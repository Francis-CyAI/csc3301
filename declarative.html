<!DOCTYPE html>
<html class="writer-html5" lang="en" >

<!-- Mirrored from eecs390.github.io/notes/declarative.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic Programming &mdash; Programming Language Principles and Paradigms 0.4 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/style-extra.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/general.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/dark.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery3b25.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compatfa9a.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options804b.js?v=7f00635f"></script>
        <script src="_static/doctools56c1.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight7f57.js?v=dc90522c"></script>
        <script src="_static/js-extraf31b.js?v=c32e72a1"></script>
        <script async="async" src="../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-mml-chtml.js"></script>
        <script src="_static/dark_mode_js/default_light679c.js?v=c2e647ce"></script>
        <script src="_static/dark_mode_js/theme_switcher2b7c.js?v=358d3910"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Macros and Code Generation" href="metaprogramming.html" />
    <link rel="prev" title="Functional Data Abstraction" href="data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #C53390" >

          
          
          <a href="index-2.html" class="icon icon-home">
            Programming Language Principles and Paradigms
          </a>
              <div class="version">
                0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://eecs390.github.io/notes/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Foundations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="foundations.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-python">Basic Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#basic-data-structures">Basic Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#compound-statements">Compound Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#function-definitions">Function Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#class-definitions">Class Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#modules">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#executing-a-module">Executing a Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#python-reference-semantics">Python Reference Semantics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-elements">Basic Elements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#levels-of-description">Levels of Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#lexical-structure">Lexical Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#semantics">Semantics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#entities-objects-and-variables">Entities, Objects, and Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#l-values-and-r-values">L-Values and R-Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statements">Statements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#names-and-environments">Names and Environments</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#blocks">Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#name-lookup">Name Lookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#nested-inline-blocks">Nested Inline Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#scope-in-functions">Scope in Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#id2">Static Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#dynamic-scope">Dynamic Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#point-of-declaration-or-definition">Point of Declaration or Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#control-flow">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expression-sequencing">Expression Sequencing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#short-circuiting">Short Circuiting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#explicit-sequences">Explicit Sequences</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#compound-assignment">Compound Assignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statement-sequences">Statement Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#unstructured-transfer-of-control">Unstructured Transfer of Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#structured-control">Structured Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loops">Loops</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loop-termination">Loop Termination</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#memory-management">Memory Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#storage-duration-classes">Storage Duration Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#static-storage">Static Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#automatic-storage">Automatic Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#thread-local-storage">Thread-Local Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#dynamic-storage">Dynamic Storage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#value-and-reference-semantics">Value and Reference Semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#raii-and-scope-based-resource-management">RAII and Scope-Based Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#garbage-collection">Garbage Collection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#reference-counting">Reference Counting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#tracing-collectors">Tracing Collectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#finalizers">Finalizers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#grammars">Grammars</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#context-free-grammars">Context-Free Grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#grammars-in-programming-languages">Grammars in Programming Languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#vexing-parse">Vexing Parse</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functional Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="functional.html">Introduction to Scheme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#compound-values">Compound Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#symbolic-data">Symbolic Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#functions">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#default-arguments">Default Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#variadic-functions">Variadic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#parameter-passing">Parameter Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#evaluation-of-function-calls">Evaluation of Function Calls</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#recursion">Recursion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#activation-records">Activation Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#tail-recursion">Tail Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#higher-order-functions">Higher-Order Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#function-objects">Function Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#functions-as-parameters">Functions as Parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#function-pointers">Function Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#binding-policy">Binding Policy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#nested-functions">Nested Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#decorators">Decorators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#lambda-functions">Lambda Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#scheme">Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#python">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#java">Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#common-patterns">Common Patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#sequence-patterns">Sequence Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="functional.html#map">Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#reduce">Reduce</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#filter">Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#any">Any</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#composition">Composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#partial-application-and-currying">Partial Application and Currying</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#continuations">Continuations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#restricted-continuations">Restricted Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#subroutines">Subroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#exceptions">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#generators">Generators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#first-class-continuations">First-Class Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#signaling-errors">Signaling Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#call-and-return">Call and Return</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#id11">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Lambda Calculus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#non-terminating-computation">Non-Terminating Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#normal-order-evaluation">Normal-Order Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#encoding-data">Encoding Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#booleans">Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#pairs">Pairs</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#church-numerals">Church Numerals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#equivalent-models">Equivalent Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#operational-semantics">Operational Semantics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#language">Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#states-and-transitions">States and Transitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#arithmetic-expressions">Arithmetic Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#order-of-evaluation">Order of Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#boolean-expressions">Boolean Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#statements">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#operational-semantics-for-lambda-calculus">Operational Semantics for Lambda Calculus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#formal-type-systems">Formal Type Systems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#subtyping">Subtyping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-arithmetic-operators">Subtyping and Arithmetic Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#the-top-type">The Top Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-functions">Subtyping and Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#full-typing-rules">Full Typing Rules</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Abstraction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="data.html">Functional Data Abstraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#pairs-and-lists">Pairs and Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#lists">Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#dictionaries">Dictionaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#dispatch-dictionaries">Dispatch Dictionaries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#object-oriented-programming">Object-Oriented Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#members">Members</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#access-control">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#kinds-of-methods">Kinds of Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#nested-and-local-classes">Nested and Local Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#inheritance-and-polymorphism">Inheritance and Polymorphism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#types-of-inheritance">Types of Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#class-hierarchies">Class Hierarchies</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#method-overriding">Method Overriding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#covariance-and-contravariance">Covariance and Contravariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#accessing-hidden-or-overridden-members">Accessing Hidden or Overridden Members</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#implementing-dynamic-binding">Implementing Dynamic Binding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#full-lookup-and-dispatch-process">Full Lookup and Dispatch Process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#multiple-inheritance">Multiple Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#dictionary-based-implementation">Dictionary-Based Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#record-based-implementation">Record-Based Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#static-analysis">Static Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-equivalence">Type Equivalence</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-compatibility">Type Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-inference">Type Inference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#control-flow-analysis">Control-Flow Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#dynamic-typing">Dynamic Typing</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html#generics">Generics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#implicit-parametric-polymorphism">Implicit Parametric Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#explicit-parametric-polymorphism">Explicit Parametric Polymorphism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#non-type-parameters">Non-Type Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#constraints">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#java-generics">Java Generics</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#curiously-recurring-template-pattern">Curiously Recurring Template Pattern</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#duck-typing">Duck Typing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#modules-and-namespaces">Modules and Namespaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#translation-units">Translation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#modules-packages-and-namespaces">Modules, Packages, and Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#linkage">Linkage</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#information-hiding">Information Hiding</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#initialization">Initialization</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Declarative Programming</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Logic Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prolog">Prolog</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lists">Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic">Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#side-effects">Side Effects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unification-and-search">Unification and Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#search-order-and-backtracking">Search Order and Backtracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-cut-operator">The Cut Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#negation">Negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#constraints-and-dependencies">Constraints and Dependencies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#constraint-logic-programming">Constraint Logic Programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#search">Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#make">Make</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pattern-matching">Pattern Matching</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Metaprogramming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html">Macros and Code Generation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#scheme-macros">Scheme Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#cpp-macros">CPP Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="metaprogramming.html#stringification-and-concatenation">Stringification and Concatenation</a></li>
<li class="toctree-l3"><a class="reference internal" href="metaprogramming.html#the-macro-namespace">The Macro Namespace</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#code-generation">Code Generation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html#template-metaprogramming">Template Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#pairs">Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#numerical-computations">Numerical Computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#templates-and-function-overloading">Templates and Function Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#sfinae">SFINAE</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#ensuring-a-substitution-failure">Ensuring a Substitution Failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#variadic-templates">Variadic Templates</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html#example-multidimensional-arrays">Example: Multidimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#points">Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#domains">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#stencil">Stencil</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#nested-iteration">Nested Iteration</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Concurrent Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#parallelism-in-python">Parallelism in Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#threading">Threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#multiprocessing">Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#the-problem-with-shared-state">The Problem with Shared State</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#when-no-synchronization-is-necessary">When No Synchronization is Necessary</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronized-data-structures">Synchronized Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#locks">Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#barriers">Barriers</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#application-examples">Application Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#web-crawler">Web Crawler</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#particle-simulator">Particle Simulator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronization-pitfalls">Synchronization Pitfalls</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#under-synchronization">Under-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#over-synchronization">Over-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#deadlock">Deadlock</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html#asynchronous-tasks">Asynchronous Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#limiting-the-number-of-tasks">Limiting the Number of Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#launch-policy">Launch Policy</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #C53390" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index-2.html">Programming Language Principles and Paradigms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index-2.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Logic Programming</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="data.html" class="btn btn-neutral float-left" title="Functional Data Abstraction" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="metaprogramming.html" class="btn btn-neutral float-right" title="Macros and Code Generation" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Declarative Programming</h1><p>Most of the languages we’ve considered so far in this text have
followed the imperative programming model, where a computation is
decomposed into individual statements that modify the state of the
program. These languages have also been procedural, grouping
statements into subroutines that are then called explicitly.</p>
<p>We have also seen the functional programming model, which decomposes a
computation into functions that are closely related to those in
mathematics. In such a model, programming is done with expressions
that avoid side effects. We have also considered specific languages
that provide a mix of the functional and imperative paradigms.</p>
<p>Functional programs are <em>declarative</em>, since they declare a
relationship between the inputs and outputs of a function. We turn our
attention to other models that are declarative, including those that
express computation using logical relations, constraints, and
dependencies.</p>
<section id="logic-programming">
<h1>Logic Programming<a class="headerlink" href="#logic-programming" title="Link to this heading"></a></h1>
<p>Whereas functional programming is based on the theoretical foundations
of <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, logic programming is based on the
foundation of formal logic. More specifically, it is based on
<em>first-order predicate calculus</em>, which expresses quantified
statements such as:</p>
<div class="math notranslate nohighlight">
\[\forall X.~ \exists Y.~ P(X) ~\vee~ \neg Q(Y).\]</div>
<p>This states that for every value <code class="docutils literal notranslate"><span class="pre">X</span></code>, over some implicit universe of
values, there is some value <code class="docutils literal notranslate"><span class="pre">Y</span></code> such that either <code class="docutils literal notranslate"><span class="pre">P(X)</span></code> is true or
<code class="docutils literal notranslate"><span class="pre">Q(Y)</span></code> is false or both. This specific statement can also be written
in the form of an implication:</p>
<div class="math notranslate nohighlight">
\[\forall X.~ \exists Y.~ Q(Y) ~\Longrightarrow~ P(X).\]</div>
<p>The implication <span class="math notranslate nohighlight">\(a ~\Longrightarrow~ b\)</span> is equivalent to
<span class="math notranslate nohighlight">\(\neg a ~\vee~ b\)</span>.</p>
<p>In most logic languages, a program is specified in terms of <em>axioms</em>
that are assumed to be true, and a programmer specifies a <em>goal</em> that
the system should attempt to prove from the set of axioms. An axiom is
usually written in the form of a <em>Horn clause</em>, which has the
following structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="p">:</span><span class="o">-</span> <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">BN</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:-</span></code> symbol specifies a reverse implication, and the comma is
used for conjunction. The equivalent form in predicate calculus is:</p>
<div class="math notranslate nohighlight">
\[(B_1 ~\wedge~ B_2 ~\wedge~ \dots ~\wedge~ B_N) ~\Longrightarrow~ H\]</div>
<p>In the Horn clause above, <code class="docutils literal notranslate"><span class="pre">H</span></code> is the <em>head</em> of the clause, while
<code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">B2,</span> <span class="pre">...,</span> <span class="pre">BN</span></code> is the <em>body</em>. In natural language, the Horn
clause is stating that if <code class="docutils literal notranslate"><span class="pre">B1</span></code> is true, and <code class="docutils literal notranslate"><span class="pre">B2</span></code> is true, …, and
<code class="docutils literal notranslate"><span class="pre">BN</span></code> is true, then it must be that <code class="docutils literal notranslate"><span class="pre">H</span></code> is also true. (Quantifiers
are implicit in a Horn clause, though we will not discuss the details
here.)</p>
<p>The individual elements of a Horn clause, such as <code class="docutils literal notranslate"><span class="pre">H</span></code> or <code class="docutils literal notranslate"><span class="pre">B2</span></code>
above, are called <em>terms</em>. A term may be a variable, an <em>atom</em> in the
form of a symbol, or a compound term, such as a <em>predicate</em> applied to
some arguments which are themselves terms.</p>
<p>A set of Horn clauses establishes <em>relations</em> among data, which we can
then use to query whether a relation holds or what pieces of data
satisfy a particular relation.</p>
<p>As a concrete example, consider the following clauses that represent
familial relationships:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span>                 <span class="o">%</span> <span class="n">rule</span> <span class="mi">1</span>
<span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">father</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span>                 <span class="o">%</span> <span class="n">rule</span> <span class="mi">2</span>
<span class="n">sibling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span>  <span class="o">%</span> <span class="n">rule</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Here, we have stated three <em>rules</em>. The first establishes that if
<code class="docutils literal notranslate"><span class="pre">P</span></code> is the mother of <code class="docutils literal notranslate"><span class="pre">C</span></code>, then <code class="docutils literal notranslate"><span class="pre">P</span></code> is also a parent of <code class="docutils literal notranslate"><span class="pre">C</span></code>.
The second states that if <code class="docutils literal notranslate"><span class="pre">P</span></code> is the father of <code class="docutils literal notranslate"><span class="pre">C</span></code>, then <code class="docutils literal notranslate"><span class="pre">P</span></code> is
also a parent of <code class="docutils literal notranslate"><span class="pre">C</span></code>. The last rule states that if <code class="docutils literal notranslate"><span class="pre">P</span></code> is a parent
of <code class="docutils literal notranslate"><span class="pre">A</span></code>, and <code class="docutils literal notranslate"><span class="pre">P</span></code> is also a parent of <code class="docutils literal notranslate"><span class="pre">B</span></code>, then <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>
are siblings.</p>
<p>We can state some specific relationships as <em>facts</em>, which are Horn
clauses without a body and thus are unconditionally true:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">)</span><span class="o">.</span>      <span class="o">%</span> <span class="n">fact</span> <span class="mi">1</span>
<span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">charlie</span><span class="p">)</span><span class="o">.</span>   <span class="o">%</span> <span class="n">fact</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We can give the logic interpreter a query of the form <code class="docutils literal notranslate"><span class="pre">sibling(bill,</span>
<span class="pre">S)</span></code>. The interpreter will then attempt to solve this query using a
process known as <em>resolution</em>, which applies rules to existing
information. Part of this process is <em>unification</em>, which connects
terms that match. One possible resolution sequence for the query
above is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">sibling</span><span class="p">(</span><span class="n">bill</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">bill</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>                 <span class="p">(</span><span class="n">rule</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">bill</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>                 <span class="p">(</span><span class="n">rule</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>         <span class="p">(</span><span class="n">fact</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">),</span> <span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>         <span class="p">(</span><span class="n">rule</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">),</span> <span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">charlie</span><span class="p">)</span>   <span class="p">(</span><span class="n">fact</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The end result in this sequence would be that <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">charlie</span></code>.</p>
<p>In the process above, the third step unifies the term <code class="docutils literal notranslate"><span class="pre">mother(P,</span>
<span class="pre">bill)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code>, which in turn unifies <code class="docutils literal notranslate"><span class="pre">P</span></code> with
<code class="docutils literal notranslate"><span class="pre">molly</span></code>. This unification is reflected in all occurrences of <code class="docutils literal notranslate"><span class="pre">P</span></code>,
resulting in the second term becoming <code class="docutils literal notranslate"><span class="pre">parent(molly,</span> <span class="pre">S)</span></code>.
Unification is a generalized form of variable binding, except that
full terms can be unified with each other rather than just binding
variables to values.</p>
<p>In our formulation of familial relationships, however, there is
nothing preventing the resolution engine from applying <code class="docutils literal notranslate"><span class="pre">mother(molly,</span>
<span class="pre">bill)</span></code> in resolving <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">S)</span></code>, so another perfectly valid
solution is that <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">bill</span></code>. We will see later how to fix this
specific problem in Prolog.</p>
<section id="prolog">
<h2>Prolog<a class="headerlink" href="#prolog" title="Link to this heading"></a></h2>
<p>Before we proceed further in our exploration of logic programming, let
us introduce a concrete programming language to work with. Among logic
languages, Prolog is by far the most popular, and many implementations
are available. For the purposes of this text, we will use a specific
interpreter called <a class="reference external" href="http://www.swi-prolog.org/">SWI-Prolog</a>, of which
there is also a <a class="reference external" href="http://swish.swi-prolog.org/">web-based version</a>.</p>
<p>The syntax we used above is actually that of Prolog. A Prolog program
consists of a set of Horn clauses that are assumed to be true. A
clause is composed of a head term and zero or more body terms, and a
term may be atomic, compound, or a variable. An atomic term may be an
<em>atom</em>, which is either a Scheme-like symbol or a quoted string. The
following are all atoms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hello</span>    <span class="o">=&lt;</span>    <span class="o">+</span>    <span class="s1">&#39;logic programming&#39;</span>
</pre></div>
</div>
<p>If an atom starts with a letter, then that letter must be lowercase.
Thus, <code class="docutils literal notranslate"><span class="pre">hEllo</span></code> is an atom, but <code class="docutils literal notranslate"><span class="pre">Hello</span></code> is not. Numbers, which can
be integer or floating-point, are also atomic terms.</p>
<p>Variables are identifiers that begin with a capital letter. Thus,
<code class="docutils literal notranslate"><span class="pre">Hello</span></code> is a variable, as are <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<p>Compound terms consist of a <em>functor</em>, which is itself an atom,
followed by a list of one or more argument terms. The following are
compound terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="n">wizard</span><span class="p">(</span><span class="n">harry</span><span class="p">)</span>    <span class="n">writeln</span><span class="p">(</span><span class="n">hello</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
</pre></div>
</div>
<p>A compound term is interpreted as a <em>predicate</em>, meaning that it has a
truth value, when it occurs as the head term or one of the body terms
of a clause, as well as when it is the goal query. Otherwise, it is
generally interpreted as data, as in <code class="docutils literal notranslate"><span class="pre">hello(world)</span></code> in
<code class="docutils literal notranslate"><span class="pre">writeln(hello(world))</span></code>.</p>
<p>While the syntax of a compound term resembles that of a function call
in many imperative or functional languages, Prolog does not have
functions, so a compound term is never interpreted as such.</p>
<p>A Horn clause with no body is a fact, since it is always true. Thus,
the following are facts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">)</span><span class="o">.</span>
<span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">charlie</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Notice the period that signifies the end of a clause.</p>
<p>A Horn clause with a body is called a rule, and it consists of a head
term, the reverse implication symbol (<code class="docutils literal notranslate"><span class="pre">:-</span></code>), and one or more body
terms, separated by commas. The comma signifies conjunction so that
the head is true when all the body terms are true. The following are
rules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span>
<span class="n">sibling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">parent</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>The first rule states that if <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">C)</span></code> is true, then
<code class="docutils literal notranslate"><span class="pre">parent(P,</span> <span class="pre">C)</span></code> is also true. The second rule states that if both
<code class="docutils literal notranslate"><span class="pre">parent(P,</span> <span class="pre">A)</span></code> and <code class="docutils literal notranslate"><span class="pre">parent(P,</span> <span class="pre">B)</span></code> are true, then <code class="docutils literal notranslate"><span class="pre">sibling(A,</span> <span class="pre">B)</span></code>
is true.</p>
<p>A program is composed of a set of facts and rules. Once these have
been established, we can query the Prolog interpreter with a a goal
predicate. The interpreter will attempt to establish that the goal is
true, and if it contains variables, instantiate them with terms that
result in the satisfaction of the goal. If the query succeeds, the
interpreter reports success, along with the terms that the variables
unified with in order to establish the result. If more than one
solution may exist, we can ask for the next one using a semicolon in
most interpreters. If we ask for a solution and no more exist, the
interpreter reports failure.</p>
<p>As an example, consider the query <code class="docutils literal notranslate"><span class="pre">sibling(bill,</span> <span class="pre">S)</span></code>. Loading a file
containing the two facts and rules above will result in the
interactive prompt <code class="docutils literal notranslate"><span class="pre">?-</span></code> (For now, we have elided the <code class="docutils literal notranslate"><span class="pre">parent</span></code> rule
that depended on <code class="docutils literal notranslate"><span class="pre">father</span></code>, since we haven’t established any
<code class="docutils literal notranslate"><span class="pre">father</span></code> facts and our Prolog interpreter will report an error as a
result.):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- sibling(bill, S).
S = bill ;
S = charlie.
</pre></div>
</div>
<p>At the prompt, we’ve entered the query followed by a period to signify
the end of the query. The interpreter reports <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">bill</span></code> as the
first result, and we have the option of entering a semicolon to search
for another or a period to end the query. We enter a semicolon, and
the interpreter finds and reports <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">charlie</span></code>, as well as a period
to indicate its certainty that no more solutions exist.</p>
<p>The actual order in which Prolog searches for a result is
deterministic, as we will see shortly. Thus, the query will always
find <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">bill</span></code> as its first result and <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">charlie</span></code> as its
second.</p>
<section id="lists">
<h3>Lists<a class="headerlink" href="#lists" title="Link to this heading"></a></h3>
<p>Compound terms, which can relate multiple individual terms, allow us
to represent data structures. For example, we can use the compound
term <code class="docutils literal notranslate"><span class="pre">pair(First,</span> <span class="pre">Second)</span></code> to represent a pair composed of <code class="docutils literal notranslate"><span class="pre">First</span></code>
and <code class="docutils literal notranslate"><span class="pre">Second</span></code>. The term will not appear on its own as a head or body
term, so it will be treated as data. We can then define relations for
lists as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cons</span><span class="p">(</span><span class="n">First</span><span class="p">,</span> <span class="n">Second</span><span class="p">,</span> <span class="n">pair</span><span class="p">(</span><span class="n">First</span><span class="p">,</span> <span class="n">Second</span><span class="p">))</span><span class="o">.</span>
<span class="n">car</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="n">First</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">First</span><span class="p">)</span><span class="o">.</span>
<span class="n">cdr</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">Second</span><span class="p">),</span> <span class="n">Second</span><span class="p">)</span><span class="o">.</span>
<span class="n">is_null</span><span class="p">(</span><span class="n">nil</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>In the clauses above, an underscore represents an anonymous variable.
Many Prolog implementations will raise a warning if a variable is used
only once in a clause – such a variable is called a <em>singleton</em>, and
it can be introduced inadvertently due to a typo, as in the
following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cons</span><span class="p">(</span><span class="n">First</span><span class="p">,</span> <span class="n">Second</span><span class="p">,</span> <span class="n">pair</span><span class="p">(</span><span class="n">Frist</span><span class="p">,</span> <span class="n">Second</span><span class="p">))</span><span class="o">.</span>
</pre></div>
</div>
<p>Here, we misspelled <code class="docutils literal notranslate"><span class="pre">First</span></code> as <code class="docutils literal notranslate"><span class="pre">Frist</span></code>, so that both are singleton
variables. The warning from the Prolog interpreter directs our
attention to this, so that we can fix it. If, on the other hand, we do
intend a variable to be used only once, we can start it with an
underscore to inform the implementation of that intent. We can also
use a lone underscore, and each occurrence of a solitary underscore is
considered a separate, anonymous variable.</p>
<p>We’ve set <code class="docutils literal notranslate"><span class="pre">nil</span></code> as our representation for an empty list. We can then
make queries on lists as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- cons(1, nil, X).
X = pair(1, nil).

?- car(pair(1, pair(2, nil)), X).
X = 1.

?- cdr(pair(1, pair(2, nil)), X).
X = pair(2, nil).

?- cdr(pair(1, pair(2, nil)), X), car(X, Y), cdr(X, Z).
X = pair(2, nil),
Y = 2,
Z = nil.

?- is_null(nil).
true.

?- is_null(pair(1, pair(2, nil))).
false.
</pre></div>
</div>
<p>In the fourth example, we’ve used conjunction to obtain the cdr of the
original list, as well as the car and the cdr of the result.</p>
<p>As in Scheme, lists are a fundamental data structure in Prolog, so
Prolog provides its own syntax for lists. A list can be specified by
placing elements in square brackets, separated by commas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
<span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">)]</span>
</pre></div>
</div>
<p>A list can be decomposed into a number of items followed by a rest,
much like the period in Scheme, using a pipe:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- writeln([1, 2 | [3, 4]]).   % similar to (1 2 . (3 4)) in Scheme
[1,2,3,4]
true.
</pre></div>
</div>
<p>We can use this syntax to write rules on lists. For example, a contains
predicate is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">contains</span><span class="p">([</span><span class="n">Item</span><span class="o">|</span><span class="n">_Rest</span><span class="p">],</span> <span class="n">Item</span><span class="p">)</span><span class="o">.</span>
<span class="n">contains</span><span class="p">([</span><span class="n">_First</span><span class="o">|</span><span class="n">Rest</span><span class="p">],</span> <span class="n">Item</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span>
    <span class="n">contains</span><span class="p">(</span><span class="n">Rest</span><span class="p">,</span> <span class="n">Item</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>The first clause asserts that a list whose first element is <code class="docutils literal notranslate"><span class="pre">Item</span></code>
contains <code class="docutils literal notranslate"><span class="pre">Item</span></code>. The second clause states that a list contains
<code class="docutils literal notranslate"><span class="pre">Item</span></code> if the remaining list, excluding the first item, contains
<code class="docutils literal notranslate"><span class="pre">Item</span></code>. Thus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- contains([], a).
false.

?- contains([a], a).
true .

?- contains([b, c, a, d], a).
true .
</pre></div>
</div>
<p>The built-in <code class="docutils literal notranslate"><span class="pre">member</span></code> predicate works similarly to our definition of
<code class="docutils literal notranslate"><span class="pre">contains</span></code>, except that it takes the arguments in reverse order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- member(a, []).
false.

?- member(a, [a]).
true.
</pre></div>
</div>
</section>
<section id="arithmetic">
<h3>Arithmetic<a class="headerlink" href="#arithmetic" title="Link to this heading"></a></h3>
<p>Prolog provides numbers, as well as comparison predicates on numbers.
For convenience, these predicates may be written in infix order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- 3 =&lt; 4.    % less than or equal
true.

?- 4 =&lt; 3.
false.

?- 3 =:= 3.   % equal (for arithmetic)
true.

?- 3 =\= 3.   % not equal (for arithmetic)
false.
</pre></div>
</div>
<p>Prolog also provides arithmetic operators, but they merely represent
compound terms. Thus, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">4</span></code> is another means of writing the
compound term <code class="docutils literal notranslate"><span class="pre">+(3,</span> <span class="pre">4)</span></code>. If we attempt to unify this with 7 using
the explicit unification operator <code class="docutils literal notranslate"><span class="pre">=</span></code>, it will fail:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- 7 = 3 + 4.
false.
</pre></div>
</div>
<p>Similarly, if we attempt to unify a variable with an arithmetic
expression, it will be unified with the compound term itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- X = 3 + 4.
X = 3+4.
</pre></div>
</div>
<p>Comparison operators, however, do evaluate the arithmetic expressions
in their operands::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- 7 =:= 3 + 4.
true.

?- 2 + 5 =:= 3 + 4.
true.

?- 4 &lt; 3 + 2.
true.
</pre></div>
</div>
<p>In order for the operands to be evaluated, variables in the operands
must be <em>instantiated</em> with numeric values. A comparison cannot be
applied to an uninstantiated variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- X =:= 3 + 4.
ERROR: Arguments are not sufficiently instantiated
</pre></div>
</div>
<p>Instead, the <code class="docutils literal notranslate"><span class="pre">is</span></code> operator is defined to unify its first argument
with the arithmetic result of its second argument, allowing the first
argument to be an uninstantiated variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- 7 is 3 + 4.
true.

?- X is 3 + 4.
X = 7.

?- X is 3 + 4, X =:= 7.
X = 7.

?- X is 3 + 4, X = 7.
X = 7.
</pre></div>
</div>
<p>In the third example, <code class="docutils literal notranslate"><span class="pre">X</span></code> is unified with 7, the result of adding 3
and 4. Since <code class="docutils literal notranslate"><span class="pre">X</span></code> is now instantiated with 7, it can be compared
to 7. In the fourth example, <code class="docutils literal notranslate"><span class="pre">X</span></code> is 7 so it unifies with the
number 7.</p>
<p>We can use this to define a length predicate on our list
representation above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span>
<span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">Second</span><span class="p">),</span> <span class="n">Length</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span>
    <span class="nb">len</span><span class="p">(</span><span class="n">Second</span><span class="p">,</span> <span class="n">SecondLength</span><span class="p">),</span> <span class="n">Length</span> <span class="ow">is</span> <span class="n">SecondLength</span> <span class="o">+</span> <span class="mf">1.</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">Length</span></code> is unified with the arithmetic result of adding 1 to
<code class="docutils literal notranslate"><span class="pre">SecondLength</span></code>. This must occur after the recursive application of
<code class="docutils literal notranslate"><span class="pre">len</span></code>, so that <code class="docutils literal notranslate"><span class="pre">SecondLength</span></code> is sufficiently instantiated to be
able to perform arithmetic on it. Then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- len(nil, X).
X = 0.

?- len(pair(1, pair(b, nil)), X).
X = 2.
</pre></div>
</div>
</section>
<section id="side-effects">
<h3>Side Effects<a class="headerlink" href="#side-effects" title="Link to this heading"></a></h3>
<p>Prolog provides several predicates that perform input and output.
We’ve already used the <code class="docutils literal notranslate"><span class="pre">writeln</span></code> predicate, which writes a term to
standard out and then writes a newline. The <code class="docutils literal notranslate"><span class="pre">write</span></code> predicate also
writes a term to standard out, but without a trailing newline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- X = 3, write(&#39;The value of X is: &#39;), writeln(X).
The value of X is: 3
X = 3.
</pre></div>
</div>
<p>We will not discuss the remaining I/O routines here.</p>
</section>
</section>
<section id="unification-and-search">
<span id="id1"></span><h2>Unification and Search<a class="headerlink" href="#unification-and-search" title="Link to this heading"></a></h2>
<p>The core computational engine in Prolog revolves around unification
and search. The search procedure takes a set of goal terms and looks
for a clause that has a head that can unify with one of the terms. The
unification process can recursively unify subterms, which may
instantiate or unify variables. If the current term unifies with the
head of a clause, then the body terms, with variables suitably
instantiated, are added to the set of goal terms. The search process
succeeds when no more goal terms remain.</p>
<p>This process of starting from goal terms and working backwards,
replacing heads with bodies, is called <em>backward chaining</em>. A logic
interpreter may use <em>forward chaining</em> instead, which starts from
facts and works forward to derive the goal. However, Prolog is defined
to use backward chaining.</p>
<p>The unification rules for two terms in Prolog are as follows:</p>
<ol class="arabic simple">
<li><p>An atomic term only unifies with itself.</p></li>
<li><p>An uninstantiated variable unifies with any term. If the other term
is not a variable, then the variable is instantiated with the value
of the other term. If the other term is another variable, then the
two variables are bound together such that if one of them is later
instantiated with a value, then so is the other.</p></li>
<li><p>A compound term unifies with another compound term that has
the same functor and number of arguments, and only if the arguments
of the two compound terms also unify.</p></li>
</ol>
<p>As stated by the first rule, the atomic term 1 only unifies with 1,
and the term <code class="docutils literal notranslate"><span class="pre">abc</span></code> only unifies with <code class="docutils literal notranslate"><span class="pre">abc</span></code>.</p>
<p>The second rule states that a variable <code class="docutils literal notranslate"><span class="pre">X</span></code> unifies with a
non-variable by instantiating it to the given value. This essentially
means that all occurrences of the variable are replaced with the given
value. Thus <code class="docutils literal notranslate"><span class="pre">X</span></code> unifies with 3 by instantiating <code class="docutils literal notranslate"><span class="pre">X</span></code> with 3, <code class="docutils literal notranslate"><span class="pre">Y</span></code>
unifies with <code class="docutils literal notranslate"><span class="pre">foo(1,</span> <span class="pre">3)</span></code> by instantiating it with <code class="docutils literal notranslate"><span class="pre">foo(1,</span> <span class="pre">3)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">Z</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">foo(A,</span> <span class="pre">B)</span></code> by instantiating it with <code class="docutils literal notranslate"><span class="pre">foo(A,</span>
<span class="pre">B)</span></code>.</p>
<p>A variable unifies with another variable by binding them together.
Thus, if <code class="docutils literal notranslate"><span class="pre">X</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and if <code class="docutils literal notranslate"><span class="pre">Y</span></code> is later instantiated
with 3, then <code class="docutils literal notranslate"><span class="pre">X</span></code> is also instantiated with 3.</p>
<p>The last rule states that a compound term such as <code class="docutils literal notranslate"><span class="pre">foo(1,</span> <span class="pre">X)</span></code>
unifies with <code class="docutils literal notranslate"><span class="pre">foo(Y,</span> <span class="pre">3)</span></code> by recursively unifying the arguments, such
that <code class="docutils literal notranslate"><span class="pre">Y</span></code> is instantiated with 1 and <code class="docutils literal notranslate"><span class="pre">X</span></code> with 3.</p>
<p>Care must be taken in the search process to treat variables that appear
in independent contexts as independent, even if they have the same name.
Thus, given the clause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">bar</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>and the goal <code class="docutils literal notranslate"><span class="pre">foo(3,</span> <span class="pre">X)</span></code>, the variable <code class="docutils literal notranslate"><span class="pre">X</span></code> should be treated as
distinct in the contexts of the goal and the clause. One way to
accomplish this is renaming before applying a rule, analogous to
<span class="math notranslate nohighlight">\(\alpha\)</span>-reduction in <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">Y1</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">bar</span><span class="p">(</span><span class="n">Y1</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Thus, unifying the goal <code class="docutils literal notranslate"><span class="pre">foo(3,</span> <span class="pre">X)</span></code> with the head <code class="docutils literal notranslate"><span class="pre">foo(X1,</span> <span class="pre">Y1)</span></code>
produces <code class="docutils literal notranslate"><span class="pre">X1</span> <span class="pre">=</span> <span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">Y1</span> <span class="pre">=</span> <span class="pre">X</span></code>, resulting in the subsequent goal
<code class="docutils literal notranslate"><span class="pre">bar(X,</span> <span class="pre">3)</span></code>.</p>
<section id="search-order-and-backtracking">
<h3>Search Order and Backtracking<a class="headerlink" href="#search-order-and-backtracking" title="Link to this heading"></a></h3>
<p>In pure logic programming, the order in which clauses are applied and
body terms are resolved doesn’t matter as long as the search process
terminates. However, since Prolog has side effects and non-pure
operations, it specifies a well-defined order for both. In particular,
clauses for a predicate are attempted to be applied in program order,
and terms in a conjunction are resolved from left to right. This
provides the programmer with some control over how computation
proceeds, which can be used to improve efficiency as well as sequence
side effects.</p>
<p>A search process that goes down one path may end up in a dead end,
where no clauses can be applied to a goal term. This should not
immediately result in failure, since changing a previous decision made
by the search may lead to a solution. Thus, the search process
performs <em>backtracking</em> on failure, or even on success if a user
requests more solutions. This reverts the search process to the last
choice point with remaining options, at which a different choice is
made about which clause to apply.</p>
<p>As an example, consider the following clauses:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span>

<span class="n">mother</span><span class="p">(</span><span class="n">lily</span><span class="p">,</span> <span class="n">harry</span><span class="p">)</span><span class="o">.</span>
<span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">bill</span><span class="p">)</span><span class="o">.</span>
<span class="n">mother</span><span class="p">(</span><span class="n">molly</span><span class="p">,</span> <span class="n">charlie</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Suppose the goal is <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code>. Then the search tree is as
in <a class="reference internal" href="#figure-prolog-search0"><span class="std std-numref">Figure 31</span></a>.</p>
<figure class="align-center" id="id5">
<span id="figure-prolog-search0"></span><a class="reference internal image-reference" href="_images/prolog_search0.svg"><img alt="_images/prolog_search0.svg" src="_images/prolog_search0.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 31 </span><span class="caption-text">The search tree for the query <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code>.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The search will first unify <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code> with the goal term
<code class="docutils literal notranslate"><span class="pre">sibling(A,</span> <span class="pre">B)</span></code>, binding <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> together and instantiating
<code class="docutils literal notranslate"><span class="pre">B</span></code> with <code class="docutils literal notranslate"><span class="pre">bill</span></code>. We use the notation <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">A</span></code> to denote that
<code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> are bound together, as in
<a class="reference internal" href="#figure-prolog-search1"><span class="std std-numref">Figure 32</span></a>.</p>
<figure class="align-center" id="id6">
<span id="figure-prolog-search1"></span><a class="reference internal image-reference" href="_images/prolog_search1.svg"><img alt="_images/prolog_search1.svg" src="_images/prolog_search1.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 32 </span><span class="caption-text">Unifying <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code> with <code class="docutils literal notranslate"><span class="pre">sibling(A,</span> <span class="pre">B)</span></code> binds <code class="docutils literal notranslate"><span class="pre">S</span></code>
and <code class="docutils literal notranslate"><span class="pre">A</span></code> together and instantiates <code class="docutils literal notranslate"><span class="pre">B</span></code> with <code class="docutils literal notranslate"><span class="pre">bill</span></code>. The body
terms <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> and <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> are added to the goal
set.</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Prolog will then add the body terms to its set of goals, so that
<code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> and <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> need to be satisfied. It then
searches for a solution to <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code>, under an environment in
which <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> are bound together and <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated
with <code class="docutils literal notranslate"><span class="pre">bill</span></code>. There are several clauses that can be applied to
satisfy <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code>, introducing a choice point. Prolog attempts
to apply clauses in program order, so the first choice the search
engine will make is to unify <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span>
<span class="pre">harry)</span></code>, as shown in <a class="reference internal" href="#figure-prolog-search2"><span class="std std-numref">Figure 33</span></a>.</p>
<figure class="align-center" id="id7">
<span id="figure-prolog-search2"></span><a class="reference internal image-reference" href="_images/prolog_search2.svg"><img alt="_images/prolog_search2.svg" src="_images/prolog_search2.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 33 </span><span class="caption-text">Unifying <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code> instantiates
<code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">lily</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> with <code class="docutils literal notranslate"><span class="pre">harry</span></code>. The goal
term <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> is satisfied, so it is removed from the goal
set.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This instantiates <code class="docutils literal notranslate"><span class="pre">A</span></code>, and therefore <code class="docutils literal notranslate"><span class="pre">S</span></code> since <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> are
bound together, with <code class="docutils literal notranslate"><span class="pre">harry</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">lily</span></code>. Then only the
goal term <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> remains, and since multiple clauses can be
applied, another choice point is introduced. The first choice is to
unify <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code>, as demonstrated
in <a class="reference internal" href="#figure-prolog-search3"><span class="std std-numref">Figure 34</span></a>.</p>
<figure class="align-center" id="id8">
<span id="figure-prolog-search3"></span><a class="reference internal image-reference" href="_images/prolog_search3.svg"><img alt="_images/prolog_search3.svg" src="_images/prolog_search3.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 34 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code> fails,
since <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does not unify
with <code class="docutils literal notranslate"><span class="pre">harry</span></code>.</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This unification fails, since it requires <code class="docutils literal notranslate"><span class="pre">B</span></code> to be unified with
<code class="docutils literal notranslate"><span class="pre">harry</span></code>. However, <code class="docutils literal notranslate"><span class="pre">B</span></code> is currently instantiated with the atom
<code class="docutils literal notranslate"><span class="pre">bill</span></code>, and two atoms only unify if they are the same, so that
<code class="docutils literal notranslate"><span class="pre">bill</span></code> and <code class="docutils literal notranslate"><span class="pre">harry</span></code> do not unify. The unification failure causes
the search engine to backtrack to the previous choice point, so that
it instead attempts to unify <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span>
<span class="pre">bill)</span></code>. <a class="reference internal" href="#figure-prolog-search4"><span class="std std-numref">Figure 35</span></a> illustrates this.</p>
<figure class="align-center" id="id9">
<span id="figure-prolog-search4"></span><a class="reference internal image-reference" href="_images/prolog_search4.svg"><img alt="_images/prolog_search4.svg" src="_images/prolog_search4.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 35 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code> fails,
since <code class="docutils literal notranslate"><span class="pre">P</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">lily</span></code>, which does not unify
with <code class="docutils literal notranslate"><span class="pre">molly</span></code>.</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This unification also fails, since it requires <code class="docutils literal notranslate"><span class="pre">P</span></code>, currently
instantiated with <code class="docutils literal notranslate"><span class="pre">lily</span></code>, to be unified with <code class="docutils literal notranslate"><span class="pre">molly</span></code>. The search
backtracks once again, trying to unify <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with
<code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code>, as shown in
<a class="reference internal" href="#figure-prolog-search5"><span class="std std-numref">Figure 36</span></a>.</p>
<figure class="align-center" id="id10">
<span id="figure-prolog-search5"></span><a class="reference internal image-reference" href="_images/prolog_search5.svg"><img alt="_images/prolog_search5.svg" src="_images/prolog_search5.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 36 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code>
fails: <code class="docutils literal notranslate"><span class="pre">P</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">lily</span></code>, which does not unify
with <code class="docutils literal notranslate"><span class="pre">molly</span></code>, and <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does
not unify with <code class="docutils literal notranslate"><span class="pre">charlie</span></code>.</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Again, the unification fails, so the search backtracks. At this point,
it has exhausted all the choices for <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code>, so it
backtracks further to the preceding choice point. Now, it makes the
choice of unifying <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code>, as
illustrated in <a class="reference internal" href="#figure-prolog-search6"><span class="std std-numref">Figure 37</span></a>.</p>
<figure class="align-center" id="id11">
<span id="figure-prolog-search6"></span><a class="reference internal image-reference" href="_images/prolog_search6.svg"><img alt="_images/prolog_search6.svg" src="_images/prolog_search6.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 37 </span><span class="caption-text">The search backtracks and unifies <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with
<code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code> instead. This instantiates <code class="docutils literal notranslate"><span class="pre">P</span></code> with
<code class="docutils literal notranslate"><span class="pre">molly</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> with <code class="docutils literal notranslate"><span class="pre">bill</span></code>.</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This instantiates <code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">molly</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> with
<code class="docutils literal notranslate"><span class="pre">bill</span></code>. Then, as shown in <a class="reference internal" href="#figure-prolog-search7"><span class="std std-numref">Figure 38</span></a>, the
search attempts to find a solution for <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code>, first
attempting to unify it with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code>.</p>
<figure class="align-center" id="id12">
<span id="figure-prolog-search7"></span><a class="reference internal image-reference" href="_images/prolog_search7.svg"><img alt="_images/prolog_search7.svg" src="_images/prolog_search7.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 38 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code> fails:
<code class="docutils literal notranslate"><span class="pre">P</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">molly</span></code>, which does not unify with
<code class="docutils literal notranslate"><span class="pre">lily</span></code>, and <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does not
unify with <code class="docutils literal notranslate"><span class="pre">harry</span></code>.</span><a class="headerlink" href="#id12" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This fails, since <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">molly</span></code> cannot unify with <code class="docutils literal notranslate"><span class="pre">lily</span></code>. Thus, the
search backtracks to the previous choice point, attempting to unify
<code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code>.
<a class="reference internal" href="#figure-prolog-search8"><span class="std std-numref">Figure 39</span></a> demonstrates this.</p>
<figure class="align-center" id="id13">
<span id="figure-prolog-search8"></span><a class="reference internal image-reference" href="_images/prolog_search8.svg"><img alt="_images/prolog_search8.svg" src="_images/prolog_search8.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 39 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code>
succeeds. No goal terms remain, so the query is satisfied with <code class="docutils literal notranslate"><span class="pre">S</span>
<span class="pre">=</span> <span class="pre">bill</span></code>.</span><a class="headerlink" href="#id13" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This succeeds. No more goal terms remain, so the query succeeds with a
solution of <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">bill</span></code>.</p>
<p>We can proceed to ask the interpreter for more solutions, which
continues the search at the last choice point. One more choice
remains, to unify <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code>, as
shown in <a class="reference internal" href="#figure-prolog-search9"><span class="std std-numref">Figure 40</span></a>.</p>
<figure class="align-center" id="id14">
<span id="figure-prolog-search9"></span><a class="reference internal image-reference" href="_images/prolog_search9.svg"><img alt="_images/prolog_search9.svg" src="_images/prolog_search9.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 40 </span><span class="caption-text">Continuing to search for more solutions, unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span>
<span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code> fails, since <code class="docutils literal notranslate"><span class="pre">B</span></code> is
instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does not unify with <code class="docutils literal notranslate"><span class="pre">charlie</span></code>.</span><a class="headerlink" href="#id14" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>However, this fails, so the search backtracks to the preceding choice
point, unifying <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code>, as
illustrated in <a class="reference internal" href="#figure-prolog-search10"><span class="std std-numref">Figure 41</span></a>.</p>
<figure class="align-center" id="id15">
<span id="figure-prolog-search10"></span><a class="reference internal image-reference" href="_images/prolog_search10.svg"><img alt="_images/prolog_search10.svg" src="_images/prolog_search10.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 41 </span><span class="caption-text">The search backtracks and unifies <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">A)</span></code> with
<code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code> instead. This instantiates <code class="docutils literal notranslate"><span class="pre">P</span></code> with
<code class="docutils literal notranslate"><span class="pre">molly</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> with <code class="docutils literal notranslate"><span class="pre">charlie</span></code>.</span><a class="headerlink" href="#id15" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Continuing the search with <code class="docutils literal notranslate"><span class="pre">P</span></code> instantiated with <code class="docutils literal notranslate"><span class="pre">molly</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>
and <code class="docutils literal notranslate"><span class="pre">S</span></code> with <code class="docutils literal notranslate"><span class="pre">charlie</span></code> reaches another choice point for
<code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code>. As <a class="reference internal" href="#figure-prolog-search11"><span class="std std-numref">Figure 42</span></a> demonstrates,
the first choice fails.</p>
<figure class="align-center" id="id16">
<span id="figure-prolog-search11"></span><a class="reference internal image-reference" href="_images/prolog_search11.svg"><img alt="_images/prolog_search11.svg" src="_images/prolog_search11.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 42 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(lily,</span> <span class="pre">harry)</span></code> fails:
<code class="docutils literal notranslate"><span class="pre">P</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">molly</span></code>, which does not unify with
<code class="docutils literal notranslate"><span class="pre">lily</span></code>, and <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does not
unify with <code class="docutils literal notranslate"><span class="pre">harry</span></code>.</span><a class="headerlink" href="#id16" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>However, the second choice of unifying <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with
<code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code> succeeds, as shown in
<a class="reference internal" href="#figure-prolog-search12"><span class="std std-numref">Figure 43</span></a>.</p>
<figure class="align-center" id="id17">
<span id="figure-prolog-search12"></span><a class="reference internal image-reference" href="_images/prolog_search12.svg"><img alt="_images/prolog_search12.svg" src="_images/prolog_search12.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 43 </span><span class="caption-text">Unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">bill)</span></code>
succeeds. No goal terms remain, so the query is satisfied with <code class="docutils literal notranslate"><span class="pre">S</span>
<span class="pre">=</span> <span class="pre">charlie</span></code>.</span><a class="headerlink" href="#id17" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Thus, we have another solution of <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">charlie</span></code>. We can then ask for
another solution, resulting in the search engine trying the last
choice for <code class="docutils literal notranslate"><span class="pre">mother(P,</span> <span class="pre">B)</span></code>, as demonstrated in
<a class="reference internal" href="#figure-prolog-search13"><span class="std std-numref">Figure 44</span></a>.</p>
<figure class="align-center" id="id18">
<span id="figure-prolog-search13"></span><a class="reference internal image-reference" href="_images/prolog_search13.svg"><img alt="_images/prolog_search13.svg" src="_images/prolog_search13.svg" width="900" /></a>
<figcaption>
<p><span class="caption-number">Figure 44 </span><span class="caption-text">Continuing to search for more solutions, unification of <code class="docutils literal notranslate"><span class="pre">mother(P,</span>
<span class="pre">B)</span></code> with <code class="docutils literal notranslate"><span class="pre">mother(molly,</span> <span class="pre">charlie)</span></code> fails, since <code class="docutils literal notranslate"><span class="pre">B</span></code> is
instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>, which does not unify with <code class="docutils literal notranslate"><span class="pre">charlie</span></code>.
No choice points remain, so the search terminates.</span><a class="headerlink" href="#id18" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This choice fails. At this point, all choice points have been
exhausted, so the interpreter reports that no more solutions can be
found. The full interpreter interaction is as follows, reflecting
the search process above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- sibling(S, bill).
S = bill ;
S = charlie ;
false.
</pre></div>
</div>
</section>
</section>
<section id="the-cut-operator">
<h2>The Cut Operator<a class="headerlink" href="#the-cut-operator" title="Link to this heading"></a></h2>
<p>By default, Prolog considers each possible alternative in turn when it
reaches a choice point. However, Prolog provides the <em>cut operator</em>,
written as <code class="docutils literal notranslate"><span class="pre">!</span></code>, to eliminate choice points associated with the
current predicate. For example, recall the <code class="docutils literal notranslate"><span class="pre">contains</span></code> predicate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">contains</span><span class="p">([</span><span class="n">Item</span><span class="o">|</span><span class="n">_Rest</span><span class="p">],</span> <span class="n">Item</span><span class="p">)</span><span class="o">.</span>
<span class="n">contains</span><span class="p">([</span><span class="n">_First</span><span class="o">|</span><span class="n">Rest</span><span class="p">],</span> <span class="n">Item</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span>
    <span class="n">contains</span><span class="p">(</span><span class="n">Rest</span><span class="p">,</span> <span class="n">Item</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>A query such as <code class="docutils literal notranslate"><span class="pre">contains([1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">2)</span></code> introduces a choice
point as to which clause to unify with the goal. The first choice
fails, since <code class="docutils literal notranslate"><span class="pre">contains([1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">2)</span></code> cannot unify with
<code class="docutils literal notranslate"><span class="pre">contains([Item|_Rest],</span> <span class="pre">Item)</span></code>. However, the second choice succeeds,
so that we have a new goal term of <code class="docutils literal notranslate"><span class="pre">contains([2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">2)</span></code>. Here
another choice point occurs, and the first choice succeeds, with
<code class="docutils literal notranslate"><span class="pre">Item</span></code> instantiated with 2 and <code class="docutils literal notranslate"><span class="pre">_Rest</span></code> instantiated with <code class="docutils literal notranslate"><span class="pre">[3,</span>
<span class="pre">4]</span></code>. Since no goal terms remain, the query as a whole succeeds.
However, the interpreter still has an unexplored choice available, so
it will report that more solutions may exist, requiring us to manually
either continue the query with a semicolon or end it with a dot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- contains([1, 2, 3, 4], 2).
true ;
false.
</pre></div>
</div>
<p>Instead, we can add the cut operator to tell the interpreter to stop
searching for alternatives once it has found a solution for
<code class="docutils literal notranslate"><span class="pre">contains([1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4],</span> <span class="pre">2)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- contains([1, 2, 3, 4], 2), !.
true.
</pre></div>
</div>
<p>We can similarly rewrite <code class="docutils literal notranslate"><span class="pre">contains</span></code> to eliminate choice points upon
success:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>contains([Item|_Rest], Item) :- !.
contains([_First|Rest], Item) :-
    contains(Rest, Item).
</pre></div>
</div>
<p>Here, as soon as a goal term unifies with <code class="docutils literal notranslate"><span class="pre">contains([Item|_Rest],</span>
<span class="pre">Item)</span></code>, the choice point of which <code class="docutils literal notranslate"><span class="pre">contains</span></code> clause to unify with
that goal term is eliminated. Thus, only one solution is found:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- contains([1, 2, 3, 4], 2).
true.
</pre></div>
</div>
<p>On the other hand, the fact that the cut operator prevents other
choices from being considered can result in queries that previously
succeeded to now fail:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- contains([1, 2, 3, 4], X), X = 3.
false.
</pre></div>
</div>
<p>Here, the first goal term succeeds by instantiating <code class="docutils literal notranslate"><span class="pre">X</span></code> with 1, and
the cut operator prevents other choices for <code class="docutils literal notranslate"><span class="pre">X</span></code> from being
considered. Then <code class="docutils literal notranslate"><span class="pre">X</span></code>, now instantiated as 1, fails to unify with 3
in the second goal term.</p>
<p>Given the potential negative consequences of eliminating choice
points, using the cut operator is often considered bad practice, so
that it should be avoided in most cases. In this text, we only use the
cut operator as part of a query, not as part of a rule.</p>
</section>
<section id="negation">
<h2>Negation<a class="headerlink" href="#negation" title="Link to this heading"></a></h2>
<p>The search above for <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code> produced the undesirable
result <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">bill</span></code>. In order to eliminate results from consideration,
Prolog provides a limited form of negation. For instance, we can
rewrite the <code class="docutils literal notranslate"><span class="pre">sibling</span></code> rule as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">A</span> \<span class="o">=</span> <span class="n">B</span><span class="p">,</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>This states that <code class="docutils literal notranslate"><span class="pre">A</span></code> must not be unifiable with <code class="docutils literal notranslate"><span class="pre">B</span></code>. Unfortunately,
our query will now fail completely:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- sibling(S, bill).
false.
</pre></div>
</div>
<p>This is because when the body term <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\=</span> <span class="pre">B</span></code> is reached, <code class="docutils literal notranslate"><span class="pre">A</span></code> is
uninstantiated while <code class="docutils literal notranslate"><span class="pre">B</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">bill</span></code>. The
unification rules above allow an uninstantiated variable to unify with
anything: <code class="docutils literal notranslate"><span class="pre">A</span></code> can unify with <code class="docutils literal notranslate"><span class="pre">B</span></code> by instantiating <code class="docutils literal notranslate"><span class="pre">A</span></code> with
<code class="docutils literal notranslate"><span class="pre">bill</span></code>. Since <code class="docutils literal notranslate"><span class="pre">A</span></code> is unifiable with <code class="docutils literal notranslate"><span class="pre">B</span></code>, the goal term <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\=</span>
<span class="pre">B</span></code> fails.</p>
<p>On the other hand, if we write the rule as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sibling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">mother</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">A</span> \<span class="o">=</span> <span class="n">B</span><span class="o">.</span>
</pre></div>
</div>
<p>then our query succeeds:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- sibling(S, bill).
S = charlie .
</pre></div>
</div>
<p>This is because <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are instantiated as atoms by the time
they get to the last term, and we can assert that two atoms not unify.</p>
<p>Prolog also provides an explicit negation predicate, <code class="docutils literal notranslate"><span class="pre">\+</span></code>. We can
therefore query whether <code class="docutils literal notranslate"><span class="pre">harry</span></code> and <code class="docutils literal notranslate"><span class="pre">bill</span></code> are not siblings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- \+(sibling(harry, bill)).
true.
</pre></div>
</div>
<p>Unfortunately, we cannot obtain a more general result from the search
engine, such as asking it to find someone who is not a sibling of
<code class="docutils literal notranslate"><span class="pre">bill</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- \+(sibling(S, bill)).
false.
</pre></div>
</div>
<p>This is because negation in Prolog is handled by attempting to prove
the term being negated, and only if the proof fails is the negation
true. However, the query <code class="docutils literal notranslate"><span class="pre">sibling(S,</span> <span class="pre">bill)</span></code> does indeed succeed with
<code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">charlie</span></code>, so negation results in false.</p>
<p>Thus, while Prolog does provide negation, it is of limited use. This
is not a deficiency in Prolog itself, but rather follows from the
limits of the logic-programming paradigm as a whole, which cannot
provide the full expressiveness of first-order predicate calculus.</p>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h2>
<p>We conclude with some more interesting examples expressed in the
logic paradigm.</p>
<ul>
<li><p>Suppose we wish to find a seven digit number such that the first
digit is the count of zeroes in the digits of the number, the second
digit is the count of ones, and so on. Using Prolog, we can express
this computation as follows. We will represent our results as a list
of digits. First, we define a predicate to count the occurrences of
a particular numerical value in a list:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">count</span><span class="p">(</span><span class="k">_</span><span class="nv">Item</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">count</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span> <span class="p">[</span><span class="nv">Item</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Count</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">count</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">RestCount</span><span class="p">),</span>
    <span class="nv">Count</span> <span class="o">is</span> <span class="nv">RestCount</span> <span class="o">+</span> <span class="mf">1.</span>
<span class="nf">count</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span> <span class="p">[</span><span class="nv">Other</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Count</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Item</span> <span class="s s-Atom">=\=</span> <span class="nv">Other</span><span class="p">,</span>
    <span class="nf">count</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">Count</span><span class="p">).</span>
</pre></div>
</div>
<p>The first rule states that an arbitrary item occurs zero times in an
empty list. The second states that if a value is the first item in a
list, then the number times it occurs in the list is one more than
the number of times it appears in the rest of the list. The last
rule states that if a value is not equal to the first item, then its
number of occurrences is that same as the number of times it appears
in the rest of the lest.</p>
<p>Next, we define facts to restrict the values of a digit:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">is_digit</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span>
<span class="nf">is_digit</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span>
</pre></div>
</div>
<p>Alternatively, we can define the <code class="docutils literal notranslate"><span class="pre">is_digit</span></code> predicate using
<code class="docutils literal notranslate"><span class="pre">member</span></code>:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">Digit</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]).</span>
</pre></div>
</div>
<p>Finally, we define a predicate to compute our result:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">digits</span><span class="p">(</span><span class="nv">List</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">List</span> <span class="o">=</span> <span class="p">[</span><span class="nv">Digit0</span><span class="p">,</span> <span class="nv">Digit1</span><span class="p">,</span> <span class="nv">Digit2</span><span class="p">,</span> <span class="nv">Digit3</span><span class="p">,</span> <span class="nv">Digit4</span><span class="p">,</span> <span class="nv">Digit5</span><span class="p">,</span> <span class="nv">Digit6</span><span class="p">],</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit0</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit1</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit2</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit3</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit4</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit5</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit6</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit0</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit1</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit2</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit3</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit4</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit5</span><span class="p">),</span>
    <span class="nf">count</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nv">List</span><span class="p">,</span> <span class="nv">Digit6</span><span class="p">).</span>
</pre></div>
</div>
<p>We start by unifying the argument <code class="docutils literal notranslate"><span class="pre">List</span></code> with a list of seven
items. We then specify that each item must be a digit. Finally, we
require that the the first item be the count of zeroes in the list,
the second the count of ones, and so on.</p>
<p>Entering our query, we get the sole result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- digits(List).
List = [3, 2, 1, 1, 0, 0, 0] ;
false.
</pre></div>
</div>
<p>We can proceed to write a predicate that relates a list of digits to
an actual number:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">digits_number</span><span class="p">([],</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">digits_number</span><span class="p">([</span><span class="nv">First</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Number</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">digits_number</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span> <span class="nv">RestNumber</span><span class="p">),</span>
    <span class="nf">length</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span> <span class="nv">RestLength</span><span class="p">),</span>
    <span class="nv">Number</span> <span class="o">is</span> <span class="nv">First</span> <span class="o">*</span> <span class="mi">10</span> <span class="s s-Atom">^</span> <span class="nv">RestLength</span> <span class="o">+</span> <span class="nv">RestNumber</span><span class="p">.</span>
</pre></div>
</div>
<p>An empty list is related to zero. Otherwise, we compute the number
represented by the list excluding its first item, as well of the
length of that list. Then the number representing the total list is
the number of the smaller list plus the multiple of the power of 10
represented by the first digit. Then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- digits(List), digits_number(List, Number), !.
List = [3, 2, 1, 1, 0, 0, 0],
Number = 3211000.
</pre></div>
</div>
</li>
<li><p>The <em>Tower of Hanoi</em> is a classic puzzle that consists of three rods
and a set of <span class="math notranslate nohighlight">\(N\)</span> discs of different sizes that slide onto a
rod. The puzzle starts with discs in ascending order from top to
bottom on a single rod, and the goal is to move the entire stack to
another rod by moving one disc at a time. It is prohibited to place
a larger disc on top of a smaller one. The solution is to
recursively move the <span class="math notranslate nohighlight">\(N-1\)</span> smaller discs to the third rod,
move the remaining, largest disc to the second rod, and then to
recursively move the other <span class="math notranslate nohighlight">\(N-1\)</span> discs to the second rod.</p>
<p>We can express this computation in Prolog as follows, using the
<code class="docutils literal notranslate"><span class="pre">write</span></code> and <code class="docutils literal notranslate"><span class="pre">writeln</span></code> predicates to print a move to standard
output:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">move</span><span class="p">(</span><span class="nv">Disc</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Target</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">write</span><span class="p">(</span><span class="s s-Atom">&#39;Move disc &#39;</span><span class="p">),</span> <span class="nf">write</span><span class="p">(</span><span class="nv">Disc</span><span class="p">),</span> <span class="nf">write</span><span class="p">(</span><span class="s s-Atom">&#39; from &#39;</span><span class="p">),</span>
    <span class="nf">write</span><span class="p">(</span><span class="nv">Source</span><span class="p">),</span> <span class="nf">write</span><span class="p">(</span><span class="s s-Atom">&#39; to &#39;</span><span class="p">),</span> <span class="nf">writeln</span><span class="p">(</span><span class="nv">Target</span><span class="p">).</span>

<span class="nf">hanoi</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Target</span><span class="p">,</span> <span class="k">_</span><span class="nv">Temporary</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">move</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Target</span><span class="p">).</span>
<span class="nf">hanoi</span><span class="p">(</span><span class="nv">NumDiscs</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Target</span><span class="p">,</span> <span class="nv">Temporary</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Previous</span> <span class="o">is</span> <span class="nv">NumDiscs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">hanoi</span><span class="p">(</span><span class="nv">Previous</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Temporary</span><span class="p">,</span> <span class="nv">Target</span><span class="p">),</span>
    <span class="nf">move</span><span class="p">(</span><span class="nv">NumDiscs</span><span class="p">,</span> <span class="nv">Source</span><span class="p">,</span> <span class="nv">Target</span><span class="p">),</span>
    <span class="nf">hanoi</span><span class="p">(</span><span class="nv">Previous</span><span class="p">,</span> <span class="nv">Temporary</span><span class="p">,</span> <span class="nv">Target</span><span class="p">,</span> <span class="nv">Source</span><span class="p">).</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">move</span></code> predicate, given a disc and source and target rods,
merely writes out the move to standard output. The <code class="docutils literal notranslate"><span class="pre">hanoi</span></code>
predicate relates a number of discs and three rods, a source rod, a
target rod, and a temporary rod. The base case is when there is one
disc, and that disc can be moved directly from source to target. The
second <code class="docutils literal notranslate"><span class="pre">hanoi</span></code> rule is the recursive case, which requires is
recursively move all but the largest disc to the temporary rod, move
the largest disc to the target rod, and then move the remaining
discs from the temporary to the target rod. Since Prolog solves the
body terms in order, the moves will occur in the right order.</p>
<p>The follows is the result of a query with <span class="math notranslate nohighlight">\(N = 4\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- hanoi(4, a, b, c).
Move disc 1 from a to c
Move disc 2 from a to b
Move disc 1 from c to b
Move disc 3 from a to c
Move disc 1 from b to a
Move disc 2 from b to c
Move disc 1 from a to c
Move disc 4 from a to b
Move disc 1 from c to b
Move disc 2 from c to a
Move disc 1 from b to a
Move disc 3 from c to b
Move disc 1 from a to c
Move disc 2 from a to b
Move disc 1 from c to b
true .
</pre></div>
</div>
</li>
<li><p>The <em>quicksort</em> algorithm sorts a list by choosing a pivot, often
the first item, partitioning the remaining list into elements that
are less than and greater than or equal to the pivot, recursively
sorting the partitions, and then appending them. The following
Prolog code expresses this:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">quicksort</span><span class="p">([],</span> <span class="p">[]).</span>
<span class="nf">quicksort</span><span class="p">([</span><span class="nv">Pivot</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Sorted</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">partition</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">GreaterOrEqual</span><span class="p">),</span>
    <span class="nf">quicksort</span><span class="p">(</span><span class="nv">Smaller</span><span class="p">,</span> <span class="nv">SortedSmaller</span><span class="p">),</span>
    <span class="nf">quicksort</span><span class="p">(</span><span class="nv">GreaterOrEqual</span><span class="p">,</span> <span class="nv">SortedGreaterOrEqual</span><span class="p">),</span>
    <span class="nf">append</span><span class="p">(</span><span class="nv">SortedSmaller</span><span class="p">,</span> <span class="p">[</span><span class="nv">Pivot</span><span class="p">|</span><span class="nv">SortedGreaterOrEqual</span><span class="p">],</span> <span class="nv">Sorted</span><span class="p">).</span>
</pre></div>
</div>
<p>The first item is chosen as the pivot, and the remaining items are
then partitioned into the smaller items and those that are greater
than or equal to the pivot. The two smaller lists are recursively
sorted, and then the results are appended, with the pivot placed
in front of the items that are greater than or equal to it, to
produce the sorted result.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">partition</span></code> predicate is as follows:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">partition</span><span class="p">(</span><span class="k">_</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]).</span>
<span class="nf">partition</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[</span><span class="nv">Item</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="p">[</span><span class="nv">Item</span><span class="p">|</span><span class="nv">Smaller</span><span class="p">],</span> <span class="nv">GreaterOrEqual</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Item</span> <span class="o">&lt;</span> <span class="nv">Pivot</span><span class="p">,</span>
    <span class="nf">partition</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">GreaterOrEqual</span><span class="p">).</span>
<span class="nf">partition</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[</span><span class="nv">Item</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="p">[</span><span class="nv">Item</span><span class="p">|</span><span class="nv">GreaterOrEqual</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nv">Item</span> <span class="o">&gt;=</span> <span class="nv">Pivot</span><span class="p">,</span>
    <span class="nf">partition</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">GreaterOrEqual</span><span class="p">).</span>
</pre></div>
</div>
<p>The first item in the list is either less than the pivot or greater
than or equal to it. In the first case, the item should be the first
one in the smaller partition, and the rest of the list is
partitioned to produce the rest of the smaller and
greater-than-or-equal partitions. In the second case, the item
should be the first one in the greater-than-or-equal partition, and
recursion handles the rest of the list.</p>
<p>Entering a query for a specific list produces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- quicksort([4, 8, 5, 3, 1, 2, 6, 9, 7], X).
X = [1, 2, 3, 4, 5, 6, 7, 8, 9] .
</pre></div>
</div>
</li>
<li><p>The <em>sieve of Eratosthenes</em> is an algorithm for computing prime
numbers up to some limit <span class="math notranslate nohighlight">\(N\)</span>. We start by constructing a list
of integers in order from 2 to <span class="math notranslate nohighlight">\(N\)</span>. Then we repeat the
following process, until no numbers remain:</p>
<ol class="arabic simple">
<li><p>The first item in the list is prime.</p></li>
<li><p>Filter out all multiples of the first item from the remaining
list.</p></li>
<li><p>Go to step 1.</p></li>
</ol>
<p>We can write this algorithm in Prolog as follows. First, we
construct a list with the integers from 2 to the limit <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">numbers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]).</span>
<span class="nf">numbers</span><span class="p">(</span><span class="nv">Limit</span><span class="p">,</span> <span class="nv">Numbers</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">LimitMinusOne</span> <span class="o">is</span> <span class="nv">Limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="nv">LimitMinusOne</span><span class="p">,</span> <span class="nv">NumbersToM</span><span class="p">),</span>
    <span class="nf">append</span><span class="p">(</span><span class="nv">NumbersToM</span><span class="p">,</span> <span class="p">[</span><span class="nv">Limit</span><span class="p">],</span> <span class="nv">Numbers</span><span class="p">).</span>
</pre></div>
</div>
<p>We do so by recursively computing a list of integers from 2 to
<span class="math notranslate nohighlight">\(N-1\)</span> and then appending <span class="math notranslate nohighlight">\(N\)</span> to the result.</p>
<p>We can then use write a predicate to filter out the multiples of a
factor from a list:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">filter_not_multiple</span><span class="p">(</span><span class="k">_</span><span class="nv">Factor</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]).</span>
<span class="nf">filter_not_multiple</span><span class="p">(</span><span class="nv">Factor</span><span class="p">,</span> <span class="p">[</span><span class="nv">Number</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span>
                    <span class="p">[</span><span class="nv">Number</span><span class="p">|</span><span class="nv">FilteredRest</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nv">Number</span> <span class="o">mod</span> <span class="nv">Factor</span> <span class="s s-Atom">=\=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nf">filter_not_multiple</span><span class="p">(</span><span class="nv">Factor</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">FilteredRest</span><span class="p">).</span>
<span class="nf">filter_not_multiple</span><span class="p">(</span><span class="nv">Factor</span><span class="p">,</span> <span class="p">[</span><span class="nv">Number</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">FilteredRest</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nv">Number</span> <span class="o">mod</span> <span class="nv">Factor</span> <span class="o">=:=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nf">filter_not_multiple</span><span class="p">(</span><span class="nv">Factor</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">FilteredRest</span><span class="p">).</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">filter_not_multiple</span></code> predicate relates a factor and a list of
numbers to a list with the multiples of the factor filtered out. The
second rule retains <code class="docutils literal notranslate"><span class="pre">Number</span></code> in the resulting list if it is not a
multiple of <code class="docutils literal notranslate"><span class="pre">Factor</span></code>. The third rule discards <code class="docutils literal notranslate"><span class="pre">Number</span></code> from the
filtered list if it is a multiple of <code class="docutils literal notranslate"><span class="pre">Factor</span></code>.</p>
<p>We can proceed to define a <code class="docutils literal notranslate"><span class="pre">sieve</span></code> predicate that relates a list
of numbers to the result of applying the prime-sieve algorithm to
the list:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">sieve</span><span class="p">([],</span> <span class="p">[]).</span>
<span class="nf">sieve</span><span class="p">([</span><span class="nv">Number</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="p">[</span><span class="nv">Number</span><span class="p">|</span><span class="nv">SievedRest</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nf">filter_not_multiple</span><span class="p">(</span><span class="nv">Number</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">,</span> <span class="nv">FilteredRest</span><span class="p">),</span>
    <span class="nf">sieve</span><span class="p">(</span><span class="nv">FilteredRest</span><span class="p">,</span> <span class="nv">SievedRest</span><span class="p">).</span>
</pre></div>
</div>
<p>The first number is retained in the result. All multiples of the
first number are filtered out of the rest of the list. The sieve
algorithm is then recursively applied to the filtered list to obtain
the rest of the result list.</p>
<p>Finally, we write a <code class="docutils literal notranslate"><span class="pre">primes</span></code> predicate that relates an integer
limit to a list of primes up to and including that limit:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">primes</span><span class="p">(</span><span class="nv">Limit</span><span class="p">,</span> <span class="nv">Primes</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="nv">Limit</span><span class="p">,</span> <span class="nv">Numbers</span><span class="p">),</span>
    <span class="nf">sieve</span><span class="p">(</span><span class="nv">Numbers</span><span class="p">,</span> <span class="nv">Primes</span><span class="p">).</span>
</pre></div>
</div>
<p>This rule constructs a list of numbers from 2 up to the limit and
then applies the sieve algorithm to the list. We can then use the
sieve to compute prime numbers up to 100:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- primes(100, P).
P = [2, 3, 5, 7, 11, 13, 17, 19, 23|...] [write]
P = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,
59, 61, 67, 71, 73, 79, 83, 89, 97] .
</pre></div>
</div>
<p>Pressing the <code class="docutils literal notranslate"><span class="pre">w</span></code> key when the solution is displayed in truncated
form causes the interpreter to print out the non-truncated form in
the second line above.</p>
<p>We can also use the built-in <code class="docutils literal notranslate"><span class="pre">numlist</span></code> predicate rather than the
<code class="docutils literal notranslate"><span class="pre">numbers</span></code> predicate we wrote:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">primes</span><span class="p">(</span><span class="nv">Limit</span><span class="p">,</span> <span class="nv">Primes</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">numlist</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">Limit</span><span class="p">,</span> <span class="nv">Numbers</span><span class="p">),</span>
    <span class="nf">sieve</span><span class="p">(</span><span class="nv">Numbers</span><span class="p">,</span> <span class="nv">Primes</span><span class="p">).</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="constraints-and-dependencies">
<h1>Constraints and Dependencies<a class="headerlink" href="#constraints-and-dependencies" title="Link to this heading"></a></h1>
<p>In addition to functional and logic programming, the declarative
paradigm includes programs that express constraints among variables
and constants as well those that describe dependency graphs. We will
look at the former in constraint logic programming and an instance of
the latter in the <code class="docutils literal notranslate"><span class="pre">make</span></code> build automation tool.</p>
<section id="constraint-logic-programming">
<h2>Constraint Logic Programming<a class="headerlink" href="#constraint-logic-programming" title="Link to this heading"></a></h2>
<p><em>Constraint logic programming</em> is an extension of logic programming to
include constraints on variables. While logic programming allows a
limited form of constraints, languages such as Prolog only allow
arithmetic constraints to be applied to variables that have been
instantiated. For example, suppose we wanted to find a number less
than 1000 that is both a square and the sum of two squares. The
following is an attempt to specify this in Prolog:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">square_sum</span><span class="p">([</span><span class="nv">N</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nv">N</span> <span class="o">=:=</span> <span class="nv">Z</span> <span class="o">*</span> <span class="nv">Z</span><span class="p">,</span> <span class="nv">N</span> <span class="o">=:=</span> <span class="nv">X</span> <span class="o">*</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span> <span class="o">*</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">X</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">X</span> <span class="o">&lt;</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">N</span> <span class="o">&lt;</span> <span class="mf">1000.</span>
</pre></div>
</div>
<p>We can attempt a query:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- square_sum(S).
ERROR: =:=/2: Arguments are not sufficiently instantiated
</pre></div>
</div>
<p>Unfortunately, since <code class="docutils literal notranslate"><span class="pre">N</span></code> and <code class="docutils literal notranslate"><span class="pre">Z</span></code> are not instantiated in the
comparison <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=:=</span> <span class="pre">Z</span></code>, we get an error.</p>
<p>On the other hand, using the <a class="reference external" href="http://www.swi-prolog.org/man/clpfd.html">CLP(FD)</a> library for Prolog, which
allows constraint logic programming over finite domains, we can
specify the solution as follows:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">clpfd</span><span class="p">)).</span>  <span class="c1">% load the clpfd library</span>

<span class="nf">square_sum_c</span><span class="p">([</span><span class="nv">N</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nv">N</span> <span class="s s-Atom">#=</span> <span class="nv">Z</span> <span class="o">*</span> <span class="nv">Z</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">#=</span> <span class="nv">X</span> <span class="o">*</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span> <span class="o">*</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">X</span> <span class="s s-Atom">#&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Y</span> <span class="s s-Atom">#&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Z</span> <span class="s s-Atom">#&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">X</span> <span class="s s-Atom">#&lt;</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">#&lt;</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="nf">label</span><span class="p">([</span><span class="nv">N</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">]).</span>
</pre></div>
</div>
<p>The first clause loads the library for use. We can then specify
arithmetic constraints using operators that begin with a pound symbol.
For instance, the <code class="docutils literal notranslate"><span class="pre">#=</span></code> operator constrains the two arguments to be
equal, while the <code class="docutils literal notranslate"><span class="pre">#&lt;</span></code> operator constraints the first argument to be
smaller than the second. Finally, the <code class="docutils literal notranslate"><span class="pre">label</span></code> predicate forces the
solver to <em>ground</em> the given variables, computing actual values for
them rather than specifying their results as constraints. Entering a
query, we can now obtain all solutions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- square_sum_c(S).
S = [25, 3, 4, 5] ;
S = [100, 6, 8, 10] ;
S = [169, 5, 12, 13] ;
S = [225, 9, 12, 15] ;
S = [289, 8, 15, 17] ;
S = [400, 12, 16, 20] ;
S = [625, 7, 24, 25] ;
S = [625, 15, 20, 25] ;
S = [676, 10, 24, 26] ;
S = [841, 20, 21, 29] ;
S = [900, 18, 24, 30] ;
false.
</pre></div>
</div>
<section id="search">
<h3>Search<a class="headerlink" href="#search" title="Link to this heading"></a></h3>
<p>In constraint logic programming, resolution follows the same basic
process as in plain logic programming. For a solver that uses backward
chaining, a set of goal terms is maintained, and the solver searches
for a clause whose head can be unified with the first goal term. If
unification succeeds, then the body terms that are not constraints are
added to the set of goals. Terms that are constraints are added to a
separate set called the <em>constraint store</em>. When a new constraint is
added to the store, in principle, the store is checked to make sure
that the constraints are satisfiable, and if not, backtracking is done
as in standard search. In practice, however, more limited checking is
performed in order to obtain better efficiency from the solver. A
solution is obtained when no more goal terms remain, and the set of
constraints in the store is satisfiable.</p>
</section>
<section id="id2">
<h3>Examples<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>As another example of using constraints, consider the canonical
<a class="reference external" href="https://en.wikipedia.org/wiki/Verbal_arithmetic">verbal arithmetic</a>
puzzle of finding a solution to the following equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">S</span> <span class="n">E</span> <span class="n">N</span> <span class="n">D</span>
<span class="o">+</span>   <span class="n">M</span> <span class="n">O</span> <span class="n">R</span> <span class="n">E</span>
<span class="o">-----------</span>
<span class="o">=</span> <span class="n">M</span> <span class="n">O</span> <span class="n">N</span> <span class="n">E</span> <span class="n">Y</span>
</pre></div>
</div>
<p>Requirements are that each letter be a distinct digit, and that the
leading digit of a number not be zero. We can express this problem in
plain Prolog as the following:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">is_digit</span><span class="p">(</span><span class="nv">Digit</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">numlist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nv">AllDigits</span><span class="p">),</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">Digit</span><span class="p">,</span> <span class="nv">AllDigits</span><span class="p">).</span>

<span class="nf">money</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span> <span class="nv">E</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">Y</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">S</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">E</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">N</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">D</span><span class="p">),</span>
    <span class="nf">is_digit</span><span class="p">(</span><span class="nv">M</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">O</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">R</span><span class="p">),</span> <span class="nf">is_digit</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span>
    <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">M</span> <span class="s s-Atom">\=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">E</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">E</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">N</span> <span class="s s-Atom">\=</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">\=</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">\=</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">N</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">D</span> <span class="s s-Atom">\=</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">D</span> <span class="s s-Atom">\=</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">D</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">D</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">M</span> <span class="s s-Atom">\=</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">M</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">M</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">O</span> <span class="s s-Atom">\=</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">O</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nv">R</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">,</span>
                    <span class="mi">1000</span> <span class="o">*</span> <span class="nv">S</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="nv">D</span>
                  <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">R</span> <span class="o">+</span> <span class="nv">E</span>
    <span class="o">=:=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>First, we require that each variable be a digit in the range
<span class="math notranslate nohighlight">\([0, 9]\)</span>, and we further require that <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">M</span></code> not
be zero. We then specify the pairwise uniqueness requirements.
Finally, we specify that the variables must satisfy the target
equation.</p>
<p>We can enter a query as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- money(S), !.
S = [9, 5, 6, 7, 1, 0, 8, 2].
</pre></div>
</div>
<p>Computing this solution takes close to a minute on the author’s iMac
computer, since the solver has to search a large portion of the
solution space, with much backtracking.</p>
<p>We can simplify the implementation of <code class="docutils literal notranslate"><span class="pre">money</span></code> by using the
higher-order <code class="docutils literal notranslate"><span class="pre">maplist</span></code> predicate, as well as the built-in
<code class="docutils literal notranslate"><span class="pre">is_set</span></code>:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">money</span><span class="p">(</span><span class="nv">List</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nv">List</span> <span class="o">=</span> <span class="p">[</span><span class="nv">S</span><span class="p">,</span> <span class="nv">E</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">Y</span><span class="p">],</span>
   <span class="nf">maplist</span><span class="p">(</span><span class="s s-Atom">is_digit</span><span class="p">,</span> <span class="nv">List</span><span class="p">),</span> <span class="nv">S</span> <span class="s s-Atom">\=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">M</span> <span class="s s-Atom">\=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">is_set</span><span class="p">(</span><span class="nv">List</span><span class="p">),</span>
                   <span class="mi">1000</span> <span class="o">*</span> <span class="nv">S</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="nv">D</span>
                 <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">R</span> <span class="o">+</span> <span class="nv">E</span>
   <span class="o">=:=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>The term <code class="docutils literal notranslate"><span class="pre">maplist(is_digit,</span> <span class="pre">List)</span></code> applies the higher-order
<code class="docutils literal notranslate"><span class="pre">maplist</span></code> predicate to map the <code class="docutils literal notranslate"><span class="pre">is_digit</span></code> predicate across the
elements of <code class="docutils literal notranslate"><span class="pre">List</span></code>, and <code class="docutils literal notranslate"><span class="pre">is_set(List)</span></code> ensures that <code class="docutils literal notranslate"><span class="pre">List</span></code> has
no duplicates. While this solution is shorter, it runs even slower
than our original solution, taking about a minute and half on the same
machine.</p>
<p>On the other hand, we can use CLP(FD) to specify the problem as
follows:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">clpfd</span><span class="p">)).</span>

<span class="nf">money_c</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span> <span class="nv">E</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">Y</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nv">List</span> <span class="o">=</span> <span class="p">[</span><span class="nv">S</span><span class="p">,</span> <span class="nv">E</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">D</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">O</span><span class="p">,</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">Y</span><span class="p">],</span>
    <span class="nv">List</span> <span class="s s-Atom">ins</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">9</span><span class="p">,</span> <span class="nv">S</span> <span class="s s-Atom">#\=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">M</span> <span class="s s-Atom">#\=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">all_distinct</span><span class="p">(</span><span class="nv">List</span><span class="p">),</span>
                   <span class="mi">1000</span> <span class="o">*</span> <span class="nv">S</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="nv">D</span>
                 <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">R</span> <span class="o">+</span> <span class="nv">E</span>
    <span class="s s-Atom">#=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="nv">M</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">O</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nv">N</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">E</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">,</span>
    <span class="nf">label</span><span class="p">(</span><span class="nv">List</span><span class="p">).</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ins</span></code> predicate is defined by CLP(FD) to constrain that the
variables in the first argument each be contained in the set that is
the second argument. The <code class="docutils literal notranslate"><span class="pre">..</span></code> operator specifies a range, so that
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">..</span> <span class="pre">9</span></code> is the range <span class="math notranslate nohighlight">\([0, 9]\)</span>. The <code class="docutils literal notranslate"><span class="pre">all_distinct</span></code> predicate
constraints the variables in the argument to take on distinct values.
Finally, we use <code class="docutils literal notranslate"><span class="pre">label</span></code> at the end to ground the given variables
with actual values. We obtain the same result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- money_c(S), !.
S = [9, 5, 6, 7, 1, 0, 8, 2].
</pre></div>
</div>
<p>The solver can use the set of constraints to eliminate most of the
search space, and the remaining candidates are checked when the
<code class="docutils literal notranslate"><span class="pre">label</span></code> predicate is reached. The result is that computing this
solution takes about 0.003 seconds on the author’s iMac, a speedup of
about 18000x.</p>
<p>As another example, consider the problem of solving a <a class="reference external" href="https://en.wikipedia.org/wiki/Sudoku">Sudoku</a> puzzle. The following
predicate takes in a nested list of lists, in row-major order, with
some entries provided but others filled with anonymous variables:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">sudoku</span><span class="p">(</span><span class="nv">Rows</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">length</span><span class="p">(</span><span class="nv">Rows</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="nf">maplist</span><span class="p">(</span><span class="nf">same_length</span><span class="p">(</span><span class="nv">Rows</span><span class="p">),</span> <span class="nv">Rows</span><span class="p">),</span>
    <span class="nf">append</span><span class="p">(</span><span class="nv">Rows</span><span class="p">,</span> <span class="nv">Values</span><span class="p">),</span> <span class="nv">Values</span> <span class="s s-Atom">ins</span> <span class="mf">1..9</span><span class="p">,</span>
    <span class="nf">maplist</span><span class="p">(</span><span class="s s-Atom">all_distinct</span><span class="p">,</span> <span class="nv">Rows</span><span class="p">),</span>
    <span class="nf">transpose</span><span class="p">(</span><span class="nv">Rows</span><span class="p">,</span> <span class="nv">Columns</span><span class="p">),</span>
    <span class="nf">maplist</span><span class="p">(</span><span class="s s-Atom">all_distinct</span><span class="p">,</span> <span class="nv">Columns</span><span class="p">),</span>
    <span class="nv">Rows</span> <span class="o">=</span> <span class="p">[</span><span class="nv">Row1</span><span class="p">,</span> <span class="nv">Row2</span><span class="p">,</span> <span class="nv">Row3</span><span class="p">,</span> <span class="nv">Row4</span><span class="p">,</span> <span class="nv">Row5</span><span class="p">,</span> <span class="nv">Row6</span><span class="p">,</span> <span class="nv">Row7</span><span class="p">,</span> <span class="nv">Row8</span><span class="p">,</span> <span class="nv">Row9</span><span class="p">],</span>
    <span class="nf">blocks</span><span class="p">(</span><span class="nv">Row1</span><span class="p">,</span> <span class="nv">Row2</span><span class="p">,</span> <span class="nv">Row3</span><span class="p">),</span>
    <span class="nf">blocks</span><span class="p">(</span><span class="nv">Row4</span><span class="p">,</span> <span class="nv">Row5</span><span class="p">,</span> <span class="nv">Row6</span><span class="p">),</span>
    <span class="nf">blocks</span><span class="p">(</span><span class="nv">Row7</span><span class="p">,</span> <span class="nv">Row8</span><span class="p">,</span> <span class="nv">Row9</span><span class="p">),</span>
    <span class="nf">maplist</span><span class="p">(</span><span class="s s-Atom">label</span><span class="p">,</span> <span class="nv">Rows</span><span class="p">).</span>
</pre></div>
</div>
<p>The first body term requires that the number of rows be 9. The second
uses <code class="docutils literal notranslate"><span class="pre">maplist</span></code>, which maps a predicate over the items in a list, as
we saw in the previous example. The <code class="docutils literal notranslate"><span class="pre">same_length(Rows)</span></code> argument is
a partially applied predicate that, when applied to another argument,
requires that the two argument lists have the same length. The term as
a whole is checking that each row also has the same length as the
number of rows. The <code class="docutils literal notranslate"><span class="pre">append</span></code> term takes a list of lists and
concatenates them into the single list <code class="docutils literal notranslate"><span class="pre">Values</span></code>. We then constrain
that each variable be in the range <span class="math notranslate nohighlight">\([1, 9]\)</span>. The next term
constrains each row to consist of distinct numbers, and the following
two terms constrain each of the columns to consist of distinct
numbers. The next four terms constrain each of the 9x9 squares to be
composed of distinct numbers, with the <code class="docutils literal notranslate"><span class="pre">blocks</span></code> predicate defined
below. Finally, the last term ensures that each variable is grounded
to a value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">blocks</span></code> predicate is as follows:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">blocks</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[]).</span>
<span class="nf">blocks</span><span class="p">([</span><span class="nv">N1</span><span class="p">,</span> <span class="nv">N2</span><span class="p">,</span> <span class="nv">N3</span> <span class="p">|</span> <span class="nv">RestRow1</span><span class="p">],</span>
       <span class="p">[</span><span class="nv">N4</span><span class="p">,</span> <span class="nv">N5</span><span class="p">,</span> <span class="nv">N6</span> <span class="p">|</span> <span class="nv">RestRow2</span><span class="p">],</span>
       <span class="p">[</span><span class="nv">N7</span><span class="p">,</span> <span class="nv">N8</span><span class="p">,</span> <span class="nv">N9</span> <span class="p">|</span> <span class="nv">RestRow3</span><span class="p">])</span> <span class="p">:-</span>
    <span class="nf">all_distinct</span><span class="p">([</span><span class="nv">N1</span><span class="p">,</span> <span class="nv">N2</span><span class="p">,</span> <span class="nv">N3</span><span class="p">,</span> <span class="nv">N4</span><span class="p">,</span> <span class="nv">N5</span><span class="p">,</span> <span class="nv">N6</span><span class="p">,</span> <span class="nv">N7</span><span class="p">,</span> <span class="nv">N8</span><span class="p">,</span> <span class="nv">N9</span><span class="p">]),</span>
    <span class="nf">blocks</span><span class="p">(</span><span class="nv">RestRow1</span><span class="p">,</span> <span class="nv">RestRow2</span><span class="p">,</span> <span class="nv">RestRow3</span><span class="p">).</span>
</pre></div>
</div>
<p>The predicate takes in three rows, ensures that the set consisting of
the first three items from each row contains distinct values, and then
recursively checks this for the remaining items in each row.</p>
<p>We can now provide a query to solve a specific puzzle. The following
has been called the <a class="reference external" href="http://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html">“world’s hardest Sudoku”</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>?- S = [[8,_,_,_,_,_,_,_,_],
        [_,_,3,6,_,_,_,_,_],
        [_,7,_,_,9,_,2,_,_],
        [_,5,_,_,_,7,_,_,_],
        [_,_,_,_,4,5,7,_,_],
        [_,_,_,1,_,_,_,3,_],
        [_,_,1,_,_,_,_,6,8],
        [_,_,8,5,_,_,_,1,_],
        [_,9,_,_,_,_,4,_,_]],
   sudoku(S).
S = [[8, 1, 2, 7, 5, 3, 6, 4, 9],
     [9, 4, 3, 6, 8, 2, 1, 7, 5],
     [6, 7, 5, 4, 9, 1, 2, 8, 3],
     [1, 5, 4, 2, 3, 7, 8, 9, 6],
     [3, 6, 9, 8, 4, 5, 7, 2, 1],
     [2, 8, 7, 1, 6, 9, 5, 3, 4],
     [5, 2, 1, 9, 7, 4, 3, 6, 8],
     [4, 3, 8, 5, 2, 6, 9, 1, 7],
     [7, 9, 6, 3, 1, 8, 4, 5, 2]] .
</pre></div>
</div>
<p>Solving this takes less than a tenth of a second on the author’s iMac.</p>
</section>
</section>
<section id="make">
<h2>Make<a class="headerlink" href="#make" title="Link to this heading"></a></h2>
<p>Make is a family of tools used for automating the building of software
packages, as well as tracking dependencies between the various
components of a package. Make operates on programs called <em>makefiles</em>,
which contain <em>rules</em> for how to build individual <em>targets</em>. A target
may have <em>dependencies</em>, which are required to be satisfied before the
target can be built, as well as <em>commands</em> that specify how the target
should actually be built. Thus, a makefile is a combination of
declarative components relating targets to dependencies and imperative
actions specifying the actions required to build a target.</p>
<p>The structure of a rule in a makefile is as follows:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">target</span><span class="o">:</span><span class="w"> </span><span class="n">dependencies</span>
<span class="w">        </span>commands
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">dependencies</span></code> is a list of zero or more targets or files that
the given target depends on, and <code class="docutils literal notranslate"><span class="pre">commands</span></code> is a list of zero or
more actions to be taken, generally each on its own line and indented
with a tab character.</p>
<p>As an example, consider the following simple makefile, located by
convention in a file named <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> (note the capitalization):</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">hello</span><span class="o">:</span>
<span class="w">        </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hello world!&quot;</span>
</pre></div>
</div>
<p>We can run this from the terminal, if we are in the same directory,
as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make hello
echo &quot;Hello world!&quot;
Hello world!
</pre></div>
</div>
<p>This invokes the <code class="docutils literal notranslate"><span class="pre">hello</span></code> target, which has no dependencies and as
its sole action invokes the shell command to print <code class="docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">world!</span></code> to
the screen. We can leave out the explicit target when invoking
<code class="docutils literal notranslate"><span class="pre">make</span></code>, in which case it will build the first target in the
makefile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make
echo &quot;Hello world!&quot;
Hello world!
</pre></div>
</div>
<p>The target of a rule is commonly an executable file, and the
dependencies are the files needed to build the target. For example,
suppose we have a C++ project with the source files <code class="docutils literal notranslate"><span class="pre">a.cpp</span></code>,
<code class="docutils literal notranslate"><span class="pre">b.cpp</span></code>, and <code class="docutils literal notranslate"><span class="pre">c.cpp</span></code>. We can structure our makefile as follows:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="o">:</span><span class="w"> </span><span class="n">a</span>.<span class="n">o</span> <span class="n">b</span>.<span class="n">o</span> <span class="n">c</span>.<span class="n">o</span>
<span class="w">        </span>g++<span class="w"> </span>-o<span class="w"> </span>main<span class="w"> </span>a.o<span class="w"> </span>b.o<span class="w"> </span>c.o

<span class="nf">a.o</span><span class="o">:</span><span class="w"> </span><span class="n">a</span>.<span class="n">cpp</span>
<span class="w">        </span>g++<span class="w"> </span>--std<span class="o">=</span>c++14<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-c<span class="w"> </span>a.cpp

<span class="nf">b.o</span><span class="o">:</span><span class="w"> </span><span class="n">b</span>.<span class="n">cpp</span>
<span class="w">        </span>g++<span class="w"> </span>--std<span class="o">=</span>c++14<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-c<span class="w"> </span>b.cpp

<span class="nf">c.o</span><span class="o">:</span><span class="w"> </span><span class="n">c</span>.<span class="n">cpp</span>
<span class="w">        </span>g++<span class="w"> </span>--std<span class="o">=</span>c++14<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-c<span class="w"> </span>c.cpp
</pre></div>
</div>
<p>Here, our default rule is <code class="docutils literal notranslate"><span class="pre">main</span></code>, which depends on the targets
<code class="docutils literal notranslate"><span class="pre">a.o</span></code>, <code class="docutils literal notranslate"><span class="pre">b.o</span></code>, and <code class="docutils literal notranslate"><span class="pre">c.o</span></code>. In order to build <code class="docutils literal notranslate"><span class="pre">main</span></code>, those
targets have to be built first, so Make will attempt to build each of
those targets using their respective rules. The rule for <code class="docutils literal notranslate"><span class="pre">a.o</span></code>
depends on the file <code class="docutils literal notranslate"><span class="pre">a.cpp</span></code>, and if it exists, the command invokes
<code class="docutils literal notranslate"><span class="pre">g++</span></code> to build the object file <code class="docutils literal notranslate"><span class="pre">a.o</span></code>. The rules for <code class="docutils literal notranslate"><span class="pre">b.o</span></code> and
<code class="docutils literal notranslate"><span class="pre">c.o</span></code> have the same structure. Once those targets have been built,
Make can then build <code class="docutils literal notranslate"><span class="pre">main</span></code>, which links together the object files
into the final <code class="docutils literal notranslate"><span class="pre">main</span></code> executable. Running <code class="docutils literal notranslate"><span class="pre">make</span></code> indicates the
sequence of operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make
g++ --std=c++14 -Wall -Werror -pedantic -c a.cpp
g++ --std=c++14 -Wall -Werror -pedantic -c b.cpp
g++ --std=c++14 -Wall -Werror -pedantic -c c.cpp
g++ -o main a.o b.o c.o
</pre></div>
</div>
<p>Thus, we can specify complex dependency trees with rules in a
makefile, and the Make tool will automatically resolve the
dependencies and build the required targets. The relationship between
a target and its dependencies is specified declaratively in a rule.</p>
<p>A key feature of Make is that it only builds a target if it has a
dependency, direct or indirect through other rules, that is newer than
the target itself. For instance, if we follow up the preceding build
by modifying the timestamp on <code class="docutils literal notranslate"><span class="pre">b.cpp</span></code>, we can see that it is newer
than the targets <code class="docutils literal notranslate"><span class="pre">b.o</span></code> and <code class="docutils literal notranslate"><span class="pre">main</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ touch b.cpp
$ ls -l
-rw-r--r--  1 kamil  staff    229 Nov 17 01:01 Makefile
-rw-r--r--  1 kamil  staff     90 Nov 17 00:57 a.cpp
-rw-r--r--  1 kamil  staff   6624 Nov 17 01:01 a.o
-rw-r--r--  1 kamil  staff     31 Nov 17 01:12 b.cpp
-rw-r--r--  1 kamil  staff    640 Nov 17 01:01 b.o
-rw-r--r--  1 kamil  staff     33 Nov 17 00:58 c.cpp
-rw-r--r--  1 kamil  staff    640 Nov 17 01:01 c.o
-rwxr-xr-x  1 kamil  staff  15268 Nov 17 01:01 main
</pre></div>
</div>
<p>If we then run <code class="docutils literal notranslate"><span class="pre">make</span></code>, it will only rebuild those targets that
depend on <code class="docutils literal notranslate"><span class="pre">b.cpp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make
g++ --std=c++14 -Wall -Werror -pedantic -c b.cpp
g++ -o main a.o b.o c.o
</pre></div>
</div>
<p>This is a crucial feature for working with large projects, as only the
components that depend on a modification are rebuilt rather than every
target in the project.</p>
<p>As a more complex example, consider the following makefile that was
used to build a previous version of this text:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="n">foundations</span> <span class="n">functional</span> <span class="n">theory</span> <span class="n">data</span> <span class="n">declarative</span>

<span class="nf">foundations</span><span class="o">:</span><span class="w"> </span><span class="n">foundations</span>.<span class="n">html</span> <span class="n">foundations</span>.<span class="n">tex</span>

<span class="nf">functional</span><span class="o">:</span><span class="w"> </span><span class="n">functional</span>.<span class="n">html</span> <span class="n">functional</span>.<span class="n">tex</span>

<span class="nf">theory</span><span class="o">:</span><span class="w"> </span><span class="n">theory</span>.<span class="n">html</span> <span class="n">theory</span>.<span class="n">tex</span>

<span class="nf">data</span><span class="o">:</span><span class="w"> </span><span class="n">data</span>.<span class="n">html</span> <span class="n">data</span>.<span class="n">tex</span>

<span class="nf">declarative</span><span class="o">:</span><span class="w"> </span><span class="n">declarative</span>.<span class="n">html</span> <span class="n">declarative</span>.<span class="n">tex</span>

<span class="nf">asynchronous</span><span class="o">:</span><span class="w"> </span><span class="n">asynchronous</span>.<span class="n">html</span> <span class="n">asynchronous</span>.<span class="n">tex</span>

<span class="nf">metaprogramming</span><span class="o">:</span><span class="w"> </span><span class="n">metaprogramming</span>.<span class="n">html</span> <span class="n">metaprogramming</span>.<span class="n">tex</span>

<span class="nf">%.html</span><span class="o">:</span><span class="w"> </span>%.<span class="n">rst</span>
<span class="w">        </span>rst2html.py<span class="w"> </span>--stylesheet<span class="o">=</span>style/style.css<span class="w"> </span>$&lt;<span class="w"> </span>&gt;<span class="w"> </span><span class="nv">$@</span>

<span class="nf">%.tex</span><span class="o">:</span><span class="w"> </span>%.<span class="n">rst</span>
<span class="w">        </span>rst2latex.py<span class="w"> </span>--stylesheet<span class="o">=</span>style/style.sty<span class="w"> </span>$&lt;<span class="w"> </span>&gt;<span class="w"> </span><span class="nv">$@</span>
<span class="w">        </span>pdflatex<span class="w"> </span><span class="nv">$@</span>
<span class="w">        </span>pdflatex<span class="w"> </span><span class="nv">$@</span>
<span class="w">        </span>pdflatex<span class="w"> </span><span class="nv">$@</span>

<span class="nf">clean</span><span class="o">:</span>
<span class="w">        </span>rm<span class="w"> </span>-vf<span class="w"> </span>*.html<span class="w"> </span>*.tex<span class="w"> </span>*.pdf<span class="w"> </span>*.aux<span class="w"> </span>*.log<span class="w"> </span>*.out
</pre></div>
</div>
<p>The default target is <code class="docutils literal notranslate"><span class="pre">all</span></code>, which depends on the <code class="docutils literal notranslate"><span class="pre">foundations</span></code>,
<code class="docutils literal notranslate"><span class="pre">functional</span></code>, <code class="docutils literal notranslate"><span class="pre">theory</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, and <code class="docutils literal notranslate"><span class="pre">declarative</span></code> targets.
While there are also <code class="docutils literal notranslate"><span class="pre">asynchronous</span></code> and <code class="docutils literal notranslate"><span class="pre">metaprogramming</span></code> targets,
they were not being built since we had not reached the corresponding
units in the text.</p>
<p>Each of the following standard targets has two dependencies, an
<code class="docutils literal notranslate"><span class="pre">.html</span></code> file and a <code class="docutils literal notranslate"><span class="pre">.tex</span></code> file. In order to build an <code class="docutils literal notranslate"><span class="pre">.html</span></code>
file, Make looks for an appropriate target. We have a <em>pattern rule</em>
for <code class="docutils literal notranslate"><span class="pre">.html</span></code> files, which depends on a corresponding <code class="docutils literal notranslate"><span class="pre">.rst</span></code> file.
Thus, in order to build, for example, <code class="docutils literal notranslate"><span class="pre">declarative.html</span></code>, Make
applies the pattern rule and invokes <code class="docutils literal notranslate"><span class="pre">rst2html.py</span></code>. The special
symbol <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> stands for the dependencies, while <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> stands for the
target. Thus, the result of <code class="docutils literal notranslate"><span class="pre">rst2html.py</span></code> is written to
<code class="docutils literal notranslate"><span class="pre">declarative.html</span></code>, and the build for that target is complete.</p>
<p>We also have a pattern rule for <code class="docutils literal notranslate"><span class="pre">.tex</span></code> files, which invokes
<code class="docutils literal notranslate"><span class="pre">rst2latex.py</span></code>, followed by several invocations of <code class="docutils literal notranslate"><span class="pre">pdflatex</span></code>. The
end result is that building <code class="docutils literal notranslate"><span class="pre">declarative.tex</span></code> ends up creating
<code class="docutils literal notranslate"><span class="pre">declarative.pdf</span></code> as well.</p>
<p>The last rule is to clean up target and temporary files. Thus, we can
force the <code class="docutils literal notranslate"><span class="pre">all</span></code> target to be built from scratch with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span>
<span class="pre">all</span></code>. Without requesting the <code class="docutils literal notranslate"><span class="pre">clean</span></code> target, only those targets
that depend on an <code class="docutils literal notranslate"><span class="pre">.rst</span></code> file that has been modified will be
rebuilt.</p>
</section>
</section>
<section id="pattern-matching">
<h1>Pattern Matching<a class="headerlink" href="#pattern-matching" title="Link to this heading"></a></h1>
<p>Many languages that are primarily functional or imperative provide a
declarative construct that does <em>pattern matching</em>, specifying
separate cases that each define a pattern against which a value can
match, and the computation to be done as a result. These separate
cases are analogous to different axioms in Prolog or different pattern
rules in Make, and the matching process is similar to
<a class="reference internal" href="#unification-and-search"><span class="std std-ref">unification</span></a> in Prolog.</p>
<p>As an example, we take a look at the <code class="docutils literal notranslate"><span class="pre">match</span></code> statement in Python,
which has the following syntax:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">match</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">:</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">pattern</span><span class="o">&gt;</span><span class="p">:</span>
        <span class="o">&lt;</span><span class="n">suite</span><span class="o">&gt;</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">pattern</span><span class="o">&gt;</span><span class="p">:</span>
        <span class="o">&lt;</span><span class="n">suite</span><span class="o">&gt;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>A controlling expression provides the value to be matched, and one or
more <code class="docutils literal notranslate"><span class="pre">case</span></code> clauses specify a matching pattern and a suite of
statements to be executed upon a match. Only the first clause that
matches the value is executed – the remaining clauses are skipped,
even if their patterns also match the value. This is similar to the
behavior of a sequence of <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">elif</span></code> branches, or a sequence
of <code class="docutils literal notranslate"><span class="pre">except</span></code> clauses on a <code class="docutils literal notranslate"><span class="pre">try</span></code> statement.</p>
<p>There are several kinds of patterns that can be specified, a subset of
which are the following:</p>
<ul>
<li><p>A <em>literal pattern</em> specifies a number, string, or boolean literal,
or the <code class="docutils literal notranslate"><span class="pre">None</span></code> literal, and it matches a value that compares equal
to the literal. The following is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">https_error_description</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">code</span><span class="p">:</span>
        <span class="k">case</span> <span class="mi">400</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Bad Request&#39;</span>
        <span class="k">case</span> <span class="mi">401</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Unauthorized&#39;</span>
        <span class="k">case</span> <span class="mi">403</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Forbidden&#39;</span>
        <span class="k">case</span> <span class="mi">404</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Not Found&#39;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Unknown code </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>This is similar to a <a class="reference internal" href="foundations.html#conditionals"><span class="std std-ref">switch statement</span></a>, but the
<code class="docutils literal notranslate"><span class="pre">match</span></code> construct is much more powerful in that it supports other
patterns as well.</p>
</li>
<li><p>A <em>capture pattern</em> specifies an identifier, and it matches against
any value, binding the identifier to that value. In the example
above, we can use such a pattern to incorporate the default result
in the <code class="docutils literal notranslate"><span class="pre">match</span></code> statement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">https_error_description</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">code</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="mi">404</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Not Found&#39;</span>
        <span class="k">case</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Unknown code </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>Since we don’t actually use the variable introduced in the last case,
we can use a lone underscore instead as an anonymous variable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">https_error_description</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">code</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Unknown code </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>A case with a pattern that consists solely of an identifier matches
any value, so such a case is only permitted as the last one in a
<code class="docutils literal notranslate"><span class="pre">match</span></code> statement.</p>
</li>
<li><p>A <em>class pattern</em> only matches a value that is an instance of the
class. The simplest class pattern consists of a type name followed
by empty parentheses:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">https_error_description</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">code</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>  <span class="c1"># only matches an int</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Unknown code </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;expected an int, got </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A class pattern may also specify attributes that the object must have
using syntax similar to keyword arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Alternatively, the class itself may define custom matching using
syntax similar to positional arguments. For instance, several
built-in types allow patterns of the form <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;(&lt;subpattern&gt;)</span></code>,
which matches against a value that is an instance of <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code> and
that also matches <code class="docutils literal notranslate"><span class="pre">&lt;subpattern&gt;</span></code>. Thus, the pattern <code class="docutils literal notranslate"><span class="pre">int(3)</span></code>
matches an <code class="docutils literal notranslate"><span class="pre">int</span></code> whose value is 3, and the pattern <code class="docutils literal notranslate"><span class="pre">int(value)</span></code>
matches any <code class="docutils literal notranslate"><span class="pre">int</span></code> and binds the name <code class="docutils literal notranslate"><span class="pre">value</span></code> to that object.</p>
</li>
<li><p>A <em>sequence pattern</em> consists of a comma-separated list of
subpatterns, which can be enclosed by either square brackets or
parentheses <a class="footnote-reference brackets" href="#id4" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Such a pattern can match a variety of sequence
types (including user-defined ones that <a class="reference external" href="https://peps.python.org/pep-0634/#sequence-patterns">meet a certain set of
conditions</a>),
though strings are excluded from matching a sequence pattern.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>If there is only one subpattern, then a trailing comma is
required if parentheses are used, to distinguish from normal
parenthesization. The parentheses or brackets can be elided
for patterns consisting of two or more subpatterns.</p>
</aside>
</aside>
<p>The following is an example of simple sequence patterns:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_short</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">case</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">case</span><span class="w"> </span><span class="p">[</span><span class="k">_</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">case</span><span class="w"> </span><span class="p">[</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>The first case matches an empty sequence, the second a one-element
sequence, and the third a two-element sequence. We use anonymous
variables since we are not concerned with the actual element values.
Note that the pattern <code class="docutils literal notranslate"><span class="pre">[_,</span> <span class="pre">_]</span></code> has different behavior than <code class="docutils literal notranslate"><span class="pre">[var,</span>
<span class="pre">var]</span></code>. The latter requires both elements to be equal, since the
first occurrence of <code class="docutils literal notranslate"><span class="pre">var</span></code> binds the variable to a value and the
second checks whether the corresponding element is equal to that
value. On the other hand, the anonymous variable <code class="docutils literal notranslate"><span class="pre">_</span></code> does not do
any binding, so each occurrence is independent of any others.</p>
<p>A sequence pattern may also contain a variadic subpattern, matching
zero or more occurrences. The syntax is similar to variadic
positional arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_short</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">case</span><span class="w"> </span><span class="p">[</span><span class="k">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Here, the pattern <code class="docutils literal notranslate"><span class="pre">[_,</span> <span class="pre">_,</span> <span class="pre">*_]</span></code> matches a sequence with at least
two elements – the first occurrence of <code class="docutils literal notranslate"><span class="pre">_</span></code> matches the first
element, the second occurrence matches second element, and the
<code class="docutils literal notranslate"><span class="pre">*_</span></code> matches all remaining elements.</p>
<p>The following is an example of recursively computing the length of a
sequence using sequence patterns:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="k">match</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">case</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">case</span><span class="w"> </span><span class="p">[</span><span class="k">_</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
</pre></div>
</div>
<p>The first case matches an empty sequence, the base case of the
computation. The second matches a sequence with at least one
element, and all but the first element match the variadic <code class="docutils literal notranslate"><span class="pre">*rest</span></code>
subpattern. These elements are encapsulated in a list bound to the
<code class="docutils literal notranslate"><span class="pre">rest</span></code> variable, and we can recurse on this list.</p>
<p>Compare this definition of <code class="docutils literal notranslate"><span class="pre">length</span></code> with an equivalent predicate
in Prolog:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">len</span><span class="p">([],</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">len</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Length</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nf">len</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span> <span class="nv">RestLength</span><span class="p">),</span>
  <span class="nv">Length</span> <span class="o">is</span> <span class="mi">1</span> <span class="o">+</span> <span class="nv">RestLength</span><span class="p">.</span>
</pre></div>
</div>
<p>In both definitions, we specify two separate cases with patterns
that are matched against an input list.</p>
</li>
</ul>
<p>There are several other patterns, including mapping patterns, <code class="docutils literal notranslate"><span class="pre">as</span></code>
patterns, value patterns, and “or” patterns, and a case can include a
<em>guard</em> expressed as an <code class="docutils literal notranslate"><span class="pre">if</span></code> clause to further restrict what the
case matches. More details are in the <a class="reference external" href="https://peps.python.org/pep-0634/">original specification</a> as well as the <a class="reference external" href="https://peps.python.org/pep-0636/">tutorial</a>.</p>
<p>We consider one more, complex example that illustrates the declarative
nature of pattern matching. Suppose we want to compute the sum of all
the elements in a nested list of numbers. The following expresses this
computation in Prolog:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% deep_sum(NestedList, Sum).</span>
<span class="c1">% True if NestedList is a nested list of numbers, and Sum is the sum</span>
<span class="c1">% of all the numbers contained in NestedList.</span>
<span class="nf">deep_sum</span><span class="p">([],</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">deep_sum</span><span class="p">([</span><span class="nv">First</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Sum</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nf">deep_sum</span><span class="p">(</span><span class="nv">First</span><span class="p">,</span> <span class="nv">FirstSum</span><span class="p">),</span>
  <span class="nf">deep_sum</span><span class="p">(</span><span class="nv">Rest</span><span class="p">,</span> <span class="nv">RestSum</span><span class="p">),</span>
  <span class="nv">Sum</span> <span class="o">is</span> <span class="nv">FirstSum</span> <span class="o">+</span> <span class="nv">RestSum</span><span class="p">.</span>
<span class="nf">deep_sum</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span> <span class="nv">Item</span><span class="p">).</span> <span class="c1">% can restrict this to numbers with :- number(Item).</span>
</pre></div>
</div>
<p>We have three cases: an empty list whose sum is zero, a non-empty list
whose sum is the recursive sum of the first item (which itself may be
a list) plus the recursive sum of the rest of the list, and a non-list
item whose sum is itself. We can express this same computation in
Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deep_sum</span><span class="p">(</span><span class="n">nested_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the sum of all the numbers in nested_list.</span>

<span class="sd">    nested_list must be a nested list of numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">nested_list</span><span class="p">:</span>
        <span class="k">case</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">case</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">deep_sum</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">deep_sum</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">item</span><span class="p">:</span>  <span class="c1"># can do int(item) | float(item) to restrict to numbers</span>
            <span class="k">return</span> <span class="n">item</span>
</pre></div>
</div>
<p>There is a direct correspondence between the two implementations,
reflecting the primarily declarative manner in which the computation
is expressed. The fundamental difference between Prolog and Python
here is that Prolog provides search and backtracking, so that other
axioms can be tried if one fails (or more solutions are requested). In
Python and other functional or imperative languages that have pattern
matching, a value matches at most one case, and the remaining cases
are never considered. Thus, while pattern matching is declarative, it
does not provide the full expressiveness of logic programming.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="data.html" class="btn btn-neutral float-left" title="Functional Data Abstraction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="metaprogramming.html" class="btn btn-neutral float-right" title="Macros and Code Generation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Amir Kamil, licensed under the Creative Commons Attribution-ShareAlike 4.0 International license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org/">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>

<!-- Mirrored from eecs390.github.io/notes/declarative.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:52 GMT -->
</html>