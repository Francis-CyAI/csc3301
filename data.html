<!DOCTYPE html>
<html class="writer-html5" lang="en" >

<!-- Mirrored from eecs390.github.io/notes/data.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Functional Data Abstraction &mdash; Programming Language Principles and Paradigms 0.4 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/style-extra.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/general.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/dark.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery3b25.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compatfa9a.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options804b.js?v=7f00635f"></script>
        <script src="_static/doctools56c1.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight7f57.js?v=dc90522c"></script>
        <script src="_static/js-extraf31b.js?v=c32e72a1"></script>
        <script async="async" src="../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-mml-chtml.js"></script>
        <script src="_static/dark_mode_js/default_light679c.js?v=c2e647ce"></script>
        <script src="_static/dark_mode_js/theme_switcher2b7c.js?v=358d3910"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Logic Programming" href="declarative.html" />
    <link rel="prev" title="Lambda Calculus" href="theory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #C53390" >

          
          
          <a href="index-2.html" class="icon icon-home">
            Programming Language Principles and Paradigms
          </a>
              <div class="version">
                0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://eecs390.github.io/notes/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Foundations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="foundations.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-python">Basic Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#basic-data-structures">Basic Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#compound-statements">Compound Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#function-definitions">Function Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#class-definitions">Class Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#modules">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#executing-a-module">Executing a Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#python-reference-semantics">Python Reference Semantics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-elements">Basic Elements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#levels-of-description">Levels of Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#lexical-structure">Lexical Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#semantics">Semantics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#entities-objects-and-variables">Entities, Objects, and Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#l-values-and-r-values">L-Values and R-Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statements">Statements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#names-and-environments">Names and Environments</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#blocks">Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#name-lookup">Name Lookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#nested-inline-blocks">Nested Inline Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#scope-in-functions">Scope in Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#id2">Static Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#dynamic-scope">Dynamic Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#point-of-declaration-or-definition">Point of Declaration or Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#control-flow">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expression-sequencing">Expression Sequencing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#short-circuiting">Short Circuiting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#explicit-sequences">Explicit Sequences</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#compound-assignment">Compound Assignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statement-sequences">Statement Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#unstructured-transfer-of-control">Unstructured Transfer of Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#structured-control">Structured Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loops">Loops</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loop-termination">Loop Termination</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#memory-management">Memory Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#storage-duration-classes">Storage Duration Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#static-storage">Static Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#automatic-storage">Automatic Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#thread-local-storage">Thread-Local Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#dynamic-storage">Dynamic Storage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#value-and-reference-semantics">Value and Reference Semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#raii-and-scope-based-resource-management">RAII and Scope-Based Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#garbage-collection">Garbage Collection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#reference-counting">Reference Counting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#tracing-collectors">Tracing Collectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#finalizers">Finalizers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#grammars">Grammars</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#context-free-grammars">Context-Free Grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#grammars-in-programming-languages">Grammars in Programming Languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#vexing-parse">Vexing Parse</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functional Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="functional.html">Introduction to Scheme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#compound-values">Compound Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#symbolic-data">Symbolic Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#functions">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#default-arguments">Default Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#variadic-functions">Variadic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#parameter-passing">Parameter Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#evaluation-of-function-calls">Evaluation of Function Calls</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#recursion">Recursion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#activation-records">Activation Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#tail-recursion">Tail Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#higher-order-functions">Higher-Order Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#function-objects">Function Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#functions-as-parameters">Functions as Parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#function-pointers">Function Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#binding-policy">Binding Policy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#nested-functions">Nested Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#decorators">Decorators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#lambda-functions">Lambda Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#scheme">Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#python">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#java">Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#common-patterns">Common Patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#sequence-patterns">Sequence Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="functional.html#map">Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#reduce">Reduce</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#filter">Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#any">Any</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#composition">Composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#partial-application-and-currying">Partial Application and Currying</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#continuations">Continuations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#restricted-continuations">Restricted Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#subroutines">Subroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#exceptions">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#generators">Generators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#first-class-continuations">First-Class Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#signaling-errors">Signaling Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#call-and-return">Call and Return</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#id11">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Lambda Calculus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#non-terminating-computation">Non-Terminating Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#normal-order-evaluation">Normal-Order Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#encoding-data">Encoding Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#booleans">Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#pairs">Pairs</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#church-numerals">Church Numerals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#equivalent-models">Equivalent Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#operational-semantics">Operational Semantics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#language">Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#states-and-transitions">States and Transitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#arithmetic-expressions">Arithmetic Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#order-of-evaluation">Order of Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#boolean-expressions">Boolean Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#statements">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#operational-semantics-for-lambda-calculus">Operational Semantics for Lambda Calculus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#formal-type-systems">Formal Type Systems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#subtyping">Subtyping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-arithmetic-operators">Subtyping and Arithmetic Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#the-top-type">The Top Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-functions">Subtyping and Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#full-typing-rules">Full Typing Rules</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Abstraction</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functional Data Abstraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pairs-and-lists">Pairs and Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lists">Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dictionaries">Dictionaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dispatch-dictionaries">Dispatch Dictionaries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#object-oriented-programming">Object-Oriented Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#members">Members</a></li>
<li class="toctree-l2"><a class="reference internal" href="#access-control">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kinds-of-methods">Kinds of Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nested-and-local-classes">Nested and Local Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#inheritance-and-polymorphism">Inheritance and Polymorphism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#types-of-inheritance">Types of Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-hierarchies">Class Hierarchies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#method-overriding">Method Overriding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#covariance-and-contravariance">Covariance and Contravariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-hidden-or-overridden-members">Accessing Hidden or Overridden Members</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-dynamic-binding">Implementing Dynamic Binding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#full-lookup-and-dispatch-process">Full Lookup and Dispatch Process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-inheritance">Multiple Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dictionary-based-implementation">Dictionary-Based Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#record-based-implementation">Record-Based Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#static-analysis">Static Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#type-equivalence">Type Equivalence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-compatibility">Type Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-inference">Type Inference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#control-flow-analysis">Control-Flow Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#dynamic-typing">Dynamic Typing</a></li>
<li class="toctree-l1"><a class="reference internal" href="#generics">Generics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#implicit-parametric-polymorphism">Implicit Parametric Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explicit-parametric-polymorphism">Explicit Parametric Polymorphism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#non-type-parameters">Non-Type Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#java-generics">Java Generics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#curiously-recurring-template-pattern">Curiously Recurring Template Pattern</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#duck-typing">Duck Typing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#modules-and-namespaces">Modules and Namespaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#translation-units">Translation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modules-packages-and-namespaces">Modules, Packages, and Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linkage">Linkage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#information-hiding">Information Hiding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialization">Initialization</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Declarative Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="declarative.html">Logic Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#prolog">Prolog</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#lists">Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#arithmetic">Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#side-effects">Side Effects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#unification-and-search">Unification and Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#search-order-and-backtracking">Search Order and Backtracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#the-cut-operator">The Cut Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#negation">Negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarative.html#constraints-and-dependencies">Constraints and Dependencies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#constraint-logic-programming">Constraint Logic Programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#search">Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#id2">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#make">Make</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarative.html#pattern-matching">Pattern Matching</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Metaprogramming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html">Macros and Code Generation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#scheme-macros">Scheme Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#cpp-macros">CPP Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="metaprogramming.html#stringification-and-concatenation">Stringification and Concatenation</a></li>
<li class="toctree-l3"><a class="reference internal" href="metaprogramming.html#the-macro-namespace">The Macro Namespace</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#code-generation">Code Generation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html#template-metaprogramming">Template Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#pairs">Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#numerical-computations">Numerical Computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#templates-and-function-overloading">Templates and Function Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#sfinae">SFINAE</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#ensuring-a-substitution-failure">Ensuring a Substitution Failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#variadic-templates">Variadic Templates</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html#example-multidimensional-arrays">Example: Multidimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#points">Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#domains">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#stencil">Stencil</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#nested-iteration">Nested Iteration</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Concurrent Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#parallelism-in-python">Parallelism in Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#threading">Threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#multiprocessing">Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#the-problem-with-shared-state">The Problem with Shared State</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#when-no-synchronization-is-necessary">When No Synchronization is Necessary</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronized-data-structures">Synchronized Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#locks">Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#barriers">Barriers</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#application-examples">Application Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#web-crawler">Web Crawler</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#particle-simulator">Particle Simulator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronization-pitfalls">Synchronization Pitfalls</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#under-synchronization">Under-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#over-synchronization">Over-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#deadlock">Deadlock</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html#asynchronous-tasks">Asynchronous Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#limiting-the-number-of-tasks">Limiting the Number of Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#launch-policy">Launch Policy</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #C53390" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index-2.html">Programming Language Principles and Paradigms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index-2.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Functional Data Abstraction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="theory.html" class="btn btn-neutral float-left" title="Lambda Calculus" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="declarative.html" class="btn btn-neutral float-right" title="Logic Programming" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Data Abstraction</h1><p>We now examine mechanisms for constructing <em>abstract data types
(ADTs)</em>, which allow us to abstract the interface for a piece of data
from its implementation. We also look at mechanisms for
<em>encapsulation</em>, which bind together the data of an ADT along with the
functions that operate on that data.</p>
<section id="functional-data-abstraction">
<span id="id1"></span><h1>Functional Data Abstraction<a class="headerlink" href="#functional-data-abstraction" title="Link to this heading"></a></h1>
<p>We start by modeling data using the tools of procedural abstraction,
beginning with a simple pair abstraction and progressing to more complex
abstract data types that encode behavior with messages.</p>
<section id="pairs-and-lists">
<h2>Pairs and Lists<a class="headerlink" href="#pairs-and-lists" title="Link to this heading"></a></h2>
<p>Recall that in <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, a pair is implemented as a
function that takes in two items and returns another function:</p>
<div class="math notranslate nohighlight">
\[pair ~=~ \lambda x.~ \lambda y.~ \lambda f.~ f~ x~ y\]</div>
<p>We could then obtain the first item by applying the resulting function
to <span class="math notranslate nohighlight">\(true\)</span>, and the second item by applying it to <span class="math notranslate nohighlight">\(false\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}first ~&amp;=~ \lambda p.~ p~ true\\
second ~&amp;=~ \lambda p.~ p~ false\end{split}\]</div>
<p>Following a similar strategy, we can define a pair constructor in
Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y</span>

    <span class="k">return</span> <span class="n">get</span>
</pre></div>
</div>
<p>As in <span class="math notranslate nohighlight">\(\lambda\)</span>-calculus, the <code class="docutils literal notranslate"><span class="pre">pair()</span></code> function returns a
function with the two items located in the latter’s non-local
environment. Now instead of applying the resulting function to a
boolean, we call it on an index to retrieve the first or the second
item:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">second</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Using pairs, we can build a full sequence abstraction, as in Scheme’s
pairs and lists. Before we proceed to do so, however, observe that our
current pair implementation does not support mutation, which is a key
feature of the sequence abstractions provided in imperative languages.
We can implement mutation by defining separate get and set functions,
using an immutable pair to return both when we construct a mutable
pair:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mutable_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">pair</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mutable_first</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mutable_second</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">set_first</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">second</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">set_second</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">second</span><span class="p">(</span><span class="n">p</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">mutable_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_first</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_second</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_first</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_second</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_first</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mutable_second</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>We use an immutable pair rather than a mutable one to return the get
and set functions so as to avoid infinite recursion in
<code class="docutils literal notranslate"><span class="pre">mutable_pair()</span></code>. In the definition of <code class="docutils literal notranslate"><span class="pre">set()</span></code>, the <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code>
statement is required so that the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> in the non-local
environment are modified.</p>
<p>While this representation works, it does not provide any
encapsulation. We now have four functions that manipulate mutable
pairs, and we had to name them carefully to avoid conflict with those
that work with immutable pairs.</p>
</section>
<section id="message-passing">
<h2>Message Passing<a class="headerlink" href="#message-passing" title="Link to this heading"></a></h2>
<p>An alternative strategy, assuming that we have access to a string data
type, is <em>message passing</em>, in which we send specific messages to an
ADT that determine what operations are performed on the data. This can
be implemented with a <em>dispatch function</em> that checks the input
message against a known set of behaviors and then takes the
appropriate action. Using message passing, we can define a mutable
pair as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mutable_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;second&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;set_first&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;set_second&#39;</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">dispatch</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">mutable_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;set_first&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;set_second&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<p>We still represent a pair as a function, but now instead of calling
external functions on a pair, we pass it a message and, if
appropriate, a value to obtain the action we want. The pair ADT is
entirely encapsulated within the <code class="docutils literal notranslate"><span class="pre">mutable_pair()</span></code> function.</p>
</section>
<section id="lists">
<h2>Lists<a class="headerlink" href="#lists" title="Link to this heading"></a></h2>
<p>Now that we have mutable pairs, we can implement a mutable list as a
sequence of pairs, as in Scheme. We will use the <code class="docutils literal notranslate"><span class="pre">None</span></code> object to
represent an empty list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mutable_list</span><span class="p">():</span>
    <span class="n">empty_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">empty_list</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="n">empty_list</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">mlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mlist</span> <span class="ow">is</span> <span class="n">empty_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="p">(</span><span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="n">mlist</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">mlist</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;set_first&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">setitem</span><span class="p">(</span><span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="n">empty_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;[]&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">))</span> <span class="o">+</span>
                <span class="n">to_string_helper</span><span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_string_helper</span><span class="p">(</span><span class="n">mlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mlist</span> <span class="ow">is</span> <span class="n">empty_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">))</span> <span class="o">+</span>
                <span class="n">to_string_helper</span><span class="p">(</span><span class="n">mlist</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="n">empty_list</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">mutable_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">empty_list</span><span class="p">)</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span><span class="p">(</span><span class="s1">&#39;set_second&#39;</span><span class="p">,</span> <span class="n">mutable_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">empty_list</span><span class="p">))</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">arg1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;len&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;getitem&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;setitem&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">setitem</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">to_string</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;append&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">append</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dispatch</span>
</pre></div>
</div>
<p>To avoid implementing all our functionality within the <code class="docutils literal notranslate"><span class="pre">dispatch()</span></code>
function, we’ve defined separate functions to perform each action.
Then the task of the <code class="docutils literal notranslate"><span class="pre">dispatch()</span></code> function is to call the
appropriate function based on the input message. The following
demonstrates how to use the mutable list ADT:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">mutable_list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">)</span>
<span class="go">&#39;[]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">)</span>
<span class="go">&#39;[3, 4, 5]&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">)</span>
<span class="go">&#39;[3, 6, 5]&#39;</span>
</pre></div>
</div>
</section>
<section id="dictionaries">
<h2>Dictionaries<a class="headerlink" href="#dictionaries" title="Link to this heading"></a></h2>
<p>We can implement a dictionary ADT using a list of records, each of
which consists of a key-value pair.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dictionary</span><span class="p">():</span>
    <span class="n">records</span> <span class="o">=</span> <span class="n">mutable_list</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_record</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">records</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">record</span> <span class="o">=</span> <span class="n">records</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">record</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">record</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">get_record</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">get_record</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">records</span><span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">mutable_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">record</span><span class="p">(</span><span class="s1">&#39;set_second&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;getitem&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">&#39;setitem&#39;</span><span class="p">:</span>
            <span class="n">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dispatch</span>
</pre></div>
</div>
<p>For simplicity, we only implement two messages, one for inserting a
key-value pair into a dictionary and one for retrieving the value of a
key. A key is looked up by searching through the records for a
matching key, and if it is found, the associated value is returned. A
key-value pair is inserted by looking up the key and modifying the
associated value if it is found. If it is not found, then a new record
is inserted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Compare this to code that works with Python’s built-in dictionaries,
with special methods invoked directly rather than using operators:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>The abstraction we provide is almost the same, with only minor
differences in syntax. On the other hand, our dictionary
implementation is particularly inefficient, requiring
<span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> time to perform an operation on a dictionary
with <span class="math notranslate nohighlight">\(n\)</span> keys. We can reduce this to linear time by implementing
an iterator abstraction on lists, but we will not do so here.</p>
</section>
<section id="dispatch-dictionaries">
<h2>Dispatch Dictionaries<a class="headerlink" href="#dispatch-dictionaries" title="Link to this heading"></a></h2>
<p>Now that we have dictionaries, we can make use of them to simplify our
handling of messages. Previously, our dispatch function consisted of a
lengthy conditional that called the appropriate internal function
based on the message. In order to accommodate internal functions that
take in different numbers of arguments, we had to arrange for the
dispatch function to be able to take in the maximum number of
arguments over the internal functions, and we had to use default
arguments to enable fewer arguments to be passed. This can get
unwieldy and error-prone the more complex our ADTs become.</p>
<p>Instead, we can store the mapping of messages to functions inside of a
<em>dispatch dictionary</em>. When we pass a message to an ADT, it returns
back the function corresponding to that message, which we can then
call with the appropriate arguments. The following uses this pattern
to define an ADT for a bank account:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">account</span><span class="p">(</span><span class="n">initial_balance</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
        <span class="n">new_balance</span> <span class="o">=</span> <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">amount</span>
        <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="n">new_balance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_balance</span>

    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="n">balance</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Insufficient funds&#39;</span>
        <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>
        <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="n">balance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">balance</span>

    <span class="k">def</span> <span class="nf">get_balance</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">)</span>

    <span class="n">dispatch</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">()</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;balance&#39;</span><span class="p">,</span> <span class="n">initial_balance</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;deposit&#39;</span><span class="p">,</span> <span class="n">deposit</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;withdraw&#39;</span><span class="p">,</span> <span class="n">withdraw</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;setitem&#39;</span><span class="p">,</span> <span class="s1">&#39;get_balance&#39;</span><span class="p">,</span> <span class="n">get_balance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dispatch_message</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dispatch_message</span>
</pre></div>
</div>
<p>The dispatch dictionary contains an entry for the account balance, as
well as functions to deposit, withdraw, and obtain the balance. The
dispatch function just retrieves the appropriate function from the
dispatch dictionary. We can then use an account as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">account</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="s1">&#39;get_balance&#39;</span><span class="p">)()</span>
<span class="go">33</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="s1">&#39;deposit&#39;</span><span class="p">)(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="s1">&#39;withdraw&#39;</span><span class="p">)(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">(</span><span class="s1">&#39;withdraw&#39;</span><span class="p">)(</span><span class="mi">77</span><span class="p">)</span>
<span class="go">&#39;Insufficient funds&#39;</span>
</pre></div>
</div>
<p>Compare this to the interface provided by a bank account implemented
as a Python class:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_balance</span><span class="p">()</span>
<span class="go">33</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">77</span><span class="p">)</span>
<span class="go">&#39;Insufficient funds&#39;</span>
</pre></div>
</div>
<p>Once again, our implementation provides a very similar interface with
only minor differences in syntax.</p>
<p>We have now constructed a hierarchy of ADTs using functions,
progressing from immutable pairs to mutable pairs, lists, and
dictionaries, finally arriving at a message-passing abstraction that
bears striking resemblance to object-oriented programming. Next, we
will examine language-level mechanisms for defining ADTs in the
object-oriented paradigm.</p>
</section>
</section>
<section id="object-oriented-programming">
<h1>Object-Oriented Programming<a class="headerlink" href="#object-oriented-programming" title="Link to this heading"></a></h1>
<p>Object-oriented languages provide mechanisms for defining abstract
data types in a systematic manner. Such languages provide means for
the following features of ADTs:</p>
<ul class="simple">
<li><p><em>Encapsulation</em>: The ability to bundle together the data of an ADT
along with the functions that operate on that data <a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p></li>
<li><p><em>Information hiding</em>: The ability to restrict access to
implementation details of an ADT.</p></li>
<li><p><em>Inheritance</em>: The ability to reuse code of an existing ADT when
defining another ADT. This includes <em>implementation inheritance</em>,
where the actual implementation of an ADT is reused, and <em>interface
inheritance</em>, where the new ADT merely supports the same interface
as the existing ADT.</p></li>
<li><p><em>Subtype polymorphism</em>: The ability to use an instance of a derived
ADT where a base ADT is expected. This requires some form of
<em>dynamic binding</em> or <em>dynamic dispatch</em>, where the derived ADT’s
functionality is used at runtime when the base ADT’s version is
expected at compile time.</p></li>
</ul>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>The term “encapsulation” is often used to encompass information
hiding as well.</p>
</aside>
</aside>
<p>In object-oriented languages, an ADT is specified by a <em>class</em>, which
defines the pattern to be used in instantiating <em>objects</em> of the
class.</p>
<section id="members">
<h2>Members<a class="headerlink" href="#members" title="Link to this heading"></a></h2>
<p>An object is composed of individual pieces of data, variously called
<em>fields</em>, <em>attributes</em>, or <em>data members</em>. Functions that are defined
within a class and operate on the contents of an object are often
called <em>methods</em>, or in C++ terminology, <em>member functions</em>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x_</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">x</span></code> is a field, <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> is a <em>constructor</em>
that is called to initialize a new object of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, and
<code class="docutils literal notranslate"><span class="pre">baz()</span></code> is a member function.</p>
<p>A class may also have fields associated with it that are shared among
all instances of the class. These are often called <em>static fields</em> or
<em>class attributes</em>, and they are often specified with the <code class="docutils literal notranslate"><span class="pre">static</span></code>
keyword, as in the following Java code:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A static field usually can be accessed through the class or through an
instance:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="na">bar</span><span class="p">);</span><span class="w"> </span><span class="c1">// access through class</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">().</span><span class="na">bar</span><span class="p">);</span><span class="w"> </span><span class="c1">// access through instance</span>
</pre></div>
</div>
<p>The following is the same example in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Foo</span><span class="p">().</span><span class="n">bar</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ requires an out-of-line definition for static data members that
are not compile-time constants to designate a storage location. Class
members are accessed using the scope-resolution operator (<code class="docutils literal notranslate"><span class="pre">::</span></code>).</p>
<p>Finally, the following demonstrates this example in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
   <span class="n">bar</span> <span class="o">=</span> <span class="mi">3</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Foo</span><span class="o">.</span><span class="n">bar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">bar</span><span class="p">)</span>
</pre></div>
</div>
<p>Attributes that are defined directly within a class definition are
automatically class attributes.</p>
</section>
<section id="access-control">
<h2>Access Control<a class="headerlink" href="#access-control" title="Link to this heading"></a></h2>
<p>Information hiding requires the ability to restrict access to the members
of a class or object. Many object-oriented languages provide a mechanism
for restricting accessibility (also called <em>visibility</em>) of members.
Common categories of access include:</p>
<ul class="simple">
<li><p>allowing only an object itself to access its own data</p></li>
<li><p>allowing all code in a class to access any data of the class or its
instances</p></li>
<li><p>allowing the data inherited from a base class to be accessed by code
in a derived class</p></li>
<li><p>allowing the data of a class and its instances to be accessed by all
code in the same package or module</p></li>
<li><p>allowing all code in a program to access the data of a class and its
instances</p></li>
</ul>
<p>In C++, Java, and C#, the <code class="docutils literal notranslate"><span class="pre">public</span></code> keyword grants all code access to
a member, while the <code class="docutils literal notranslate"><span class="pre">private</span></code> keyword restricts access to the class
itself. In C++ and C#, the <code class="docutils literal notranslate"><span class="pre">protected</span></code> keyword grants access to
inherited data to derived classes, while in Java, it additionally
grants access to all code in the same package. In C#, the <code class="docutils literal notranslate"><span class="pre">internal</span></code>
keyword grants access to a package. In Java, a member that does not
have an access qualifier is accessible to other code in the same
package but not to derived classes in other packages.</p>
<p>In many dynamic languages, such as Smalltalk and Python, all members
have public accessibility. In Ruby, fields of an object are only
accessible to the object itself and not to other objects of the same
class.</p>
<p><a class="reference internal" href="#table-access-control"><span class="std std-numref">Table 3</span></a> summarizes the access control provided
by several languages.</p>
<span id="table-access-control"></span><table class="docutils align-default" id="id9">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Access control in different languages</span><a class="headerlink" href="#id9" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Access</p></th>
<th class="head"><p>public</p></th>
<th class="head"><p>private</p></th>
<th class="head"><p>C++ protected</p></th>
<th class="head"><p>Java protected</p></th>
<th class="head"><p>C# internal/Java default</p></th>
<th class="head"><p>Python</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Same instance</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p>Same class</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>Derived classes</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p>Same package</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>Global access</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
</tbody>
</table>
<p>A subtlety arises when it comes to the <code class="docutils literal notranslate"><span class="pre">protected</span></code> access level.
Suppose a class <code class="docutils literal notranslate"><span class="pre">Derived</span></code> derives from <code class="docutils literal notranslate"><span class="pre">Base</span></code>, and <code class="docutils literal notranslate"><span class="pre">Base</span></code>
defines a <code class="docutils literal notranslate"><span class="pre">protected</span></code> member <code class="docutils literal notranslate"><span class="pre">x</span></code>. Is <code class="docutils literal notranslate"><span class="pre">Derived</span></code> allowed to access
the <code class="docutils literal notranslate"><span class="pre">x</span></code> member of instances of <code class="docutils literal notranslate"><span class="pre">Base</span></code> that are not also instances
of <code class="docutils literal notranslate"><span class="pre">Derived</span></code>? The following C++ code demonstrates this case:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>C++, C#, and Java all prohibit <code class="docutils literal notranslate"><span class="pre">Derived</span></code> from accessing the
protected member <code class="docutils literal notranslate"><span class="pre">x</span></code> of <code class="docutils literal notranslate"><span class="pre">Base</span></code>, unless the access is through an
instance that is also of type <code class="docutils literal notranslate"><span class="pre">Derived</span></code>. Thus, the expression
<code class="docutils literal notranslate"><span class="pre">b-&gt;x</span></code> above is erroneous, while <code class="docutils literal notranslate"><span class="pre">d-&gt;x</span></code> is permitted.</p>
</section>
<section id="kinds-of-methods">
<h2>Kinds of Methods<a class="headerlink" href="#kinds-of-methods" title="Link to this heading"></a></h2>
<p>Methods that operate on instances of a class generally take in the
instance itself as a parameter. Often, this parameter is named
<code class="docutils literal notranslate"><span class="pre">self</span></code> or <code class="docutils literal notranslate"><span class="pre">this</span></code>, either by convention or as a language keyword.
In most languages, the instance is an implicit parameter, as in the
following C++ code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_x</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In many languages, the <code class="docutils literal notranslate"><span class="pre">this</span></code> qualification on a member can be
elided, though it is necessary if another variable hides the
declaration of the member:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// x hidden by parameter</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">        </span><span class="c1">// y not hidden, so this-&gt; not needed</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In Python, the instance must be an explicit parameter, conventionally
named <code class="docutils literal notranslate"><span class="pre">self</span></code>. The <code class="docutils literal notranslate"><span class="pre">self</span></code> qualification cannot be elided:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>In most languages, method-call syntax implicitly passes the instance
as the implicit or explicit instance parameter, as the instance is
syntactically provided as part of the method call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">get_x</span><span class="p">()</span>  <span class="c1"># passes f as self parameter to get_x()</span>
</pre></div>
</div>
<p>Most languages also provide a means for defining static methods, which
do not operate on an instance but can generally be called on a class
or instance. In languages in the C++ family, the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword
specifies a static method. In Python, the <code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> decorator
accomplishes this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Baz</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">():</span>
        <span class="k">return</span> <span class="s1">&#39;Baz&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Baz</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Baz</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> decorator, the function <code class="docutils literal notranslate"><span class="pre">name()</span></code>
cannot be called on an instance of <code class="docutils literal notranslate"><span class="pre">Baz</span></code>. Python also has a
<code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> decorator that allows definition of a static-like
method that takes in the class itself as the first argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Baz</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

<span class="k">class</span> <span class="nc">Fie</span><span class="p">(</span><span class="n">Baz</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Baz</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>     <span class="c1"># prints Baz</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Baz</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>   <span class="c1"># prints Baz</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Fie</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>     <span class="c1"># prints Fie</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Fie</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>   <span class="c1"># prints Fie</span>
</pre></div>
</div>
<p>Some languages, such as C# and Python, provide a mechanism for
defining <em>property</em> methods that act as accessors to fields. Such a
method is called using field-access syntax and is useful for
controlling access to a field. A property method can also be used to
provide a field interface for data that must be computed on the fly,
such as in the following complex-number representation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Complex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="nd">@magnitude</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mag</span><span class="p">):</span>
        <span class="n">old_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">old_angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">old_angle</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@angle</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ang</span><span class="p">):</span>
        <span class="n">old_magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">old_magnitude</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">old_magnitude</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> decorator defines a getter, followed by which the
<code class="docutils literal notranslate"><span class="pre">&#64;&lt;method&gt;.setter</span></code> decorator can be used to define a setter, where
<code class="docutils literal notranslate"><span class="pre">&lt;method&gt;</span></code> is the name of the function used with <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>. With
<code class="docutils literal notranslate"><span class="pre">magnitude</span></code> and <code class="docutils literal notranslate"><span class="pre">angle</span></code> defined as properties with both getters
and setters, we can use them as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">magnitude</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
<span class="go">0.3333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">real</span>
<span class="go">1.0000000000000002</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">imag</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Thus, property methods allow the interface of a field to be abstracted
from its implementation. In the example of <code class="docutils literal notranslate"><span class="pre">Complex</span></code>, we could
change the implementation such that <code class="docutils literal notranslate"><span class="pre">magnitude</span></code> and <code class="docutils literal notranslate"><span class="pre">angle</span></code> are
stored as standard fields and <code class="docutils literal notranslate"><span class="pre">real</span></code> and <code class="docutils literal notranslate"><span class="pre">imag</span></code> are implemented as
property methods. This would not change the interface of <code class="docutils literal notranslate"><span class="pre">Complex</span></code>
at all, abstracting the implementation change from outside code.</p>
</section>
<section id="nested-and-local-classes">
<h2>Nested and Local Classes<a class="headerlink" href="#nested-and-local-classes" title="Link to this heading"></a></h2>
<p>Some object-oriented languages allow a <em>nested class</em> to be defined
within the scope of another class. This enables a helper class to be
encapsulated within the scope of an outer class, enabling it to be
hidden from users of the outer class. A language may also allow a
class to be defined at local scope as well.</p>
<p>Languages in which classes are first-class entities allow the creation
of new classes at runtime. Generally, such a creation may happen at
any scope, and the class has access to its definition environment
(i.e. it has <a class="reference internal" href="foundations.html#static-scope"><span class="std std-ref">static scope</span></a>). Python is an
example of such a language.</p>
<p>In C++, nested and local classes act as any other classes, except that
they have access to the private members of the enclosing class. On the
other hand, the enclosing class must be declared as a <code class="docutils literal notranslate"><span class="pre">friend</span></code> of a
nested class in order to have access to the private members of the
nested class. A local class does not have access to the local
variables in the enclosing stack frame.</p>
<p>Java provides more flexibility in its nested and local classes. Local
classes have access to local variables that are <em>effectively final</em>,
meaning that they are only assigned once and never modified. When
defined in a non-static scope, both nested and local classes are
associated with an actual instance of the enclosing class and have
direct access to its fields:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Outer</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="n">Outer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">class</span> <span class="nc">Inner</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="w">    </span><span class="n">Inner</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="na">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Outer</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Outer</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">Outer</span><span class="p">.</span><span class="na">Inner</span><span class="w"> </span><span class="n">inn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="na">new</span><span class="w"> </span><span class="nf">Inner</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">inn</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Java, nested and local classes have access to private members of
the enclosing class, and the enclosing class has access to the private
members of a nested class. The definition of a nested class can be
prefaced with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword to dissociate it from any
instance of the enclosing class.</p>
</section>
<section id="implementation-strategies">
<h2>Implementation Strategies<a class="headerlink" href="#implementation-strategies" title="Link to this heading"></a></h2>
<p>In concept, object-oriented programming is built around the idea of
passing messages to objects, which then respond in a manner
appropriate for the object. Access to a member can be thought of as
sending a message to the object. Languages differ in whether or not
the set of messages an object responds to is fixed at compile time, as
well as whether the actual message that is passed to an object is
fixed at compile time.</p>
<p>In efficiency-oriented languages such as C++ and Java, the set of
messages that an object supports is fixed at compile time and is the
same for all instances of a class. Such a language enables objects to
be implemented in a manner similar to <a class="reference internal" href="#records">records</a> or structs: the
fields of an object can be stored contiguously within the memory for
the object, with one slot for each field. Access to a field can then
be translated at compile time to a fixed offset into the object,
similar to an <a class="reference internal" href="foundations.html#activation-record-implementation-strategies"><span class="std std-ref">offset-based implementation of activation records</span></a> . As an example,
consider the following class in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x_</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y_</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are stored contiguously within the <code class="docutils literal notranslate"><span class="pre">Foo</span></code>
object, with <code class="docutils literal notranslate"><span class="pre">x</span></code> at an offset of zero bytes from the beginning of
the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> object and <code class="docutils literal notranslate"><span class="pre">y</span></code> at an offset of four bytes, since <code class="docutils literal notranslate"><span class="pre">x</span></code>
takes up four bytes (assuming that <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">4</span></code>).
<a class="reference internal" href="#figure-record"><span class="std std-numref">Figure 26</span></a> illustrates this layout:</p>
<figure class="align-center" id="id10">
<span id="figure-record"></span><a class="reference internal image-reference" href="_images/record.svg"><img alt="_images/record.svg" src="_images/record.svg" width="200" /></a>
<figcaption>
<p><span class="caption-number">Figure 26 </span><span class="caption-text">Record-based implementation of an object.</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Then given a <code class="docutils literal notranslate"><span class="pre">Foo</span></code> object <code class="docutils literal notranslate"><span class="pre">f</span></code>, the field access <code class="docutils literal notranslate"><span class="pre">f.x</span></code> is
translated at compile time to an offset of zero from the address of
<code class="docutils literal notranslate"><span class="pre">f</span></code>, while <code class="docutils literal notranslate"><span class="pre">f.y</span></code> is translated to an offset of four. No lookup is
required at runtime, making such an implementation very efficient.</p>
<p>In languages that enable a member to be added to a class or even an
individual object at runtime, members are usually stored within a
dictionary, analogous to a <a class="reference internal" href="foundations.html#activation-record-implementation-strategies"><span class="std std-ref">dictionary-based implementation of
activation records</span></a>.
This is similar to the message-passing scheme demonstrated in the last
section. Such a language defines a process for looking up a member.
For example, in Python, accessing an attribute of an object first
checks the dictionary for the object before proceeding to the
dictionary for its class:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Foo</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>   <span class="c1"># prints 3 2 2</span>
<span class="n">f</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">4</span>                  <span class="c1"># adds binding to instance dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Foo</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>   <span class="c1"># prints 3 4 2</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">Foo</span></code> has a class attribute <code class="docutils literal notranslate"><span class="pre">y</span></code>, and the constructor
creates an instance attribute <code class="docutils literal notranslate"><span class="pre">x</span></code>. Looking up <code class="docutils literal notranslate"><span class="pre">f.x</span></code> first looks in
the instance dictionary, finding a binding there. On the other hand,
looking up <code class="docutils literal notranslate"><span class="pre">f.y</span></code> within the first call to <code class="docutils literal notranslate"><span class="pre">print()</span></code> does not find
<code class="docutils literal notranslate"><span class="pre">y</span></code> in the instance dictionary, so lookup proceeds to the class
dictionary, finding it there. The assignment <code class="docutils literal notranslate"><span class="pre">f.y</span> <span class="pre">=</span> <span class="pre">4</span></code> introduces a
binding for <code class="docutils literal notranslate"><span class="pre">y</span></code> in the instance dictionary, so subsequent lookups
find <code class="docutils literal notranslate"><span class="pre">y</span></code> there.</p>
<p>Python actually takes a hybrid approach, using a dictionary by default
but allowing a class to specify a record-like implementation using the
special <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> attribute. The following is a definition of the
<code class="docutils literal notranslate"><span class="pre">Complex</span></code> class to use this mechanism:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Complex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="nd">@magnitude</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mag</span><span class="p">):</span>
        <span class="n">old_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">old_angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">old_angle</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@angle</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ang</span><span class="p">):</span>
        <span class="n">old_magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">old_magnitude</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">old_magnitude</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
</pre></div>
</div>
<p>Instances of a class that uses <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> no longer store
attributes in a dictionary, saving space and providing better
performance. However, they lose the ability of adding attributes to a
specific instance at runtime.</p>
<p>Dictionary-based languages usually provide a mechanism for dynamically
constructing a message and passing it to an object, such as the
special <code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code> method of Python objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s1">&#39;append&#39;</span><span class="p">)(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Java also supports dynamic invocation of messages through a powerful
<em>reflection</em> API, which provides a form of <a class="reference internal" href="#runtime-type-information">runtime type
information</a>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.lang.reflect.Method</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">Method</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getMethod</span><span class="p">(</span><span class="s">&quot;length&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="na">invoke</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="inheritance-and-polymorphism">
<span id="subtype-polymorphism"></span><h1>Inheritance and Polymorphism<a class="headerlink" href="#inheritance-and-polymorphism" title="Link to this heading"></a></h1>
<p>Inheritance and polymorphism are two key features of object-oriented
programming, enabling code reuse as well as allowing the
specialization of behavior based on the dynamic type of an object.
Languages differ greatly in the design choices they make in the
specifics of how they support inheritance and polymorphism. In this
section, we discuss some of these design choices as well as how they
are typically implemented.</p>
<section id="types-of-inheritance">
<h2>Types of Inheritance<a class="headerlink" href="#types-of-inheritance" title="Link to this heading"></a></h2>
<p>In <a class="reference internal" href="#object-oriented-programming">Object-Oriented Programming</a>, we alluded to the fact that
interface inheritance only reuses the interface of an ADT, while
implementation inheritance reuses the implementation. These two types
of inheritance are strongly coupled in most languages; specifically,
implementation inheritance almost always includes interface
inheritance as well. C++ is an exception, allowing fields and methods
to be inherited without exposing them as part of the interface of the
derived class.</p>
<p>In particular, C++ supports <em>private</em>, <em>protected</em>, and <em>public</em>
inheritance, which designate the accessibility of inherited members.
In private inheritance, all inherited members are made private in the
derived class. In protected inheritance, inherited members that were
originally public are made protected, while more restricted members
retain their original accessibility. In public inheritance, all
inherited members retain their original accessibility. The general
rule is that the accessibility of an inherited members is the more
restrictive of its original accessibility and the type of inheritance.
In keeping with the meaning of <code class="docutils literal notranslate"><span class="pre">private</span></code> discussed previously,
inherited members that were originally private are not accessible to
the derived class itself.</p>
<p>The default inheritance variant is public for classes defined using
the <code class="docutils literal notranslate"><span class="pre">struct</span></code> keyword, while it is private if the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword
is used. The programmer can override the default by placing an
access modifier in front of the base class, as in the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">baz</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">protected</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this example, the method <code class="docutils literal notranslate"><span class="pre">foo()</span></code> is public in <code class="docutils literal notranslate"><span class="pre">B</span></code>, protected in
<code class="docutils literal notranslate"><span class="pre">C</span></code>, and private in <code class="docutils literal notranslate"><span class="pre">D</span></code>. Thus, <code class="docutils literal notranslate"><span class="pre">D</span></code> inherits the implementation
of <code class="docutils literal notranslate"><span class="pre">foo()</span></code> without exposing it as part of its interface. The method
<code class="docutils literal notranslate"><span class="pre">bar()</span></code> is protected in <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> and private in <code class="docutils literal notranslate"><span class="pre">D</span></code>.
Finally, the member function <code class="docutils literal notranslate"><span class="pre">baz()</span></code> is private in all three derived
classes, while also being inaccessible to the classes themselves.</p>
<p>C++ also allows derived classes to delete <a class="reference internal" href="#non-virtual">non-virtual</a> inherited
methods.</p>
<p>Some languages allow an interface to be inherited without the
implementation, requiring concrete derived classes to provide their
own implementation. A method is <em>abstract</em> (<em>pure virtual</em> in C++
terminology) if no implementation is provided, and a class is abstract
if it has at least one abstract method, whether the abstract method is
declared directly in the class or inherited. In Java, abstract classes
must be labeled as such:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">abstract</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A class that only has abstract methods is often called an <em>interface</em>,
and Java has specific mechanisms for defining and implementing an
interface:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">I</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">C</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;foo() in C&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;bar() in C&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Abstract methods in Java may have any access level except private, but
interface methods are implicitly public. Java allows a class to
implement multiple interfaces, though it only allows it to derive from
a single class.</p>
<p>Some languages further decouple inheritance from polymorphism by
allowing methods to be inherited without establishing a parent-child
relationship between two classes. The class that defines these methods
is called a <em>mixin</em>, and a mixin can be included from another class to
obtain those methods. The use of mixins is particularly common in
Ruby. The following is an example:</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span>
<span class="w">  </span><span class="kp">include</span><span class="w"> </span><span class="no">Comparable</span>
<span class="w">  </span><span class="kp">attr_accessor</span><span class="w"> </span><span class="ss">:count</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span>
<span class="w">    </span><span class="vi">@count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span>
<span class="w">    </span><span class="vi">@count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">&lt;=&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="vi">@count</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">count</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">Counter</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">Counter</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="n">c1</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
<span class="nb">print</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c2</span>
<span class="nb">print</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">c2</span>
<span class="nb">print</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c2</span>
</pre></div>
</div>
<p>By including the <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> mixin, the <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class obtains
comparison methods such as <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> that use the general
<code class="docutils literal notranslate"><span class="pre">&lt;=&gt;</span></code> comparison method defined in <code class="docutils literal notranslate"><span class="pre">Counter</span></code>.</p>
<p>We will see later how to implement mixins in C++ using the <a class="reference internal" href="#curiously-recurring-template-pattern">curiously
recurring template pattern</a>.</p>
</section>
<section id="class-hierarchies">
<h2>Class Hierarchies<a class="headerlink" href="#class-hierarchies" title="Link to this heading"></a></h2>
<p>In some languages, such as Java and Python, every class eventually
derives from a root class, called <code class="docutils literal notranslate"><span class="pre">Object</span></code> in Java and <code class="docutils literal notranslate"><span class="pre">object</span></code> in
Python. This results in a single class hierarchy rooted at the root
class. In Java, this hierarchy is a tree, since Java does not allow
multiple inheritance outside of interfaces. Python does allow multiple
inheritance, so the hierarchy is a directed acyclic graph. Other
languages, including C++, do not have a root class.</p>
<p>A root class enables code to be written that works on all class-type
objects. For example, a <code class="docutils literal notranslate"><span class="pre">Vector&lt;Object&gt;</span></code> in Java can hold objects of
any type. Because the <code class="docutils literal notranslate"><span class="pre">Object</span></code> class defines an <code class="docutils literal notranslate"><span class="pre">equals()</span></code> method,
such a data structure can be searched to find an object that is
semantically equal to an item:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">unique</span><span class="p">(</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">item</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">result</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">contains()</span></code> method of <code class="docutils literal notranslate"><span class="pre">Vector&lt;Object&gt;</span></code> calls
the <code class="docutils literal notranslate"><span class="pre">equals()</span></code> method on an element. Since the root <code class="docutils literal notranslate"><span class="pre">Object</span></code> class
defines <code class="docutils literal notranslate"><span class="pre">equals()</span></code>, it is valid to call on an instance of any class.</p>
<p>In contrast, C++ allows <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> to hold a pointer to any object, so
that a <code class="docutils literal notranslate"><span class="pre">vector&lt;void</span> <span class="pre">*&gt;</span></code> can store pointers to arbitrary objects.
However, a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> does not implement any behavior, so we can only
compare such pointers by pointer value and not whether the actual
referenced objects are equal.</p>
</section>
<section id="method-overriding">
<span id="non-virtual"></span><h2>Method Overriding<a class="headerlink" href="#method-overriding" title="Link to this heading"></a></h2>
<p>The ability to <em>override</em> a method in a derived class is the key to
polymorphism in object-oriented programming. Overriding requires
<em>dynamic binding</em>, where the actual method to be invoked is determined
by an object’s dynamic type rather than the type apparent in the
program source.</p>
<p>As we will see shortly, dynamic binding comes at a runtime cost. To
avoid this cost wherever possible, instance methods do not use dynamic
binding by default in C++. Instead, an instance method must be
designated as <em>virtual</em> in order for dynamic binding to be used. Java,
on the other hand, uses dynamic binding for all instance methods,
except those designated as <em>final</em> in some cases, since they cannot be
overridden. Both languages use static binding for static methods,
whether or not they are dispatched through an object.</p>
<p><a class="reference internal" href="#dynamically-typed">Dynamically typed</a> languages universally support dynamic binding,
since objects do not have a static type. Such languages include Python
and Ruby.</p>
<p>In languages that support method overloading, including C++ and Java,
a method generally must have the same parameter list as the method it
is overriding. Otherwise, the new definition is treated as overloading
or hiding the base-class method instead. This can lead to unexpected
behavior, such as the following code in Java:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">vec</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)));</span>
</pre></div>
</div>
<p>This code, when run, prints out <code class="docutils literal notranslate"><span class="pre">false</span></code>. The problem is that the
<code class="docutils literal notranslate"><span class="pre">equals()</span></code> method defined in <code class="docutils literal notranslate"><span class="pre">Object</span></code> has the signature:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
</pre></div>
</div>
<p>The difference in the parameter type causes the <code class="docutils literal notranslate"><span class="pre">equals()</span></code> that is
defined in <code class="docutils literal notranslate"><span class="pre">Foo</span></code> to be an overload rather than overriding the
inherited method. Combined with the fact that <a class="reference internal" href="#generics">generics</a> in Java do
not generate code that is specialized to the type parameter, this
results in the original <code class="docutils literal notranslate"><span class="pre">equals()</span></code> method being called from the
<code class="docutils literal notranslate"><span class="pre">contains()</span></code> method in <code class="docutils literal notranslate"><span class="pre">Vector</span></code>.</p>
<p>Java allows a method to be annotated to assert that it is an override,
as follows:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@Override</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The compiler will then detect that the method does not in fact
override a base-class method and will report an error. C++11 has a
similar <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword that can be placed at the end of a method
signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">Bar</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
</pre></div>
</div>
<section id="covariance-and-contravariance">
<span id="id4"></span><h3>Covariance and Contravariance<a class="headerlink" href="#covariance-and-contravariance" title="Link to this heading"></a></h3>
<p>Some statically typed languages, including C++ and Java, permit
<em>covariant return types</em>, where the return type of an overriding
method is a derived type of the return type in the overridden method.
Such a narrowing is semantically valid, since a derived object can be
used (at least as far as the type system is concerned) where a base
type is expected. The <code class="docutils literal notranslate"><span class="pre">clone()</span></code> method in Java is an example, where
the version in <code class="docutils literal notranslate"><span class="pre">Object</span></code> returns <code class="docutils literal notranslate"><span class="pre">Object</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="nd">@Override</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Foo</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">();</span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="na">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Equally valid semantically for parameter types is <em>contravariance</em>,
where an overriding method takes in a base type of the parameter type
in the overridden method. However, in languages that allow
overloading, parameter contravariance results in an ambiguity: is the
newly defined method an override of the original method, an overload
of the method, or does it hide the base-class method? Consider the
following example in Java:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">Foo</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Bar</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">b.foo(arg)</span></code>, where <code class="docutils literal notranslate"><span class="pre">b</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Bar</span></code>, results in
different behavior depending on the type of <code class="docutils literal notranslate"><span class="pre">arg</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Bar</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Bar</span><span class="p">();</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="na">foo</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Bar</span><span class="p">()));</span><span class="w">     </span><span class="c1">// prints 0</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="na">foo</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">()));</span><span class="w">  </span><span class="c1">// prints 1</span>
</pre></div>
</div>
<p>Thus, in Java, defining a method with a parameter that is
contravariant to the base-class method results in an overload. On the
other hand, in C++, this pattern hides the base-class method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Bar</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="n">Bar</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">   </span><span class="c1">// prints 1</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="n">Base</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// prints 1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In both languages, the derived-class method with contravariant
parameters does not override the base-class method.</p>
</section>
<section id="accessing-hidden-or-overridden-members">
<h3>Accessing Hidden or Overridden Members<a class="headerlink" href="#accessing-hidden-or-overridden-members" title="Link to this heading"></a></h3>
<p>In many languages, base-class members that are not overridden but
redefined in a derived class are <em>hidden</em> by the definition in the
derived class. This is the case for non-virtual methods in C++, as
well as virtual methods that differ in signature from the method
defined in the base class. In Java, on the other hand, a derived-class
method with the same name as a base-class method but a different
signature overloads the base-class method rather than override or hide
it, as we saw in <a class="reference internal" href="#method-overriding">Method Overriding</a>.</p>
<p>In record-based languages, redefining a field in a derived class
usually results in the derived object containing both the hidden and
the redefined field. In dictionary-based languages, however, objects
usually only have a single field for a given name. Using <code class="docutils literal notranslate"><span class="pre">__slots__</span></code>
in Python, space is reserved for both the hidden and the redefined
field, but field access always accesses the slot defined in the
derived class.</p>
<p>A common pattern in a derived-class method is to add functionality to
that of the base-class method that it is overriding or hiding. In
order to avoid repeating code, most languages provide a means of
calling the base-class method. In C++, the scope-resolution operator
enables this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A::foo()&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B::foo()&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>More common is some variation of <code class="docutils literal notranslate"><span class="pre">super</span></code>, as in the following in
Java:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;A.foo()&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">B</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">super</span><span class="p">.</span><span class="na">foo</span><span class="p">();</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;B.foo()&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python uses similar syntax:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A.foo()&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B.foo()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The same mechanisms can be used to access a hidden field, i.e. the
scope-resolution operator in C++ and <code class="docutils literal notranslate"><span class="pre">super</span></code> in Java. In Python,
<code class="docutils literal notranslate"><span class="pre">super()</span></code> can be used to access hidden static fields; instance
fields are not replicated within an object.</p>
<p>Perhaps the most common case where a base class member needs to be
accessed is the constructor for the derived class, where the
base-class constructor needs to be invoked. In C++, a base-class
constructor can be explicitly invoked from a constructor’s initializer
list:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">B</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If no explicit call is made to a base-class constructor, a call to the
default constructor of the base class is inserted by the compiler, and
it is an error if such a constructor does not exist. The base-class
constructor runs before any other initializers or the body of the
derived-class constructor, regardless of where the former appears in
the latter’s initializer list.</p>
<p>In Java, a call to a base-class constructor must be the first
statement in a constructor, and the compiler implicitly inserts a call
to the zero-argument base-class constructor if an explicit call is not
provided.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">B</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">B</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">super</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python, a call to a base-class constructor must be made explicitly,
and the interpreter does not insert one if it is missing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="implementing-dynamic-binding">
<h2>Implementing Dynamic Binding<a class="headerlink" href="#implementing-dynamic-binding" title="Link to this heading"></a></h2>
<p>In dictionary-based languages such as Python, dynamic binding is
straightforward to implement with a sequence of dictionary lookups at
runtime. In particular, when accessing an attribute of an object in
Python, Python first searches the dictionary for the object itself. If
it is not found, then it searches the dictionary for the object’s
class. If the attribute is still not found, it proceeds to the
base-class dictionaries.</p>
<p>In record-based languages, however, efficiency is a primary concern,
and dynamic name lookup can be prohibitively expensive. Instead, such
languages commonly store pointers to methods that need to be looked up
dynamically in a structure called a <em>virtual table</em>, or <em>vtable</em> for
short. This name is a reflection of the term “virtual” in C++, which
denotes methods that are dynamically bound.</p>
<p>As an example, consider the following C++ code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">d</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">e</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The storage for an object of type <code class="docutils literal notranslate"><span class="pre">A</span></code> contains as its first item
a pointer to the vtable for class <code class="docutils literal notranslate"><span class="pre">A</span></code>, which is then followed by
entries for fields <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>. The vtable for <code class="docutils literal notranslate"><span class="pre">A</span></code> contains
pointers to each of its virtual methods in order, as shown in
<a class="reference internal" href="#figure-vtable-a"><span class="std std-numref">Figure 27</span></a>.</p>
<figure class="align-center" id="id11">
<span id="figure-vtable-a"></span><a class="reference internal image-reference" href="_images/vtable_a.svg"><img alt="_images/vtable_a.svg" src="_images/vtable_a.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Figure 27 </span><span class="caption-text">A record-based implementation of an object with dynamically bound
methods stores a vtable pointer at the beginning of the object. The
vtable stores pointers to each dynamically bound method.</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Neither the storage for an object of type <code class="docutils literal notranslate"><span class="pre">A</span></code> nor the vtable for
<code class="docutils literal notranslate"><span class="pre">A</span></code> contains a pointer to <code class="docutils literal notranslate"><span class="pre">A::f</span></code>: the latter is not a virtual
method and so is not dynamically bound. Instead, the compiler can
generate a direct dispatch to <code class="docutils literal notranslate"><span class="pre">A::f</span></code> when the method is called on an
object whose static type is <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The storage for an object of type <code class="docutils literal notranslate"><span class="pre">B</span></code> also contains a vtable pointer
as its first item. This is then followed by inherited fields, after
which are slots for fields introduced by <code class="docutils literal notranslate"><span class="pre">B</span></code>. The vtable for <code class="docutils literal notranslate"><span class="pre">B</span></code>
contains pointers for each of its methods. First come methods
inherited from <code class="docutils literal notranslate"><span class="pre">A</span></code> or overridden, in the same order as in the vtable
for <code class="docutils literal notranslate"><span class="pre">A</span></code>. Then the new methods introduced by <code class="docutils literal notranslate"><span class="pre">B</span></code> follow, as
illustrated in <a class="reference internal" href="#figure-vtable-b"><span class="std std-numref">Figure 28</span></a>.</p>
<figure class="align-center" id="id12">
<span id="figure-vtable-b"></span><a class="reference internal image-reference" href="_images/vtable_b.svg"><img alt="_images/vtable_b.svg" src="_images/vtable_b.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Figure 28 </span><span class="caption-text">The layout of a derived-class object consists of a vtable pointer,
then inherited fields, followed by fields introduced by the derived
class. The vtable for the derived class begins with the same layout
as that of the base class, followed by new methods introduced by
the derived class.</span><a class="headerlink" href="#id12" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>As mentioned previously, fields are statically bound, but fields that
are inherited from <code class="docutils literal notranslate"><span class="pre">A</span></code> are at the same offsets in both <code class="docutils literal notranslate"><span class="pre">A</span></code> and
<code class="docutils literal notranslate"><span class="pre">B</span></code>. Thus, the compiler can translate a field access to an offset
into an object, and the same offset will work for a base class and its
derived classes. We can observe this by computing the offset of the
member <code class="docutils literal notranslate"><span class="pre">x</span></code> in an <code class="docutils literal notranslate"><span class="pre">A</span></code> and a <code class="docutils literal notranslate"><span class="pre">B</span></code> from the beginning of the object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Converting a pointer to a <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> results in its address value.
Running the above code results in the same offset of 8 using Clang on
a 64-bit Intel machine, reflecting the size of the vtable pointer that
comes before <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Dynamically bound methods, on the other hand, require an indirection.
A method override has the same offset in a derived class’s vtable as
the overridden method in the base class’s vtable. In the example
above, <code class="docutils literal notranslate"><span class="pre">B::b</span></code> is located in the second entry in the vtable for
<code class="docutils literal notranslate"><span class="pre">B</span></code>, which is the same offset as where <code class="docutils literal notranslate"><span class="pre">A::b</span></code> is stored in the
vtable for <code class="docutils literal notranslate"><span class="pre">A</span></code>. Thus, the compiler can translate a dynamic method
call to a dereference into the object to get to its vtable, a fixed
offset into the vtable, followed by another dereference to get to the
actual code pointer. As an example, consider the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">aptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="n">aptr</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span>
</pre></div>
</div>
<p>The following pseudocode demonstrates the process of calling <code class="docutils literal notranslate"><span class="pre">b()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// extract vtable pointer from start of object</span>
<span class="n">vtable_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aptr</span><span class="o">-&gt;&lt;</span><span class="n">vtable</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// index into vtable at statically computed offset for b</span>
<span class="n">func_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vtable_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="c1">// call function, passing the implicit this parameter</span>
<span class="n">func_ptr</span><span class="p">(</span><span class="n">aptr</span><span class="p">);</span>
</pre></div>
</div>
<p>This process requires two dereferences to obtain the code location of
the dynamically bound method, one to extract the vtable pointer from
the object and another to index into the vtable. In contrast, the code
location for a statically bound method call can be determined at
compile time, which is more efficient than the two runtime
dereferences required in dynamic binding.</p>
<section id="full-lookup-and-dispatch-process">
<h3>Full Lookup and Dispatch Process<a class="headerlink" href="#full-lookup-and-dispatch-process" title="Link to this heading"></a></h3>
<p>In general, the <em>receiver</em> of a method call in a statically typed
language can have a dynamic type that differs from its static type.
For example, in the code below, the receivers of the first two method
calls have static type <code class="docutils literal notranslate"><span class="pre">A</span></code> while their dynamic type is <code class="docutils literal notranslate"><span class="pre">B</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">aptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="n">A</span><span class="w"> </span><span class="o">&amp;</span><span class="n">aref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">aptr</span><span class="p">;</span>
<span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">bptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="n">aptr</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span><span class="w">    </span><span class="c1">// receiver has static type A, dynamic type B</span>
<span class="n">aref</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w">     </span><span class="c1">// receiver has static type A, dynamic type B</span>
<span class="n">bptr</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span><span class="w">    </span><span class="c1">// receiver has static type B, dynamic type B</span>
</pre></div>
</div>
<p>The following is the general pattern that statically typed languages
use to look up the target method and generate a dispatch to the
appropriate code:</p>
<ol class="arabic">
<li><p>Look up the member (e.g. <code class="docutils literal notranslate"><span class="pre">b</span></code> in the case of <code class="docutils literal notranslate"><span class="pre">aptr-&gt;b()</span></code>) in the
<em>static</em> type of the receiver, performing function-overload
resolution if necessary to determine which method is being called.</p></li>
<li><p>If the resolved method is non-virtual, then generate a direct
dispatch to the code for that method. For example, in the call
<code class="docutils literal notranslate"><span class="pre">aref.f()</span></code> above, a direct dispatch to <code class="docutils literal notranslate"><span class="pre">A::f</span></code> would be
generated since <code class="docutils literal notranslate"><span class="pre">A::f</span></code>, the result of the lookup, is non-virtual.</p></li>
<li><p>If the resolved method is virtual, then determine its offset in the
vtable of the static type. In the case of <code class="docutils literal notranslate"><span class="pre">aptr-&gt;b()</span></code>, the
resolved method is <code class="docutils literal notranslate"><span class="pre">A::b</span></code>, which is the second entry in the
vtable for <code class="docutils literal notranslate"><span class="pre">A</span></code>. Then an indirect dispatch is generated, as
described previously:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vtable_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aptr</span><span class="o">-&gt;&lt;</span><span class="n">vtable</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">func_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vtable_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">func_ptr</span><span class="p">(</span><span class="n">aptr</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="multiple-inheritance">
<h2>Multiple Inheritance<a class="headerlink" href="#multiple-inheritance" title="Link to this heading"></a></h2>
<p>Some languages allow a class to directly inherit from multiple base
classes. This includes the limited form enabled by Java’s interfaces,
as well as the fully general multiple inheritance provided by Python
and C++. Multiple inheritance raises several semantic and
implementation issues that do not occur in single inheritance.</p>
<section id="dictionary-based-implementation">
<h3>Dictionary-Based Implementation<a class="headerlink" href="#dictionary-based-implementation" title="Link to this heading"></a></h3>
<p>In Python, where instance fields are stored in an object’s dictionary
by default, there is no concept of inheriting instance fields from a
base class. Thus, in the absence of <code class="docutils literal notranslate"><span class="pre">__slots__</span></code>, multiple
inheritance poses no problems for looking up an instance field. On the
other hand, methods are generally stored in the dictionary for a
class, along with static fields. Thus, a key question raised by
multiple inheritance is in which order to search base-class
dictionaries if an attribute is not found in the dictionary for an
object or its class. The solution is non-trivial, as can be seen in
the example below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">defend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;run away!&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Insect</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">WingedAnimal</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">defend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fly away!&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Butterfly</span><span class="p">(</span><span class="n">Insect</span><span class="p">,</span> <span class="n">WingedAnimal</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">defend()</span></code> is called on a <code class="docutils literal notranslate"><span class="pre">Butterfly</span></code>, there are several orders
in which the method can be looked up among its base classes. A naive
depth-first search would result in <code class="docutils literal notranslate"><span class="pre">Animal.defend</span></code>, but
<code class="docutils literal notranslate"><span class="pre">WingedAnimal.defend</span></code> is in a sense “more derived” than
<code class="docutils literal notranslate"><span class="pre">Animal.defend</span></code> and should be preferred in most cases. The actual
algorithm used by Python is <a class="reference external" href="https://en.wikipedia.org/wiki/C3_linearization">C3 linearization</a>, which results in
an order that preserves certain important aspects of the inheritance
hierarchy. The details are beyond the scope of this text, but the
result is that <code class="docutils literal notranslate"><span class="pre">WingedAnimal.defend</span></code> is used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Butterfly</span><span class="p">()</span><span class="o">.</span><span class="n">defend</span><span class="p">()</span>
<span class="go">fly away!</span>
</pre></div>
</div>
</section>
<section id="record-based-implementation">
<h3>Record-Based Implementation<a class="headerlink" href="#record-based-implementation" title="Link to this heading"></a></h3>
<p>In a record-based implementation, multiple inheritance makes it
impossible to ensure that a field is stored at a consistent offset
from the beginning of an object. Consider the following C++ code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">b</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">c</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">d</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">c</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">e</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In objects of type <code class="docutils literal notranslate"><span class="pre">A</span></code>, the field <code class="docutils literal notranslate"><span class="pre">x</span></code> is stored in the first entry
after the vtable pointer. Similarly, <code class="docutils literal notranslate"><span class="pre">y</span></code> in <code class="docutils literal notranslate"><span class="pre">B</span></code> is stored in the
first entry. With <code class="docutils literal notranslate"><span class="pre">C</span></code> deriving from both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, only one
of those fields can be stored in the first entry for <code class="docutils literal notranslate"><span class="pre">C</span></code>. A similar
problem occurs for method entries in a vtable.</p>
<p>Python classes that define <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> suffer the same problem, as
in the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Python’s solution to this conflict is to make it illegal for a class
to derive from multiple base classes that define <code class="docutils literal notranslate"><span class="pre">__slots__</span></code>.</p>
<p>C++, on the other hand, does permit code like the above. The solution
that C++ uses is to combine different views of an object that has
multiple base classes within the storage for the object. In the
example above, we would have one view of the object from the
perspective of <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>, and a separate view from the
perspective of <code class="docutils literal notranslate"><span class="pre">B</span></code>, each with its own vtable.
<a class="reference internal" href="#figure-vtable-c"><span class="std std-numref">Figure 29</span></a> illustrates the two views.</p>
<figure class="align-center" id="id13">
<span id="figure-vtable-c"></span><a class="reference internal image-reference" href="_images/vtable_c.svg"><img alt="_images/vtable_c.svg" src="_images/vtable_c.svg" width="800" /></a>
<figcaption>
<p><span class="caption-number">Figure 29 </span><span class="caption-text">Multiple inheritance in a record-based implementation results in
multiple views of an object, each with its own vtable.</span><a class="headerlink" href="#id13" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Now the view used depends on the type of pointer or reference that
refers to a <code class="docutils literal notranslate"><span class="pre">C</span></code> object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="w"> </span><span class="o">*</span><span class="n">c_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">();</span><span class="w">    </span><span class="c1">// uses view A, C</span>
<span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">a_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ptr</span><span class="p">;</span><span class="w">      </span><span class="c1">// uses view A, C</span>
<span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">b_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ptr</span><span class="p">;</span><span class="w">      </span><span class="c1">// uses view B</span>
</pre></div>
</div>
<p>When a pointer of type <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">*</span></code> is converted to one of type <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">*</span></code>,
the compiler automatically adjusts the pointer to use the view for
<code class="docutils literal notranslate"><span class="pre">B</span></code>. Then the offset for <code class="docutils literal notranslate"><span class="pre">y</span></code> from that view is the same as that of
an object of type <code class="docutils literal notranslate"><span class="pre">B</span></code>. Similarly, the methods that are inherited
from <code class="docutils literal notranslate"><span class="pre">B</span></code> or overridden are located at the same vtable offsets in the
vtable for view <code class="docutils literal notranslate"><span class="pre">B</span></code> as in the vtable for an object of type <code class="docutils literal notranslate"><span class="pre">B</span></code>
itself. The same properties hold for the <code class="docutils literal notranslate"><span class="pre">A</span></code> view and objects of
actual type <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The problem is not yet completely solved, however. What happens when
we invoke an overridden method through the <code class="docutils literal notranslate"><span class="pre">B</span></code> view? Specifically,
consider the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">C::c</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">C</span><span class="w"> </span><span class="o">*</span><span class="n">c_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">();</span>
<span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">b_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ptr</span><span class="p">;</span>
<span class="n">c_ptr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">();</span>
<span class="n">b_ptr</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">();</span>
</pre></div>
</div>
<p>If the code generated for <code class="docutils literal notranslate"><span class="pre">C::c()</span></code> assumes an offset for <code class="docutils literal notranslate"><span class="pre">z</span></code> based
on the <code class="docutils literal notranslate"><span class="pre">C</span></code> view, then that same offset is not valid for the <code class="docutils literal notranslate"><span class="pre">B</span></code>
view. In particular, <code class="docutils literal notranslate"><span class="pre">z</span></code> is two vtable pointers and two <code class="docutils literal notranslate"><span class="pre">int</span></code>s
away from the beginning of the <code class="docutils literal notranslate"><span class="pre">C</span></code> view, but it is one vtable
pointer and one <code class="docutils literal notranslate"><span class="pre">int</span></code> away in the <code class="docutils literal notranslate"><span class="pre">B</span></code> view. We need to arrange for
the view of the object to be the <code class="docutils literal notranslate"><span class="pre">C</span></code> view in the body of <code class="docutils literal notranslate"><span class="pre">C::c()</span></code>,
even when the method is invoked through a <code class="docutils literal notranslate"><span class="pre">B</span></code> pointer. One way to do
this is to store offsets in vtable entries that designate how to
change the pointer when the given method is invoked, as in
<a class="reference internal" href="#figure-vtable-c-off"><span class="std std-numref">Figure 30</span></a>.</p>
<figure class="align-center" id="id14">
<span id="figure-vtable-c-off"></span><a class="reference internal image-reference" href="_images/vtable_c_off.svg"><img alt="_images/vtable_c_off.svg" src="_images/vtable_c_off.svg" width="800" /></a>
<figcaption>
<p><span class="caption-number">Figure 30 </span><span class="caption-text">Calling a base-class method on an object that uses multiple
inheritance may require a this-pointer correction to switch from
one view of the object to another.</span><a class="headerlink" href="#id14" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Now, when the entry for <code class="docutils literal notranslate"><span class="pre">C::c</span></code> is looked up in <code class="docutils literal notranslate"><span class="pre">C</span></code>‘s vtable for
view <code class="docutils literal notranslate"><span class="pre">B</span></code>, the <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer in <code class="docutils literal notranslate"><span class="pre">C::c</span></code> should be corrected by
<code class="docutils literal notranslate"><span class="pre">-off</span></code> before it is invoked, where <code class="docutils literal notranslate"><span class="pre">off</span></code> is the distance between
the <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> views of an object of type <code class="docutils literal notranslate"><span class="pre">C</span></code>. This will ensure
that <code class="docutils literal notranslate"><span class="pre">C::c</span></code> receives the <code class="docutils literal notranslate"><span class="pre">C</span></code> view of the object.</p>
<p>In practice, a <em>thunk</em> (a compiler-generated function) is often used
to both perform this correction and call the target method. The vtable
entry for the method can then store a pointer to the thunk, and no
offset need be stored in the vtable. This avoids replicating the
correction code everywhere a method is called.</p>
<p>Another complication arises when multiple base classes define the same
function, as in the Python example above. The following is the same
example in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">defend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;run away!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Insect</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">WingedAnimal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">defend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;fly away!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Butterfly</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Insect</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">WingedAnimal</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A call to <code class="docutils literal notranslate"><span class="pre">defend()</span></code> on a <code class="docutils literal notranslate"><span class="pre">Butterfly</span></code> object can resolve to either
the version in <code class="docutils literal notranslate"><span class="pre">Animal</span></code> or <code class="docutils literal notranslate"><span class="pre">WingedAnimal</span></code>. Vtables alone cannot
solve this problem, and a more involved dynamic lookup process such as
C3 linearization would be required instead. However, C++ considers
such a method call to be ambiguous and will produce a compile-time
error if the call is attempted. Instead, C++ requires the programmer
to select a specific version using the scope-resolution operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Butterfly</span><span class="w"> </span><span class="n">bf</span><span class="p">;</span>
<span class="n">bf</span><span class="p">.</span><span class="n">WingedAnimal</span><span class="o">::</span><span class="n">defend</span><span class="p">();</span>
</pre></div>
</div>
<p>A final consideration in record-based implementations is how to handle
the <em>diamond problem</em>, where a single class occurs multiple times as
the base class for another class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">D</span></code> derives from <code class="docutils literal notranslate"><span class="pre">A</span></code> twice, once through
<code class="docutils literal notranslate"><span class="pre">B</span></code> and once through <code class="docutils literal notranslate"><span class="pre">C</span></code>. Should an object of type <code class="docutils literal notranslate"><span class="pre">D</span></code> contain a
single copy of the fields inherited from <code class="docutils literal notranslate"><span class="pre">A</span></code>, or should there be two
copies? Different situations may call for different approaches, and
C++ allows both. The default is replication, but a shared copy of <code class="docutils literal notranslate"><span class="pre">A</span></code>
can be specified using <em>virtual inheritance</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Virtual inheritance is commonly implemented by introducing indirection
to access data members of the virtual base class, in a manner similar
to vtables and vtable pointers.</p>
<p>As this example demonstrates, the intermediate classes <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>
are the ones that must declare <code class="docutils literal notranslate"><span class="pre">A</span></code> as a virtual base class, even
though it is the class <code class="docutils literal notranslate"><span class="pre">D</span></code> that actually gives rise to the diamond
problem. This implies that the writer of the intermediate classes must
know a priori that derived classes may run into the diamond problem.
Thus, to some degree, this breaks the abstraction barrier between base
and derived classes.</p>
</section>
</section>
</section>
<section id="static-analysis">
<h1>Static Analysis<a class="headerlink" href="#static-analysis" title="Link to this heading"></a></h1>
<p>In processing a program, a compiler performs <em>static analysis</em> on the
source code without actually running the program. Analysis is done to
detect bugs in programs as well as to determine information that can
be used to generate optimized code. However, as demonstrated by
<a class="reference external" href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice’s theorem</a>,
the general problem of static analysis of the behavior of a program
written in a Turing-complete language is <em>undecidable</em>, meaning that
it is not solvable by a computer. Thus, program analysis on
Turing-complete languages can only approximate the answer, and there
will always be cases where the result determined by the analysis is
incorrect.</p>
<p>In designing an analysis, we usually make the choice between the
analysis being <em>sound</em> or <em>complete</em>, which characterizes where the
analysis may produce an incorrect result:</p>
<ul class="simple">
<li><p>A <em>sound</em> analysis only accepts programs that are correct with
respect to the behavior being analyzed. If a program is incorrect,
the analysis is guaranteed to reject it. On the other hand, if a
program is correct, it is possible for the analysis to reject it,
resulting in <em>false negatives</em>. Since a sound analysis only accepts
correct programs, if a program passes the analysis, we know that it
must be correct. However, if a program fails the analysis, it may or
may not be correct.</p></li>
<li><p>A <em>complete</em> analysis accepts all programs that are correct with
respect to the behavior being analyzed. If a program is incorrect,
it is possible for the analysis to accept it, resulting in <em>false
positives</em>. If a program fails the analysis, it must be erroneous,
but if the program passes the analysis, it may or may not be
correct.</p></li>
</ul>
<p>It is often the case that static analyses are designed to be sound,
while dynamic (runtime) analyses are typically designed to be
complete.</p>
<p>An analysis cannot be both sound and complete, but it is possible for
an analysis to be neither. In such a case, it produces both false
positives and false negatives, which is undesirable. However, in
practice, real-world analyses often end up being neither sound nor
complete due to the complexity of the problems they are trying to
solve.</p>
<p>We proceed to discuss two common forms of static analysis, on types
and on control flow.</p>
<section id="types">
<span id="dynamically-typed"></span><span id="records"></span><h2>Types<a class="headerlink" href="#types" title="Link to this heading"></a></h2>
<p>In <a class="reference internal" href="theory.html#formal-type-systems"><span class="std std-ref">Formal Type Systems</span></a>, we explored the
theoretical underpinnings of types and type checking. Here, we take a
less formal look at how languages handle types, reviewing some
concepts from type checking along the way.</p>
<p>In most programming languages, expressions and objects have a type
associated with them. An object’s type determines how its data are
interpreted; all data are represented as bits, and it is a datum’s
type that determines the meaning of those bits. Types also prevent
common errors, such as attempting to perform a semantically invalid
operation like adding a floating-point number and an array. For
languages in which types of variables and functions are specified in
the source code, they also serve as useful documentation concerning
for what a variable or function is used. In languages that support
ad-hoc polymorphism in the form of operator or function overloading,
types determine the specific operation to be applied to the input
data. Finally, types enable compilers to generate code that is
specialized to the type of an object or expression.</p>
<p>Compilers perform <em>type checking</em> to ensure that types are used in
semantically valid ways in a program. Languages that enable static
analysis to perform type checking at compile time are <em>statically
typed</em>, while those that can only be checked at runtime are
<em>dynamically typed</em>. Many languages use a mixture of static and
dynamic type checking.</p>
<p>Languages often provide a predefined set of <em>primitive</em> types, such as
integers, floating-point numbers, and characters, as well as a
mechanism for constructing <em>composite</em> types whose components, or
<em>fields</em>, are simpler types. Common examples are arrays, lists, and
<em>records</em>, the latter of which are known as <em>structs</em> in C and C++.</p>
<section id="type-equivalence">
<h3>Type Equivalence<a class="headerlink" href="#type-equivalence" title="Link to this heading"></a></h3>
<p>In some languages, composite types are distinguished by their
structure, so that all types with the same structure are considered to
be equivalent. This strategy is called <em>structural equivalence</em>, and
under this scheme, the following two types (using C-like syntax) would
be equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span> <span class="n">A</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">record</span> <span class="n">B</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In a handful of languages, such as ML, reordering the fields does not
affect type equivalence. Thus, a type such as the following would also
be equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span> <span class="n">C</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Most modern languages, on the other hand, use <em>name equivalence</em>,
which distinguishes between different occurrences of definitions within
a program. Under name equivalence, the types <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> above
would be considered distinct.</p>
<p>Some languages allow aliases to be defined for an existing type, such
as the following declarations in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">double</span><span class="p">;</span>
</pre></div>
</div>
<p>Under <em>strict name equivalence</em>, aliases are considered distinct
types, so that <code class="docutils literal notranslate"><span class="pre">weight</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> are not equivalent. This can
prevent errors involving inadvertently interchanging types that alias
the same underlying type but are semantically distinct, as in the
following involving <code class="docutils literal notranslate"><span class="pre">weight</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">height</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span><span class="p">(</span><span class="mf">200.</span><span class="p">);</span>
</pre></div>
</div>
<p>The languages in the C family, however, have <em>loose name equivalence</em>,
so that aliases are considered equivalent to each other and to the
original type. The code above is permitted under loose name
equivalence.</p>
</section>
<section id="type-compatibility">
<h3>Type Compatibility<a class="headerlink" href="#type-compatibility" title="Link to this heading"></a></h3>
<p>In most languages, strict equivalence of types is not required in
order for the types to be used in the same context. Rather, most
languages specify <em>type compatibility</em> rules that determine when
one type can be used where another one is expected.</p>
<p><a class="reference internal" href="#subtype-polymorphism">Subtype polymorphism</a> is one example of type compatibility.
Languages that support subtypes, such as those that support the
object-oriented paradigm, allow an object of a derived type to be used
where an object of a base type is expected.</p>
<p>In other contexts, a language may allow a type to be used where
another is expected by converting a value of the former type to the
latter. Such a conversion, when done implicitly, is called a <em>type
coercion</em>. A common example is when performing an arithmetic operation
on different numeric types. In an expression such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>, if one
of the operands has integral type and the other has floating-point
type, most languages coerce the integral value to floating-point
before performing the addition. Languages usually specify rules for
which numeric types are coerced, or <em>promoted</em>, to others. A few
languages, such as C++, include a mechanism for defining type
coercions on user-defined types.</p>
<p>Some languages allow coercion when initializing or assigning an object
with a value from a different type. For numeric types, some languages
only allow initialization or assignment that performs a coercion that
follows the type promotion rules. For example, in Java, coercing an
<code class="docutils literal notranslate"><span class="pre">int</span></code> value to a <code class="docutils literal notranslate"><span class="pre">double</span></code> is allowed, while the latter is
prohibited:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.4</span><span class="p">;</span><span class="w">   </span><span class="c1">// error</span>
<span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// OK</span>
</pre></div>
</div>
<p>The promotion rules are often designed to avoid loss of information.
In particular, converting a <code class="docutils literal notranslate"><span class="pre">double</span></code> value to an <code class="docutils literal notranslate"><span class="pre">int</span></code> loses
information about the fractional part of the value. In other
languages, however, such as C and C++, lossy coercions are permitted,
and both definitions above would be accepted.</p>
<p>Another common example of coercion that we’ve already seen is that of
l-values to r-values, where an r-value is expected.</p>
<p>Languages with type qualifiers specify rules for when a type with one
qualification can be coerced to the same type with a different
qualification. For example, C++ specifies when <code class="docutils literal notranslate"><span class="pre">const</span></code> and
non-<code class="docutils literal notranslate"><span class="pre">const</span></code> types can be coerced to each other. In particular, a
non-<code class="docutils literal notranslate"><span class="pre">const</span></code> l-value can be coerced to a <code class="docutils literal notranslate"><span class="pre">const</span></code> l-value, but the
reverse is not allowed without an explicit <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>. On the
other hand, a <code class="docutils literal notranslate"><span class="pre">const</span></code> l-value can be coerced to a non-<code class="docutils literal notranslate"><span class="pre">const</span></code>
r-value. The following illustrates some examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">    </span><span class="c1">// OK: l-value to r-value</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">              </span><span class="c1">// OK: const l-value to r-value</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">         </span><span class="c1">// OK: no coercion</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">         </span><span class="c1">// ERROR: const l-value to non-const l-value</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">   </span><span class="c1">// OK: non-const l-value to const l-value</span>
</pre></div>
</div>
<p>In order to check the types in a program, a strongly typed language
determines the type of every expression in the program. For example,
in the compound expression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span></code>, the type of the
subexpression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> must be known in order to determine what
operation to apply to its result and <code class="docutils literal notranslate"><span class="pre">c</span></code>, whether or not a coercion
is necessary or permitted. In the case of a function-call expression,
the type of the expression is the return type of the function. In the
case of an operator, the language defines what the type of the
expression is based on the types of the operands.</p>
<p>The following is an example in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Weight is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; grams&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">to_string()</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">string</span></code>, so that is the type
of the expression <code class="docutils literal notranslate"><span class="pre">to_string(10)</span></code>. Applying the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator to a
<code class="docutils literal notranslate"><span class="pre">string</span></code> and a string (character-array) literal in turn results in
<code class="docutils literal notranslate"><span class="pre">string</span></code>. Applying the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator to an <code class="docutils literal notranslate"><span class="pre">ostream&amp;</span></code> and a
<code class="docutils literal notranslate"><span class="pre">string</span></code> results in an <code class="docutils literal notranslate"><span class="pre">ostream&amp;</span></code>. Lastly, <code class="docutils literal notranslate"><span class="pre">endl</span></code> is a function
that is an <em>I/O manipulator</em>, and applying <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> to an <code class="docutils literal notranslate"><span class="pre">ostream&amp;</span></code>
and such a function also produces an <code class="docutils literal notranslate"><span class="pre">ostream&amp;</span></code>.</p>
<p>A particular non-trivial case is that of the conditional expression
in languages that use static typing. Consider the following example
in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.4</span><span class="p">;</span>
<span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">RAND_MAX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">RAND_MAX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>What are the types of the conditional expression? In the first case,
both options are of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, so the result should be of type
<code class="docutils literal notranslate"><span class="pre">int</span></code>. In the second case, however, one option is of type <code class="docutils literal notranslate"><span class="pre">int</span></code>
while the other is of type <code class="docutils literal notranslate"><span class="pre">double</span></code>. C++ uses a complex set of rules
to determine which of the two types can be coerced to the other, and
the coercion rules here differ from those in other contexts. The
expression is only valid if exactly one of the types can be coerced to
the other. In this case, the resulting expression has type <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</section>
<section id="type-inference">
<span id="type-deduction"></span><h3>Type Inference<a class="headerlink" href="#type-inference" title="Link to this heading"></a></h3>
<p>Since the type of each expression is not specified in source code,
compilers perform <em>type inference</em> to compute their types. Some
languages allow programmers to make use of the type-inference
facilities of the compiler by allowing types to be elided from
declarations if they can be inferred. Many modern statically typed
languages allow types to be elided completely in certain contexts.</p>
<p>As an example, we have already seen that Java and C++ allow the return
type to be elided from a <a class="reference internal" href="functional.html#lambda-expression"><span class="std std-ref">lambda expression</span></a>,
and that Java also allows the parameter types to be elided:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">IntPredicate</span><span class="w"> </span><span class="nf">makeGreaterThan</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have also seen that C++ allows the type of a variable to be deduced
with the <code class="docutils literal notranslate"><span class="pre">auto</span></code> keyword:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">    </span><span class="c1">// deduced to have type int</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">   </span><span class="c1">// deduced to have type int &amp;</span>
</pre></div>
</div>
<p>The rules for type deduction in C++ have complex interactions with
reference types, as illustrated above. We will not consider them here.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">auto</span></code> keyword requires that a variable be initialized at
declaration, so that the type can be deduced from the initializer.
There are cases where this is not possible. Consider the following
class template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">U</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="o">???</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">   </span><span class="c1">// type of a + b</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, we want the type of <code class="docutils literal notranslate"><span class="pre">Foo::c</span></code> to be the same as the type of
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>, but without actually initializing it to that value. In
fact, C++ prohibits <code class="docutils literal notranslate"><span class="pre">auto</span></code> from being used with a non-static class
member. Instead, C++ provides the <code class="docutils literal notranslate"><span class="pre">decltype</span></code> keyword that computes
the type of an expression:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">U</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">   </span><span class="c1">// type of a + b</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="control-flow-analysis">
<h2>Control-Flow Analysis<a class="headerlink" href="#control-flow-analysis" title="Link to this heading"></a></h2>
<p>Compilers often perform analysis on the flow of control or data
through a program in order to provide early detection of bugs as well
as to optimize generated code. Such an analysis is referred to as
<em>control-flow</em> or <em>data-flow analysis</em>. Here, we consider a few common
examples of control-flow analysis.</p>
<p>Many imperative languages allow variables to be declared without being
explicitly initialized. Some languages specify semantics for default
initialization. In C and C++, however, variables of primitive type
have undefined values upon default initialization, so the behavior of
a program that uses such a variable is undefined. Other languages,
such as Java, reject programs in which it cannot be proven that a
variable has been initialized before being used. The compiler analyzes
the source code to determine whether or not a control-flow path exists
that may result in the use of a variable without initialization. This
analysis is conservative, so that the standard Java compiler rejects
the following code:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Even though it may seem obvious that the body of one of the
conditionals must be executed, the compiler is unable to determine
that this is the case. Instead, it conservatively assumes that it is
possible for neither conditional test to succeed, so that <code class="docutils literal notranslate"><span class="pre">i</span></code> may be
used uninitialized. Thus, the compiler reports an error like the
following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">variable</span> <span class="n">i</span> <span class="n">might</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">been</span> <span class="n">initialized</span>
    <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                     <span class="o">^</span>
<span class="mi">1</span> <span class="n">error</span>
</pre></div>
</div>
<p>On the other hand, modifying the code as follows enables the compiler
to determine that <code class="docutils literal notranslate"><span class="pre">i</span></code> must be initialized:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the compiler can determine that one of the two branches of the
conditional must execute, so that <code class="docutils literal notranslate"><span class="pre">i</span></code> is always initialized before
use.</p>
<p>Some C and C++ compilers perform the same analysis and report a
warning if a default-initialized variable of primitive type may be
used. Java also performs a similar analysis to ensure that <code class="docutils literal notranslate"><span class="pre">final</span></code>
variables are initialized no more than once.</p>
<p>In languages that require a function to explicitly return an object, a
program may have control paths that do not ensure that a function
encounters a return statement before exiting. Compilers often perform
an analysis that is analogous to that of variable initialization in
order to ensure that a function reaches a return statement. Consider
the following method in Java:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once again, the compiler cannot guarantee that one of the conditionals
will have its body executed, and it reports an error such as the
following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bar</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">missing</span> <span class="k">return</span> <span class="n">statement</span>
  <span class="p">}</span>
  <span class="o">^</span>
<span class="mi">1</span> <span class="n">error</span>
</pre></div>
</div>
<p>An equivalent example in C++ produces a warning in some compilers,
such as the following in Clang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bar</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">control</span> <span class="n">may</span> <span class="n">reach</span> <span class="n">end</span> <span class="n">of</span> <span class="n">non</span><span class="o">-</span><span class="n">void</span> <span class="n">function</span>
      <span class="p">[</span><span class="o">-</span><span class="n">Wreturn</span><span class="o">-</span><span class="nb">type</span><span class="p">]</span>
<span class="p">}</span>
<span class="o">^</span>
<span class="mi">1</span> <span class="n">warning</span> <span class="n">generated</span><span class="o">.</span>
</pre></div>
</div>
<p>In some non-obvious cases, the compiler can guarantee that a return
must be reached before a function exits. The following example
succeeds in both the standard Java compiler and in Clang for
equivalent C++ code:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the compiler can determine that the only way to exit the loop is
through a return, so that the only way to exit the function is by
reaching the return statement.</p>
<p>The same analysis can be used to detect code that will never be
reached, and depending on the language and compiler, this may be
considered an error. For example, the following modification to
<code class="docutils literal notranslate"><span class="pre">baz()</span></code> is rejected by the standard Java compiler:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The compiler reports the following error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">baz</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">unreachable</span> <span class="n">statement</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">^</span>
<span class="mi">1</span> <span class="n">error</span>
</pre></div>
</div>
<p>In Java, the language explicitly disallows statements that can be
proven to be unreachable.</p>
</section>
</section>
<section id="dynamic-typing">
<span id="runtime-type-information"></span><h1>Dynamic Typing<a class="headerlink" href="#dynamic-typing" title="Link to this heading"></a></h1>
<p>In addition to dynamic binding, languages and implementations often
make other uses of dynamic type information, also called <em>runtime type
information (RTTI)</em>, as well as making it available in some form to
programmers.</p>
<p>Many languages provide a mechanism for checking whether or not an
object has a specific type at runtime. Depending on the language, the
query type may need to be specified at compile time, particularly if
the language does not support first-class types, or it may be computed
at runtime. For example, the following C++ code checks whether the
dynamic type of an object referred to by a base class pointer is of
the derived class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;got a B&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;not a B&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> operation attempts to cast an <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*</span></code> to a <code class="docutils literal notranslate"><span class="pre">B</span>
<span class="pre">*</span></code>, which will only succeed if the pointed-to object is actually an
instance of <code class="docutils literal notranslate"><span class="pre">B</span></code>. If the cast fails, then it produces a null pointer,
which has truth value false. C++ also allows <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> to be
used on references, in which case an exception is thrown upon failure.</p>
<p>In order for <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> to work, the types involved must define
at least one virtual method. This allows an implementation to use
vtable pointers, or entries in the vtable itself, to determine the
dynamic type of an object. Types that do not have virtual methods do
not have vtables, and their instances do not include vtable pointers.</p>
<p>C++ also has the <code class="docutils literal notranslate"><span class="pre">typeid</span></code> operator, which produces an object that
contains information about the type of the given operand. In order to
make use of <code class="docutils literal notranslate"><span class="pre">typeid</span></code>, the <code class="docutils literal notranslate"><span class="pre">&lt;typeinfo&gt;</span></code> header must be included.
The operator works on objects of any type, as well as types
themselves, and the result is an instance of <code class="docutils literal notranslate"><span class="pre">std::type_info</span></code>, which
contains basic information about the type. The following is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">type_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">type_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">());</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">type_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">main</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i1</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i2</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i3</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting names are implementation dependent. For example, GCC 5.5
produces <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">P1A</span> <span class="pre">FivE</span></code> when the code above is run.</p>
<p>Java supports the <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> operator, which determines whether or
not an object is an instance of the given type at runtime. Python has
the similar <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> function, which takes in an object and a
type as arguments.</p>
<p>Java also supports an operation similar to <code class="docutils literal notranslate"><span class="pre">typeid</span></code> in the form of
the <code class="docutils literal notranslate"><span class="pre">getClass()</span></code> method defined on all objects. The result is an
instance of <code class="docutils literal notranslate"><span class="pre">Class</span></code>, which contains extensive information about the
class of the object. Similarly, Python has a <code class="docutils literal notranslate"><span class="pre">type()</span></code> function. This
returns the actual type of an object, since types are first-class
entities in Python.</p>
<p>In Java, all casts on objects are dynamically checked. Rather than
producing a null pointer on failure, Java throws a
<code class="docutils literal notranslate"><span class="pre">ClassCastException</span></code>.</p>
<p>A specific case where Java needs to check the type of an object in its
internal implementation is when an item is stored in an array.
Originally, Java did not support parametric polymorphism, so the
decision was made to support polymorphic functions on arrays by making
all arrays whose elements are of object type derive from <code class="docutils literal notranslate"><span class="pre">Object[]</span></code>.
This allowed methods like the following to be defined and called on
any array of object type:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">printAll</span><span class="p">(</span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">items</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">items</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More specifically, Java specifies that <code class="docutils literal notranslate"><span class="pre">A[]</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">B[]</span></code>
if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>As an example of where this subtype relation can permit erroneous
code, consider the following:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">sarray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">oarray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sarray</span><span class="p">;</span>
<span class="n">oarray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">oarray</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">sarray</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="na">length</span><span class="p">();</span>
</pre></div>
</div>
<p>The second line is valid, since a <code class="docutils literal notranslate"><span class="pre">String[]</span></code> object can be assigned
to a variable of type <code class="docutils literal notranslate"><span class="pre">Object[]</span></code>. The third line is also valid,
since a <code class="docutils literal notranslate"><span class="pre">String</span></code> object can be stored in an <code class="docutils literal notranslate"><span class="pre">Object[]</span></code>. The fourth
line is valid according to the type system, since <code class="docutils literal notranslate"><span class="pre">Integer</span></code> derives
from <code class="docutils literal notranslate"><span class="pre">Object</span></code>, which can be stored in an element of an <code class="docutils literal notranslate"><span class="pre">Object[]</span></code>
variable. However, <code class="docutils literal notranslate"><span class="pre">Integer</span></code> does not derive from <code class="docutils literal notranslate"><span class="pre">String</span></code>, so at
runtime, we have an attempt to store an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> object into an
array of dynamic type <code class="docutils literal notranslate"><span class="pre">String[]</span></code>. This should be prevented, since we
could then call a <code class="docutils literal notranslate"><span class="pre">String</span></code> method on the element as in the fifth
line. Thus, Java checks the dynamic types of the array and the item
being stored at runtime and throws an <code class="docutils literal notranslate"><span class="pre">ArrayStoreException</span></code> if they
are incompatible.</p>
<p>A better solution to the problem would be to use parametric
polymorphism for operations on arrays, rather than making arrays
support subtype polymorphism. Unfortunately, parametric polymorphism
was introduced much later in Java’s existence, leading to a
significant body of code that depends on the subtype polymorphism of
arrays.</p>
</section>
<section id="generics">
<span id="parametric-polymorphism"></span><h1>Generics<a class="headerlink" href="#generics" title="Link to this heading"></a></h1>
<p>Subtype polymorphism relies on subtype relationships and dynamic
binding in order to provide the ability of a single piece of code to
behave according to the dynamic type of an object. In contrast,
<em>parameteric polymorphism</em> allows the same code to operate on
different types without relying on either subtype relationships or
dynamic binding. Languages that support parametric polymorphism do so
in different ways, and we will examine the different strategies here.</p>
<section id="implicit-parametric-polymorphism">
<h2>Implicit Parametric Polymorphism<a class="headerlink" href="#implicit-parametric-polymorphism" title="Link to this heading"></a></h2>
<p>Many functional languages in the ML family, including OCaml and
Haskell, are statically typed but allow the programmer to elide types
from a function. In such a case, the function is implicitly
polymorphic, and the compiler will infer the types for each use of the
function. For example, the following defines a polymorphic <code class="docutils literal notranslate"><span class="pre">max</span></code>
function in OCaml:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">then</span>
        <span class="n">x</span>
    <span class="k">else</span>
        <span class="n">y</span><span class="o">;;</span>
</pre></div>
</div>
<p>We can then call the function on two values of the same type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># max 3 4;;</span>
<span class="o">-</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># max 4.1 3.1;;</span>
<span class="o">-</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.1</span>
<span class="c1"># max &quot;Hello&quot; &quot;World&quot;;;</span>
<span class="o">-</span> <span class="p">:</span> <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span>
</pre></div>
</div>
</section>
<section id="explicit-parametric-polymorphism">
<h2>Explicit Parametric Polymorphism<a class="headerlink" href="#explicit-parametric-polymorphism" title="Link to this heading"></a></h2>
<p>In other languages, a function or type must be explicitly specified as
polymorphic. In C++, the <code class="docutils literal notranslate"><span class="pre">template</span></code> keyword introduces a polymorphic
entity, and the parameters are specified in angle brackets:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While the definition of a parametric function must be explicitly
denoted as such, in many languages the use of a parametric function
does not normally require an explicit instantiation. Instead, as in
implicit parametric polymorphism, the compiler uses type inference to
determine the appropriate instantiation. Thus, we can use <code class="docutils literal notranslate"><span class="pre">max()</span></code> as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns 4</span>
<span class="n">max</span><span class="p">(</span><span class="mf">4.1</span><span class="p">,</span><span class="w"> </span><span class="mf">3.1</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns 4.1</span>
<span class="n">max</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="c1">// returns &quot;World&quot;s</span>
</pre></div>
</div>
<p>In the last call, we made use of C++14 string literals to compare
<code class="docutils literal notranslate"><span class="pre">std::string</span></code> s rather than character arrays.</p>
<p>With a single template parameter, the compiler cannot infer the type
parameter on a call that uses arguments of different types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">4.1</span><span class="p">);</span><span class="w"> </span><span class="c1">// error</span>
</pre></div>
</div>
<p>Instead, we can explicitly instantiate <code class="docutils literal notranslate"><span class="pre">max()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">max</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">4.1</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK</span>
</pre></div>
</div>
<p>Alternatively, we can modify <code class="docutils literal notranslate"><span class="pre">max()</span></code> to have separate type
parameters for each function parameter. However, with C++11, we also
need to make use of <a class="reference internal" href="#type-deduction">type deduction</a> for the return type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As of C++14, the trailing return type can be elided, in which case the
return type is deduced from the return statement:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="non-type-parameters">
<h3>Non-Type Parameters<a class="headerlink" href="#non-type-parameters" title="Link to this heading"></a></h3>
<p>In some languages, a generic parameter need not be a type. In
particular, Ada allows generics to be parameterized by values of any
type. C++ is more restrictive, allowing a template parameter to be a
value of an integral type, enumeration type, lvalue-reference type,
pointer type, or pointer-to-member type. The template parameter must
be a compile-time constant. A specific example of this is
<code class="docutils literal notranslate"><span class="pre">std::array</span></code>, which is declared similar to the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">array</span><span class="p">;</span>
</pre></div>
</div>
<p>We can then use it as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.1</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Link to this heading"></a></h3>
<p>An entity that supports parametric polymorphism can work with
different types, but it is often the case that not every type is
suitable for use in that entity. In the case of the <code class="docutils literal notranslate"><span class="pre">max</span></code> functions
above, it does not make sense to call <code class="docutils literal notranslate"><span class="pre">max</span></code> on values of a type that
does not support the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> operator.</p>
<p>Depending on the language, the constraints on a polymorphic entity can
be implicit or explicit. In the case of implicit constraints, the
entity is instantiated for the given type argument, and then the
result is checked for correctness. As an example, if we attempt to
call <code class="docutils literal notranslate"><span class="pre">max()</span></code> on streams in C++, we get an error like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>foo.cpp:7:12: error: invalid operands to binary expression
      (&#39;const std::__1::basic_istream&lt;char&gt;&#39; and
      &#39;const std::__1::basic_istream&lt;char&gt;&#39;)
  return x &gt; y ? x : y;
         ~ ^ ~
foo.cpp:11:5: note: in instantiation of function template
      specialization &#39;max&lt;std::__1::basic_istream&lt;char&gt; &gt;&#39;
      requested here
  ::max(cin, cin);
    ^
</pre></div>
</div>
<p>We then get a lengthy list of all the generic overloads of the
operator <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> that could not be instantiated with a
<code class="docutils literal notranslate"><span class="pre">basic_istream&lt;char&gt;</span></code>. The inscrutability of error messages produced
by C++ compilers upon instantiation failure is an unavoidable
byproduct of deferring type checking until instantiation.</p>
<p>Other languages allow a generic entity to specify explicit constraints
on the arguments with which the entity can be instantiated. Java and
C#, in particular, support powerful systems of constraints that can
restrict a generic for use with derived classes of specific types. The
code for a generic entity can then be checked once, assuming that the
constraints are satisfied. Then upon instantiating a generic, the type
arguments need only be checked against the constraints, resulting in
much cleaner error messages than C++.</p>
<p>We will look at the Java system for generics in more detail shortly.</p>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h3>
<p>Languages and compilers also differ in the implementation of generics
at runtime. In languages with strong support for dynamic binding, a
common implementation strategy is to only produce a single copy of the
code for a generic entity, relying on operations that depend on the
type parameter to be dynamically bound to the appropriate
implementation. This is the strategy used by Java and ML.</p>
<p>An alternative implementation is to generate separate code for each
instantiation of a generic entity, as is done in C++. This approach is
more flexible, since it does not require there to be a single piece of
generated code that works for any set of type arguments. It is also
often more efficient, since it does not rely on dynamic binding. The
downside is that it results in larger executables, a problem that is
exacerbated by the fact that the compiler needs access to the full
source of a generic entity when it is being instantiated. This can
lead to multiple copies of the same instantiation being included in
the resulting executable.</p>
</section>
<section id="java-generics">
<h3>Java Generics<a class="headerlink" href="#java-generics" title="Link to this heading"></a></h3>
<p>We now examine Java’s support for generics in more detail, as there
are key differences between how Java and C++ implement generics.</p>
<p>In Java, the basic syntax for using a generic is similar to C++. For
example, the following uses the generic <code class="docutils literal notranslate"><span class="pre">ArrayList&lt;T&gt;</span></code> type:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">strings</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
<span class="n">strings</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">strings</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<p>Defining a generic type, in its most basic form, also has syntax that
is related to C++, except for the distinct lack of the <code class="docutils literal notranslate"><span class="pre">template</span></code>
keyword:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_in</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A generic function requires its type parameters to be specified prior
to the return type, as the return type may use the type parameter:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unfortunately, this code will fail to compile, since not all objects
support the <code class="docutils literal notranslate"><span class="pre">compareTo()</span></code> method. By default, Java only allows
methods defined on <code class="docutils literal notranslate"><span class="pre">Object</span></code> to be called from within a generic. The
<code class="docutils literal notranslate"><span class="pre">compareTo()</span></code> method is not defined in <code class="docutils literal notranslate"><span class="pre">Object</span></code> but is defined in
the following interface in the standard library:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Thus, we need to a mechanism for constraining the type parameter of
<code class="docutils literal notranslate"><span class="pre">max()</span></code> be a derived type of <code class="docutils literal notranslate"><span class="pre">Comparable&lt;T&gt;</span></code>, so that an object of
the type parameter can be compared to another object of the same type.
We can do this by adding <code class="docutils literal notranslate"><span class="pre">extends</span> <span class="pre">Comparable&lt;T&gt;</span></code> to the type
parameter when we introduce it:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can modify the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> class as follows to implement the
<code class="docutils literal notranslate"><span class="pre">Comparable&lt;Foo&lt;T&gt;&gt;</span></code> interface:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_in</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="na">x</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To compare a <code class="docutils literal notranslate"><span class="pre">Foo&lt;T&gt;</span></code> to another <code class="docutils literal notranslate"><span class="pre">Foo&lt;T&gt;</span></code>, we in turn compare
their respective <code class="docutils literal notranslate"><span class="pre">x</span></code> fields with another call to <code class="docutils literal notranslate"><span class="pre">compareTo()</span></code>.
Again, we run into the problem that the type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>, which is
the type of <code class="docutils literal notranslate"><span class="pre">x</span></code>, may not implement the <code class="docutils literal notranslate"><span class="pre">compareTo()</span></code> method. So we
have to specify the constraint here as well that <code class="docutils literal notranslate"><span class="pre">T</span></code> be derived from
<code class="docutils literal notranslate"><span class="pre">Comparable&lt;T&gt;</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_in</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="na">x</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now use <code class="docutils literal notranslate"><span class="pre">max()</span></code> with instantiations of <code class="docutils literal notranslate"><span class="pre">Foo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">);</span>
<span class="n">Foo</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;World&quot;</span><span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>     <span class="o">//</span> <span class="n">prints</span> <span class="n">World</span>
</pre></div>
</div>
<p>A final problem is that an instance of a class may be comparable to an
instance of a base class. Consider the following classes:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Rectangle</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Rectangle</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">side1</span><span class="p">,</span><span class="w"> </span><span class="n">side2</span><span class="p">;</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">Rectangle</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s1_in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s2_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">side1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1_in</span><span class="p">;</span>
<span class="w">    </span><span class="n">side2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2_in</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">side1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">side2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">Rectangle</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">area</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Square</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">Square</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">side</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">super</span><span class="p">(</span><span class="n">side</span><span class="p">,</span><span class="w"> </span><span class="n">side</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now try to use the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> generic type with <code class="docutils literal notranslate"><span class="pre">Square</span></code>, as in:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="w">  </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Square</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="w">  </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">f1</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">f2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unfortunately, we get errors like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="nb">type</span> <span class="n">argument</span> <span class="n">Square</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">within</span> <span class="n">bounds</span>
  <span class="n">of</span> <span class="nb">type</span><span class="o">-</span><span class="n">variable</span> <span class="n">T</span>
    <span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
        <span class="o">^</span>
  <span class="n">where</span> <span class="n">T</span> <span class="ow">is</span> <span class="n">a</span> <span class="nb">type</span><span class="o">-</span><span class="n">variable</span><span class="p">:</span>
    <span class="n">T</span> <span class="n">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">declared</span> <span class="ow">in</span> <span class="k">class</span> <span class="nc">Foo</span>
</pre></div>
</div>
<p>The problem is that <code class="docutils literal notranslate"><span class="pre">Square</span></code> derives from <code class="docutils literal notranslate"><span class="pre">Comparable&lt;Rectangle&gt;</span></code>,
not <code class="docutils literal notranslate"><span class="pre">Comparable&lt;Square&gt;</span></code> as required by the type parameter. However,
semantically it should not be a problem, since if a <code class="docutils literal notranslate"><span class="pre">Square</span></code> can be
compared to another <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code>, it can also be compared to another
<code class="docutils literal notranslate"><span class="pre">Square</span></code>. The solution is to modify the type constraint to allow a
type argument as long as it is comparable to some superclass of the
type:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">super</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">Comparable&lt;?</span> <span class="pre">super</span> <span class="pre">T&gt;</span></code> specifies that the type argument
of <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> can be any type, as long as it is a supertype of
<code class="docutils literal notranslate"><span class="pre">T</span></code>. Thus, <code class="docutils literal notranslate"><span class="pre">Square</span></code> satisfies the constraint, since it derives
from <code class="docutils literal notranslate"><span class="pre">Comparable&lt;Rectangle&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code> is a superclass of
<code class="docutils literal notranslate"><span class="pre">Square</span></code>.</p>
<p>Java implements generics using <em>type erasure</em>. Once a generic has been
checked, using any constraints it specifies, and once all uses have
been checked, the generic is replaced with a version that is no longer
parameterized, usually with the type parameters replaced by
<code class="docutils literal notranslate"><span class="pre">Object</span></code>. This prevents a generic from being used directly with
primitive types, since they do not derive from <code class="docutils literal notranslate"><span class="pre">Object</span></code>. However,
Java does allow primitives to be implicitly converted to
representations that derive from <code class="docutils literal notranslate"><span class="pre">Object</span></code>, at significant efficiency
costs.</p>
</section>
<section id="curiously-recurring-template-pattern">
<span id="crtp"></span><h3>Curiously Recurring Template Pattern<a class="headerlink" href="#curiously-recurring-template-pattern" title="Link to this heading"></a></h3>
<p>In Java, the pattern of a type <code class="docutils literal notranslate"><span class="pre">T</span></code> deriving from a generic
instantiated with <code class="docutils literal notranslate"><span class="pre">T</span></code> is quite common, as in the <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code> class
above. This pattern also exists in C++ templates, and it is known as
the <em>curiously recurring template pattern (CRTP)</em>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericBase</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GenericBase</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can use such a pattern to construct a mixin, as in Ruby’s
<code class="docutils literal notranslate"><span class="pre">Comparable</span></code> mentioned in <a class="reference internal" href="#types-of-inheritance">Types of Inheritance</a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Comparable</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> class template defines the comparison operators
in terms of a <code class="docutils literal notranslate"><span class="pre">compare()</span></code> method, which the derived class must
implement. We can thus implement a counter class that inherits
the comparison operators:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Counter</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">decrement</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">--</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">get_count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>While the code above works, a major drawback of the implementation is
that it requires dynamic binding, incurring the cost of a vtable
pointer in every <code class="docutils literal notranslate"><span class="pre">Counter</span></code> object as well as a vtable lookup for
each application of a comparison operator.</p>
<p>Surprisingly, we can actually eliminate dynamic binding by adding an
implicit constraint to the <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> class template: an instance
of <code class="docutils literal notranslate"><span class="pre">Comparable&lt;T&gt;</span></code> must also be an instance of <code class="docutils literal notranslate"><span class="pre">T</span></code>. For example, a
<code class="docutils literal notranslate"><span class="pre">Counter</span></code> object is an instance of <code class="docutils literal notranslate"><span class="pre">Comparable&lt;Counter&gt;</span></code>, but of
course it is also an instance of <code class="docutils literal notranslate"><span class="pre">Counter</span></code>. With this constraint, we
can perform an unchecked type cast of a <code class="docutils literal notranslate"><span class="pre">Comparable&lt;T&gt;</span> <span class="pre">*</span></code> down to
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Comparable</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">compare</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With the type cast, we no longer need to define <code class="docutils literal notranslate"><span class="pre">compare()</span></code> as a
pure virtual method in <code class="docutils literal notranslate"><span class="pre">Comparable</span></code>. It need only exist in <code class="docutils literal notranslate"><span class="pre">T</span></code>,
and it may be defined as a non-virtual function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Counter</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The end result is polymorphism without dynamic binding, and it is
known as <em>static polymorphism</em><a class="footnote-reference brackets" href="#id6" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> or <em>simulated dynamic binding</em>.
The pattern is widely used in Microsoft’s Active Template Library
(ATL) and Windows Template Library (WTL) for development on Windows.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">2</a><span class="fn-bracket">]</span></span>
<p>The term “static polymorphism” is also used to mean parametric
polymorphism, so the term “simulated dynamic binding” is
preferable.</p>
</aside>
</aside>
</section>
</section>
<section id="duck-typing">
<h2>Duck Typing<a class="headerlink" href="#duck-typing" title="Link to this heading"></a></h2>
<p>Languages that do not have static typing are often implicitly
polymorphic. Type information is not available at compile time, so a
function is usable with values of any type that supports the required
operations. This is called <em>duck typing</em>: it doesn’t matter what the
type of the value actually is; as long as it looks like a duck and
quacks like a duck, it is considered for all intents and purposes a
duck.</p>
<p>As an example, the following is a definition of <code class="docutils literal notranslate"><span class="pre">max()</span></code> in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>The function will work at runtime on any types that support the
special <code class="docutils literal notranslate"><span class="pre">__gt__</span></code> method, which is called by the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> comparison.</p>
<p>A downside of duck typing is that whether or not a type is considered
to support an operation is based solely on the name of the operation,
which may not have the same semantic meaning in different contexts.
For example, a <code class="docutils literal notranslate"><span class="pre">run()</span></code> method on an <code class="docutils literal notranslate"><span class="pre">Athlete</span></code> object may tell the
athlete to start running in a marathon, while a <code class="docutils literal notranslate"><span class="pre">run()</span></code> method on a
<code class="docutils literal notranslate"><span class="pre">Thread</span></code> object may tell it to start executing some code. This can
lead to unexpected behavior and confusing errors in duck-typed code
that calls <code class="docutils literal notranslate"><span class="pre">run()</span></code>.</p>
</section>
</section>
<section id="modules-and-namespaces">
<h1>Modules and Namespaces<a class="headerlink" href="#modules-and-namespaces" title="Link to this heading"></a></h1>
<p>An abstract data type (ADT) defines an abstraction for a single type.
Some abstractions, however, consist of not just a single type, but a
collection of interdependent types, variables, and other entities.
Such a collection of items is a <em>module</em>, and the modularization of a
system is a means of making its maintenance more manageable.</p>
<p>Many languages provide mechanisms for organizing items into modules.
In some languages, the mechanism is closely tied to that used for
separate compilation, such that each module is compiled independently
and later linked together with other modules. In other languages, the
mechanisms for modules and separate compilation are independent.</p>
<section id="translation-units">
<h2>Translation Units<a class="headerlink" href="#translation-units" title="Link to this heading"></a></h2>
<p>A <em>translation unit</em> or <em>compilation unit</em> is the unit of compilation
in languages that support separate compilation. Often, it consists of
a single source file. In languages such as C and C++ that enable other
files to be included with a preprocessor directive, a translation unit
consists of a source file and all the files that it recursively
includes.</p>
<p>In order to support separate compilation, a translation unit need only
know basic information about entities in other translation units. For
example, in C++, only declarations of external entities that are used
need be known <a class="footnote-reference brackets" href="#id8" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. For a variable, a declaration provides the name and
type, and for functions, the name, return type, and parameter type.
For classes, in order to be able to access members, the class
declaration with its member declarations needs to be available, though
actual definitions of member functions do not. Normally, this is
accomplished by writing declarations in a header file and then
including the header file in any translation unit that needs access to
those declarations. The definitions of variables, functions, and
member functions are written in a separate source file, which will
usually be compiled as its own translation unit.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">3</a><span class="fn-bracket">]</span></span>
<p>Templates are an exception, since their definitions need to be
instantiated upon use. Thus, the compiler must have the
definitions available for templates.</p>
</aside>
</aside>
<p>As an example, the following may be placed in the header file
<code class="docutils literal notranslate"><span class="pre">Triangle.hpp</span></code> to provide the declarations for a <code class="docutils literal notranslate"><span class="pre">Triangle</span></code> ADT:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Triangle</span><span class="p">();</span>
<span class="w">  </span><span class="n">Triangle</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">area</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">perimeter</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then the definitions would be placed in a <code class="docutils literal notranslate"><span class="pre">Triangle.cpp</span></code> file:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Triangle.hpp&quot;</span>

<span class="n">Triangle</span><span class="o">::</span><span class="n">Triangle</span><span class="p">()</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">Triangle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="n">Triangle</span><span class="o">::</span><span class="n">Triangle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a_in</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b_in</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">c_in</span><span class="p">)</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">a_in</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">b_in</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">c_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="kt">double</span><span class="w"> </span><span class="n">Triangle</span><span class="o">::</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span><span class="w"> </span><span class="n">Triangle</span><span class="o">::</span><span class="n">perimeter</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Triangle</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive pulls the code from <code class="docutils literal notranslate"><span class="pre">Triangle.hpp</span></code> into
<code class="docutils literal notranslate"><span class="pre">Triangle.cpp</span></code>, making the <code class="docutils literal notranslate"><span class="pre">Triangle</span></code> declarations available to
the latter.</p>
<p>In other languages, including Java and C#, there is no notion of a
separate header file, and all declarations must also be definitions.
Instead, the compiler automatically extracts the declaration
information from a source file when needed by other translation units.</p>
</section>
<section id="modules-packages-and-namespaces">
<h2>Modules, Packages, and Namespaces<a class="headerlink" href="#modules-packages-and-namespaces" title="Link to this heading"></a></h2>
<p>Languages also specify units of organization for names in a program.
This allows the same name to be used in different units without
resulting in a conflict. In many cases, the unit of organization is at
the granularity of a source file, while in other languages, an
organizational unit can span multiple source files.</p>
<p>In Python, the first unit of organization is a source file, which is
called a <em>module</em> in Python terminology. A module is associated with a
scope in which the names defined in the module reside. In order to use
names from another module, the external module, or names from within
it, must be explicitly imported into the current scope. The <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement does so, and it can be located at any scope. Consider the
following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">quadratic_formula</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">disc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">disc</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Usage: </span><span class="si">{0}</span><span class="s1"> a b c&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">quadratic_formula</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>In the code above, the import statement in the first line directly
imports the <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> name from the <code class="docutils literal notranslate"><span class="pre">math</span></code> module into the scope of
the current module. It does not, however, import the <code class="docutils literal notranslate"><span class="pre">math</span></code> name
itself. In the first line of <code class="docutils literal notranslate"><span class="pre">main()</span></code>, the name of the <code class="docutils literal notranslate"><span class="pre">sys</span></code>
module is imported into the local scope of <code class="docutils literal notranslate"><span class="pre">main()</span></code>. The standard
dot syntax can be used to refer to a name nested inside of <code class="docutils literal notranslate"><span class="pre">sys</span></code>.</p>
<p>Python also allows a second level of organization in the form of a
<em>package</em>, which is a collection of modules. For example, if the code
above were in a module named <code class="docutils literal notranslate"><span class="pre">quadratic</span></code>, we might want to organize
it with other mathematical formulas in a package named <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.
Defining a file <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> within a directory enables the modules
in that directory to constitute a package, with the directory name as
the name of the package. Packages can then further have subpackages in
the form of subdirectories with their own <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files.</p>
<p>The following is an example of how a <a class="reference external" href="https://docs.python.org/3/tutorial/modules.html">sound module can be organized in
Python</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sound</span><span class="o">/</span>                          <span class="n">Top</span><span class="o">-</span><span class="n">level</span> <span class="n">package</span>
      <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>               <span class="n">Initialize</span> <span class="n">the</span> <span class="n">sound</span> <span class="n">package</span>
      <span class="n">formats</span><span class="o">/</span>                  <span class="n">Subpackage</span> <span class="k">for</span> <span class="n">file</span> <span class="nb">format</span> <span class="n">conversions</span>
              <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
              <span class="n">wavread</span><span class="o">.</span><span class="n">py</span>
              <span class="n">wavwrite</span><span class="o">.</span><span class="n">py</span>
              <span class="n">aiffread</span><span class="o">.</span><span class="n">py</span>
              <span class="n">aiffwrite</span><span class="o">.</span><span class="n">py</span>
              <span class="n">auread</span><span class="o">.</span><span class="n">py</span>
              <span class="n">auwrite</span><span class="o">.</span><span class="n">py</span>
              <span class="o">...</span>
      <span class="n">effects</span><span class="o">/</span>                  <span class="n">Subpackage</span> <span class="k">for</span> <span class="n">sound</span> <span class="n">effects</span>
              <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
              <span class="n">echo</span><span class="o">.</span><span class="n">py</span>
              <span class="n">surround</span><span class="o">.</span><span class="n">py</span>
              <span class="n">reverse</span><span class="o">.</span><span class="n">py</span>
              <span class="o">...</span>
      <span class="n">filters</span><span class="o">/</span>                  <span class="n">Subpackage</span> <span class="k">for</span> <span class="n">filters</span>
              <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
              <span class="n">equalizer</span><span class="o">.</span><span class="n">py</span>
              <span class="n">vocoder</span><span class="o">.</span><span class="n">py</span>
              <span class="n">karaoke</span><span class="o">.</span><span class="n">py</span>
              <span class="o">...</span>
</pre></div>
</div>
<p>Java follows a similar organizational scheme as Python. The first unit
of organization is a class, since all code in Java must be contained
within a class. Multiple classes may be contained within the same
translation unit, but a translation unit does not constitute a scope
on its own. (If a class is to be used outside a translation unit,
however, it should be located in its own file in order to make it
possible for the compiler to find its source when it is used.) A
source file may include a <code class="docutils literal notranslate"><span class="pre">package</span></code> directive in order to place its
code within the context of the specified package:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nn">formulas</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Quadratic</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Packages can be nested, as in Python.</p>
<p>Also like Python, Java has import statements in order to import names
into the local scope. Unlike Python, however, an unimported name can
be used by giving it full <em>qualification</em>, including the sequence of
packages that it is a part of:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">Vector</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">Vector</span><span class="p">();</span>
</pre></div>
</div>
<p>Import statements in Java must appear at the top of a file, after any
<code class="docutils literal notranslate"><span class="pre">package</span></code> declaration but before any class definition. A single
member can be imported from a package, or all of the package’s
contents can be imported:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Vector</span><span class="p">;</span><span class="w"> </span><span class="c1">// import just one member</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.*</span><span class="p">;</span><span class="w">      </span><span class="c1">// import all members</span>
</pre></div>
</div>
<p>Java also allows static methods and constants to be imported from a
class with the static import statement:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import static</span><span class="w"> </span><span class="nn">java.lang.System.out</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ has the concept of <em>namespaces</em> rather than modules or packages. A
namespace defines a scope in which names reside, and an entity can be
defined within a namespace as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">};</span>

<span class="p">}</span>
</pre></div>
</div>
<p>As demonstrated above, multiple entities can be defined within a
single <code class="docutils literal notranslate"><span class="pre">namespace</span></code> block, and multiple <code class="docutils literal notranslate"><span class="pre">namespace</span></code> blocks can
define entities for the same namespace. Namespaces can also be nested.</p>
<p>In order to access a namespace member from an external context, the
scope-resolution operator is required:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">::</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">A</span><span class="p">;</span>
</pre></div>
</div>
<p>C++ allows individual names to be imported from a namespace into the
current scope with a <code class="docutils literal notranslate"><span class="pre">using</span></code> declaration:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">A</span><span class="p">;</span>
</pre></div>
</div>
<p>Alternatively, all of the names declared within a namespace may be
imported as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>This latter form should be used with caution, as it significantly
increases the likelihood of inadvertent name clashes.</p>
<p>An entity defined outside of a namespace is actually within the global
namespace, and it can be referred to with the scope-resolution
operator by including nothing on the left-hand side:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">baz</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">::</span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Java similarly places code that is lacking a <code class="docutils literal notranslate"><span class="pre">package</span></code> specifier
into the anonymous package.</p>
<p>C# combines the concept of Python’s modules, which it calls
<em>assemblies</em>, with namespaces as in C++.</p>
</section>
<section id="linkage">
<h2>Linkage<a class="headerlink" href="#linkage" title="Link to this heading"></a></h2>
<p>C does not have namespaces, so it uses an alternate mechanism to
avoid name conflicts between translation units. (C++ also includes
this, since it is mostly backwards compatible with C.) A programmer
can specify a <em>linkage</em> for a function or variable, which determines
whether or not the item is visible outside of the translation unit.
The keyword <code class="docutils literal notranslate"><span class="pre">static</span></code>, when used on a function or variable at global
scope, specifies that the given item has <em>internal linkage</em>, meaning
that it is not available outside of the translation unit. This is
crucial when the same name may be defined within different translation
units, as it avoids a conflict at the link stage. In particular,
global variables and functions that are not just declared but also
defined in a header file should almost always be given internal
linkage, since a header file is likely to be included from multiple
translation units.</p>
<p>A global function or non-const variable has <em>external linkage</em> if
it is missing the <code class="docutils literal notranslate"><span class="pre">static</span></code> specifier. This means that the name will
be accessible from other translation units. A variable or function
with external linkage must have exactly one definition between the
translation units in a program. Otherwise, a conflict arises between
the multiple definitions, and a linker error will result. For a
function, the distinction between a simple declaration and a
definition is clear, since the latter provides a function body. For a
variable, however, a declaration is generally also a definition, since
a missing initializer implies default initialization. The programmer
must explicitly state that a declaration of a global variable is not a
definition using the <code class="docutils literal notranslate"><span class="pre">extern</span></code> specifier:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="c1">// just a declaration</span>
<span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">        </span><span class="c1">// also a definition</span>
</pre></div>
</div>
<p>A const global variable has internal linkage by default, and the
<code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword must be present to give it external linkage
instead. An initialization can be provided, making a declaration of
such a variable also a definition:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w">      </span><span class="c1">// just a declaration</span>
<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// also a definition</span>
</pre></div>
</div>
</section>
<section id="information-hiding">
<h2>Information Hiding<a class="headerlink" href="#information-hiding" title="Link to this heading"></a></h2>
<p>Many languages provide a mechanism for information hiding at the
granularity of modules or packages. In Java, for example, a class that
is declared without the <code class="docutils literal notranslate"><span class="pre">public</span></code> keyword is only available to other
classes within the same package. In C and C++, the standard method of
information hiding is to avoid declaring internal entities in a header
file, but to declare them within a <code class="docutils literal notranslate"><span class="pre">.c</span></code> or <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, and in the
case of variables and functions, declare them with internal linkage.</p>
<p>As mentioned above, in order to use the members of a class in C++, the
class definition itself must be available in the current translation
unit. However, access to internal members of a class can be restricted
using the <code class="docutils literal notranslate"><span class="pre">private</span></code> or <code class="docutils literal notranslate"><span class="pre">protected</span></code> specifiers.</p>
<p>C, on the other hand, does not provide a means of declaring struct
members private. However, there is a common pattern of preventing
direct access to struct members by providing only the declaration of a
struct, without its definition, in the header file. As an example, the
following defines the interface for a stack ADT:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">list</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">;</span>
<span class="n">stack</span><span class="w"> </span><span class="nf">stack_make</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">stack_push</span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">stack_top</span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">stack_pop</span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">stack_free</span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, no definition of the <code class="docutils literal notranslate"><span class="pre">list</span></code> struct is provided, making it an
<em>opaque type</em>. This prevents another translation unit from creating a
<code class="docutils literal notranslate"><span class="pre">list</span></code> object, since it can’t event tell what the size of the object
will be, or accessing its members directly. We can then write the
definitions for the stack ADT in its own <code class="docutils literal notranslate"><span class="pre">.c</span></code> file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">datum</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">list</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">node</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">stack</span><span class="w"> </span><span class="nf">stack_make</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">list</span><span class="p">));</span>
<span class="w">  </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">stack_push</span><span class="p">(</span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">node</span><span class="w"> </span><span class="o">*</span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="w">  </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">datum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="w">  </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>
</pre></div>
</div>
<p>Another <code class="docutils literal notranslate"><span class="pre">.c</span></code> file can then make use of the stack, without being able
to directly access internal details, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stack.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">stack</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack_make</span><span class="p">();</span>
<span class="w">  </span><span class="n">stack_push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">stack_push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stack_top</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="w">  </span><span class="n">stack_pop</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stack_top</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="w">  </span><span class="n">stack_free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Link to this heading"></a></h2>
<p>In a program with code organized among different modules or
translation units, an important consideration is when the code that
initializes a module is executed. Interdependencies between modules
can lead to bugs due to the semantics of initialization, and there are
cases where the only solution is to reorganize the structure of a
program.</p>
<p>In Python, the code in a module is executed when it is first imported.
Once a module has been imported, any subsequent imports of the module
will not cause its code to be re-executed. However, it is possible to
construct circular dependencies between modules that result in errors
or unexpected behavior. Consider the following, located in module
<code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bar</span>

<span class="k">def</span> <span class="nf">func1</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">bar</span><span class="o">.</span><span class="n">func3</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">func2</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func1</span><span class="p">())</span>
</pre></div>
</div>
<p>Assume that the following is located in module <code class="docutils literal notranslate"><span class="pre">bar</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>

<span class="k">def</span> <span class="nf">func3</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">func2</span><span class="p">()</span>
</pre></div>
</div>
<p>If we then run module <code class="docutils literal notranslate"><span class="pre">foo</span></code> from the command line, the <code class="docutils literal notranslate"><span class="pre">import</span></code>
statement will cause the code in <code class="docutils literal notranslate"><span class="pre">bar</span></code> to be executed. The code in
<code class="docutils literal notranslate"><span class="pre">bar</span></code> has as its first statement an import of <code class="docutils literal notranslate"><span class="pre">foo</span></code>. This is the
first import of <code class="docutils literal notranslate"><span class="pre">foo</span></code> from <code class="docutils literal notranslate"><span class="pre">bar</span></code>, so the code for <code class="docutils literal notranslate"><span class="pre">foo</span></code> will
execute. It starts with <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">bar</span></code>; however, this is now the
second import of <code class="docutils literal notranslate"><span class="pre">bar</span></code> into <code class="docutils literal notranslate"><span class="pre">foo</span></code>, so it will not have any effect.
Then when <code class="docutils literal notranslate"><span class="pre">func1()</span></code> is called, the definition for <code class="docutils literal notranslate"><span class="pre">func3()</span></code> in
<code class="docutils literal notranslate"><span class="pre">bar</span></code> has not yet been executed, so we will get an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;foo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="kn">import</span> <span class="nn">bar</span>
  <span class="n">File</span> <span class="s2">&quot;bar.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="kn">import</span> <span class="nn">foo</span>
  <span class="n">File</span> <span class="s2">&quot;foo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">9</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">func1</span><span class="p">())</span>
  <span class="n">File</span> <span class="s2">&quot;foo.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">func1</span>
    <span class="k">return</span> <span class="n">bar</span><span class="o">.</span><span class="n">func3</span><span class="p">()</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="n">module</span> <span class="s1">&#39;bar&#39;</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;func3&#39;</span>
</pre></div>
</div>
<p>One way to fix this is to delay the import of <code class="docutils literal notranslate"><span class="pre">foo</span></code> into <code class="docutils literal notranslate"><span class="pre">bar</span></code>
until <code class="docutils literal notranslate"><span class="pre">func3()</span></code> is called:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func3</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">foo</span>
    <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">func2</span><span class="p">()</span>
</pre></div>
</div>
<p>However, this still causes the code in <code class="docutils literal notranslate"><span class="pre">foo</span></code> to execute twice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python3 foo.py
2
2
</pre></div>
</div>
<p>A better solution is to move <code class="docutils literal notranslate"><span class="pre">func2()</span></code> from <code class="docutils literal notranslate"><span class="pre">foo</span></code> into its own
module, and then to import that module from both <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
<p>In Java, the static initialization of a class occurs when it is first
used, which includes creating an instance of the class or accessing a
static member. Thus, the order of initialization depends on the
dynamic execution of a program, and a programmer generally should not
rely on a specific order of initialization between different classes.</p>
<p>In C++, initialization follows a multi-step process. First is what C++
calls <em>static initialization</em>, which initializes compile-time
constants to their respective values and other variables with static
storage duration to zero. Then is <em>dynamic initialization</em>, which runs
the specified initialization for static-duration variables. In
general, variables are initialized in program order within a
translation unit, with some exceptions. However, the order of
initialization between translation units is unspecified, and in fact
may be delayed until the first time a translation unit is used. The
end result is that a programmer should avoid any assumption that any
other translation unit has been initialized when writing
initialization code for a given translation unit.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="theory.html" class="btn btn-neutral float-left" title="Lambda Calculus" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="declarative.html" class="btn btn-neutral float-right" title="Logic Programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Amir Kamil, licensed under the Creative Commons Attribution-ShareAlike 4.0 International license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org/">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>

<!-- Mirrored from eecs390.github.io/notes/data.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:47 GMT -->
</html>