<!DOCTYPE html>
<html class="writer-html5" lang="en" >

<!-- Mirrored from eecs390.github.io/notes/metaprogramming.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Macros and Code Generation &mdash; Programming Language Principles and Paradigms 0.4 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/style-extra.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/general.css" type="text/css" />
      <link rel="stylesheet" href="_static/dark_mode_css/dark.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery3b25.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compatfa9a.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options804b.js?v=7f00635f"></script>
        <script src="_static/doctools56c1.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight7f57.js?v=dc90522c"></script>
        <script src="_static/js-extraf31b.js?v=c32e72a1"></script>
        <script async="async" src="../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-mml-chtml.js"></script>
        <script src="_static/dark_mode_js/default_light679c.js?v=c2e647ce"></script>
        <script src="_static/dark_mode_js/theme_switcher2b7c.js?v=358d3910"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parallel Computing" href="concurrent.html" />
    <link rel="prev" title="Logic Programming" href="declarative.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #C53390" >

          
          
          <a href="index-2.html" class="icon icon-home">
            Programming Language Principles and Paradigms
          </a>
              <div class="version">
                0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://eecs390.github.io/notes/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Foundations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="foundations.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-python">Basic Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#basic-data-structures">Basic Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#compound-statements">Compound Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#function-definitions">Function Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#class-definitions">Class Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#modules">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#executing-a-module">Executing a Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#python-reference-semantics">Python Reference Semantics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#basic-elements">Basic Elements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#levels-of-description">Levels of Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#lexical-structure">Lexical Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#semantics">Semantics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#entities-objects-and-variables">Entities, Objects, and Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#l-values-and-r-values">L-Values and R-Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statements">Statements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#names-and-environments">Names and Environments</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#blocks">Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#name-lookup">Name Lookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#nested-inline-blocks">Nested Inline Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#scope-in-functions">Scope in Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#id2">Static Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#dynamic-scope">Dynamic Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#point-of-declaration-or-definition">Point of Declaration or Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#control-flow">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#expression-sequencing">Expression Sequencing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#short-circuiting">Short Circuiting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#explicit-sequences">Explicit Sequences</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#compound-assignment">Compound Assignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#statement-sequences">Statement Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#unstructured-transfer-of-control">Unstructured Transfer of Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#structured-control">Structured Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loops">Loops</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#loop-termination">Loop Termination</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#memory-management">Memory Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#storage-duration-classes">Storage Duration Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#static-storage">Static Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#automatic-storage">Automatic Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#thread-local-storage">Thread-Local Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#dynamic-storage">Dynamic Storage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#value-and-reference-semantics">Value and Reference Semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#raii-and-scope-based-resource-management">RAII and Scope-Based Resource Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#garbage-collection">Garbage Collection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#reference-counting">Reference Counting</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#tracing-collectors">Tracing Collectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#finalizers">Finalizers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="foundations.html#grammars">Grammars</a><ul>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#context-free-grammars">Context-Free Grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="foundations.html#grammars-in-programming-languages">Grammars in Programming Languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="foundations.html#vexing-parse">Vexing Parse</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functional Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="functional.html">Introduction to Scheme</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#expressions">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#compound-values">Compound Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#symbolic-data">Symbolic Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#functions">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#default-arguments">Default Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#variadic-functions">Variadic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#parameter-passing">Parameter Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#evaluation-of-function-calls">Evaluation of Function Calls</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#recursion">Recursion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#activation-records">Activation Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#tail-recursion">Tail Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#higher-order-functions">Higher-Order Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#function-objects">Function Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#functions-as-parameters">Functions as Parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#function-pointers">Function Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#binding-policy">Binding Policy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#nested-functions">Nested Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#decorators">Decorators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#lambda-functions">Lambda Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#scheme">Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#python">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#java">Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#common-patterns">Common Patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#sequence-patterns">Sequence Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="functional.html#map">Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#reduce">Reduce</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#filter">Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="functional.html#any">Any</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#composition">Composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#partial-application-and-currying">Partial Application and Currying</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functional.html#continuations">Continuations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functional.html#restricted-continuations">Restricted Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#subroutines">Subroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#exceptions">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#generators">Generators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functional.html#first-class-continuations">First-Class Continuations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="functional.html#signaling-errors">Signaling Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#call-and-return">Call and Return</a></li>
<li class="toctree-l3"><a class="reference internal" href="functional.html#id11">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Lambda Calculus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#non-terminating-computation">Non-Terminating Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#normal-order-evaluation">Normal-Order Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#encoding-data">Encoding Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#booleans">Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#pairs">Pairs</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#church-numerals">Church Numerals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#equivalent-models">Equivalent Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#operational-semantics">Operational Semantics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#language">Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#states-and-transitions">States and Transitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#arithmetic-expressions">Arithmetic Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#order-of-evaluation">Order of Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#boolean-expressions">Boolean Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#statements">Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#operational-semantics-for-lambda-calculus">Operational Semantics for Lambda Calculus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theory.html#formal-type-systems">Formal Type Systems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="theory.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#subtyping">Subtyping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-arithmetic-operators">Subtyping and Arithmetic Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#the-top-type">The Top Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="theory.html#subtyping-and-functions">Subtyping and Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="theory.html#full-typing-rules">Full Typing Rules</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Abstraction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="data.html">Functional Data Abstraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#pairs-and-lists">Pairs and Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#lists">Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#dictionaries">Dictionaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#dispatch-dictionaries">Dispatch Dictionaries</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#object-oriented-programming">Object-Oriented Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#members">Members</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#access-control">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#kinds-of-methods">Kinds of Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#nested-and-local-classes">Nested and Local Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#implementation-strategies">Implementation Strategies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#inheritance-and-polymorphism">Inheritance and Polymorphism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#types-of-inheritance">Types of Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#class-hierarchies">Class Hierarchies</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#method-overriding">Method Overriding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#covariance-and-contravariance">Covariance and Contravariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#accessing-hidden-or-overridden-members">Accessing Hidden or Overridden Members</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#implementing-dynamic-binding">Implementing Dynamic Binding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#full-lookup-and-dispatch-process">Full Lookup and Dispatch Process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#multiple-inheritance">Multiple Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#dictionary-based-implementation">Dictionary-Based Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#record-based-implementation">Record-Based Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#static-analysis">Static Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-equivalence">Type Equivalence</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-compatibility">Type Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#type-inference">Type Inference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#control-flow-analysis">Control-Flow Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#dynamic-typing">Dynamic Typing</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html#generics">Generics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#implicit-parametric-polymorphism">Implicit Parametric Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#explicit-parametric-polymorphism">Explicit Parametric Polymorphism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data.html#non-type-parameters">Non-Type Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#constraints">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#java-generics">Java Generics</a></li>
<li class="toctree-l3"><a class="reference internal" href="data.html#curiously-recurring-template-pattern">Curiously Recurring Template Pattern</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="data.html#duck-typing">Duck Typing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data.html#modules-and-namespaces">Modules and Namespaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data.html#translation-units">Translation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#modules-packages-and-namespaces">Modules, Packages, and Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#linkage">Linkage</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#information-hiding">Information Hiding</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html#initialization">Initialization</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Declarative Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="declarative.html">Logic Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#prolog">Prolog</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#lists">Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#arithmetic">Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#side-effects">Side Effects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#unification-and-search">Unification and Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#search-order-and-backtracking">Search Order and Backtracking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#the-cut-operator">The Cut Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#negation">Negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarative.html#constraints-and-dependencies">Constraints and Dependencies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#constraint-logic-programming">Constraint Logic Programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#search">Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarative.html#id2">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarative.html#make">Make</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarative.html#pattern-matching">Pattern Matching</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Metaprogramming</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Macros and Code Generation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scheme-macros">Scheme Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cpp-macros">CPP Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stringification-and-concatenation">Stringification and Concatenation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-macro-namespace">The Macro Namespace</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#code-generation">Code Generation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#template-metaprogramming">Template Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pairs">Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerical-computations">Numerical Computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#templates-and-function-overloading">Templates and Function Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sfinae">SFINAE</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ensuring-a-substitution-failure">Ensuring a Substitution Failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variadic-templates">Variadic Templates</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#example-multidimensional-arrays">Example: Multidimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#points">Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="#domains">Domains</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stencil">Stencil</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nested-iteration">Nested Iteration</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Concurrent Programming</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#parallelism-in-python">Parallelism in Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#threading">Threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#multiprocessing">Multiprocessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#the-problem-with-shared-state">The Problem with Shared State</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#when-no-synchronization-is-necessary">When No Synchronization is Necessary</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronized-data-structures">Synchronized Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#locks">Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#barriers">Barriers</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#message-passing">Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#application-examples">Application Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#web-crawler">Web Crawler</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#particle-simulator">Particle Simulator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#synchronization-pitfalls">Synchronization Pitfalls</a><ul>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#under-synchronization">Under-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#over-synchronization">Over-synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="concurrent.html#deadlock">Deadlock</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="concurrent.html#asynchronous-tasks">Asynchronous Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#limiting-the-number-of-tasks">Limiting the Number of Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="concurrent.html#launch-policy">Launch Policy</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #C53390" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index-2.html">Programming Language Principles and Paradigms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index-2.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Macros and Code Generation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="declarative.html" class="btn btn-neutral float-left" title="Logic Programming" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="concurrent.html" class="btn btn-neutral float-right" title="Parallel Computing" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Metaprogramming</h1><p><em>Metaprogramming</em> is the technique of writing a computer program that
operates on other programs. Systems such as compilers and program
analyzers can be considered metaprograms, since they take other
programs as input. The forms of metaprogramming we will discuss here
are specifically concerned with generating code to be included as part
of a program. In a sense, they can be considered rudimentary
compilers.</p>
<section id="macros-and-code-generation">
<h1>Macros and Code Generation<a class="headerlink" href="#macros-and-code-generation" title="Link to this heading"></a></h1>
<p>A <em>macro</em> is a rule that translates an input sequence into some
replacement output sequence. This translation process is called <em>macro
expansion</em>, and some languages provide macros as part of their
specification. The macro facility may be implemented as a
<em>preprocessing</em> step, where macro expansion occurs before lexical and
syntactic analysis, or it may be incorporated as part of syntax
analysis or a later translation step.</p>
<p>One of the most widely used macro systems is the C preprocessor (CPP),
which is included in both C and C++ as the first step in processing
a program. Preprocessor <em>directives</em> begin with a hash symbol and
include <code class="docutils literal notranslate"><span class="pre">#include</span></code>, <code class="docutils literal notranslate"><span class="pre">#define</span></code>, <code class="docutils literal notranslate"><span class="pre">#if</span></code>, among others. For instance,
the following defines a <em>function-like</em> macro to swap two items:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SWAP(a, b) { auto tmp = b; b = a; a = tmp; }</span>
</pre></div>
</div>
<p>We can then use the macro as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="n">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running the resulting executable will print a 4, followed by a 3.</p>
<p>The results of macro expansion can be obtained by passing the <code class="docutils literal notranslate"><span class="pre">-E</span></code>
flag to <code class="docutils literal notranslate"><span class="pre">g++</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ -E &lt;source&gt;
</pre></div>
</div>
<p>However, the results can be quite messy if there are <code class="docutils literal notranslate"><span class="pre">#include</span></code>s,
since that directive pulls in the code from the given file.</p>
<p>CPP macros perform text replacement, so that the code above is
equivalent to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The semicolon following the use of the <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> macro remains,
denoting an empty statement. This is a problem, however, in contexts
that require a single statement, such as a conditional branch that is
not enclosed by a block:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="n">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;no swap&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A common idiom to avoid this problem is to place the expansion code
for the macro inside of a do/while:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SWAP(a, b) do {                         \</span>
<span class="cp">    auto tmp = b;                               \</span>
<span class="cp">    b = a;                                      \</span>
<span class="cp">    a = tmp;                                    \</span>
<span class="cp">  } while (false)</span>
</pre></div>
</div>
<p>Here, we’ve placed a backslash at the end of a line to denote that the
next line should be considered a continuation of the previous one. A
do/while loop syntactically ends with a semicolon, so that the
semicolon in <code class="docutils literal notranslate"><span class="pre">SWAP(x,</span> <span class="pre">y);</span></code> is syntactically part of the do/while
loop. Thus, the expanded code has the correct syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;no swap&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>While textual replacement is useful, it does have drawbacks, stemming
from the fact that though the macros are syntactically function like,
they do not behave as functions. Specifically, they do not treat
arguments as their own entities, and they do not introduce a separate
scope. Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">SWAP</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running the resulting program produces the unexpected result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">g++</span> <span class="pre">-E</span></code>, we can see what the preprocessed code looks like.
Looking only at the output for <code class="docutils literal notranslate"><span class="pre">main()</span></code>, we find:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we’ve manually added line breaks and whitespace to make the
output more readable; the preprocessor itself places the macro output
on a single line. The culprit is the last generated statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x &lt; y ? x : y = tmp;
</pre></div>
</div>
<p>In C++, the conditional operator <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code> and the assignment operator
<code class="docutils literal notranslate"><span class="pre">=</span></code> have the same precedence and associate right to left, so this is
equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x &lt; y ? x : (y = tmp);
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>, no assignment happens here. Thus, the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>
is unchanged.</p>
<p>We can fix this problem by placing parentheses around each use of a
macro argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define SWAP(a, b) do {                         \</span>
<span class="cp">    auto tmp = (b);                             \</span>
<span class="cp">    (b) = (a);                                  \</span>
<span class="cp">    (a) = tmp;                                  \</span>
<span class="cp">  } while (false)</span>
</pre></div>
</div>
<p>This now produces the expected result, as the operations are
explicitly associated by the parentheses:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A second problem, however, is not as immediately fixable. Consider
what happens when we apply the <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> macro to a variable named
<code class="docutils literal notranslate"><span class="pre">tmp</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="n">SWAP</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running this code results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span> <span class="mi">4</span>
</pre></div>
</div>
<p>No swap occurs! Again, using <code class="docutils literal notranslate"><span class="pre">g++</span> <span class="pre">-E</span></code> to examine the output, we see
(modulo spacing):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the temporary variable used by <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> has the same name as an
argument, the temporary <em>captures</em> the occurrences of the argument in
the generated code. This is because the macro merely performs text
substitution, which does not ensure that names get resolved to the
appropriate scope. (Thus, macros do not actually use call by name,
which does ensure that a name in an argument resolves to the
appropriate scope.) The reliance on text replacement makes CPP a
<em>non-hygienic</em> macro system. Other systems, such as Scheme’s, are
hygienic, creating a separate scope for names introduced by a macro
and ensuring that arguments are not captured.</p>
<section id="scheme-macros">
<span id="id1"></span><h2>Scheme Macros<a class="headerlink" href="#scheme-macros" title="Link to this heading"></a></h2>
<p>The macro system defined as part of the R5RS Scheme specification is
hygienic. A macro is introduced by one of the <code class="docutils literal notranslate"><span class="pre">define-syntax</span></code>,
<code class="docutils literal notranslate"><span class="pre">let-syntax</span></code>, or <code class="docutils literal notranslate"><span class="pre">letrec-syntax</span></code> forms, and it binds the given
name to the macro. As an example, the following is a definition of
<code class="docutils literal notranslate"><span class="pre">let</span></code> as a macro:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax</span><span class="w"> </span><span class="k">let</span>
<span class="w">  </span><span class="p">(</span><span class="k">syntax-rules</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">((</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">name</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">       </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">     </span><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">      </span><span class="p">)</span>
<span class="w">      </span><span class="nv">val</span><span class="w"> </span><span class="o">...</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">syntax-rules</span></code> from specifies the rules for the macro
transformation. The first argument is a list of literals that must
match between the pattern of the rule and the input. An example is the
<code class="docutils literal notranslate"><span class="pre">else</span></code> identifier inside of a <code class="docutils literal notranslate"><span class="pre">cond</span></code> form. In this case, however,
there are no literals. The remaining arguments to <code class="docutils literal notranslate"><span class="pre">syntax-rules</span></code>
specify transformations. The first item in a transformation is the
input pattern, and the second is the output pattern. The <code class="docutils literal notranslate"><span class="pre">...</span></code> acts
like a Kleene star, matching the previous item to zero or more
occurrences in the input. The names that appear in an input pattern
but are not in the list of literals, excepting the first item that is
the macro name, are hygienic variables that match input elements. The
variables can then be referenced in the output pattern to specify how
to construct the output.</p>
<p>Evaluating the expression above in the global environment binds the
name <code class="docutils literal notranslate"><span class="pre">let</span></code> to a macro that translates to a <code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
<p>Identifiers introduced by the body of a macro are guaranteed to avoid
conflict with other identifiers, and the interpreter often renames
identifiers to avoid such a conflict. Consider the following
definition of a <code class="docutils literal notranslate"><span class="pre">swap</span></code> macro:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax</span><span class="w"> </span><span class="nv">swap</span>
<span class="w">  </span><span class="p">(</span><span class="k">syntax-rules</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">((</span><span class="nf">swap</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">tmp</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">set!</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">tmp</span><span class="p">)</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This translates a use of <code class="docutils literal notranslate"><span class="pre">swap</span></code> to an expression that swaps the
two arguments through a temporary variable <code class="docutils literal notranslate"><span class="pre">tmp</span></code>. Thus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="p">(</span><span class="n">define</span> <span class="n">x</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="n">define</span> <span class="n">y</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="n">swap</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">4</span>
<span class="o">&gt;</span> <span class="n">y</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>However, unlike CPP macros, the <code class="docutils literal notranslate"><span class="pre">tmp</span></code> introduced by the <code class="docutils literal notranslate"><span class="pre">swap</span></code>
macro is distinct from any other <code class="docutils literal notranslate"><span class="pre">tmp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="p">(</span><span class="n">define</span> <span class="n">tmp</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="n">swap</span> <span class="n">x</span> <span class="n">tmp</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">5</span>
<span class="o">&gt;</span> <span class="n">tmp</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>Because macros are hygienic in Scheme, we get the expected behavior.</p>
<p>In order to support macros, the evaluation procedure of the Scheme
interpreter evaluates the first item in a list, as usual. If it
evaluates to a macro, then the interpreter performs macro expansion on
the rest of the list without first evaluating the arguments. Any names
introduced by the expansion are placed in a separate scope from other
names. After expansion, the interpreter repeats the evaluation process
on the result of expansion, so that if the end result is a <code class="docutils literal notranslate"><span class="pre">let</span></code>
expression as in <code class="docutils literal notranslate"><span class="pre">swap</span></code> above, the expression is evaluated.</p>
<p>A macro definition can specify multiple pattern rules. Combined with
the fact that the result of expansion is evaluated, this allows a
macro to be recursive, as in the following definition of <code class="docutils literal notranslate"><span class="pre">let*</span></code>:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define-syntax</span><span class="w"> </span><span class="k">let*</span>
<span class="w">  </span><span class="p">(</span><span class="k">syntax-rules</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">((</span><span class="k">let*</span><span class="w"> </span><span class="p">()</span>
<span class="w">       </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">()</span>
<span class="w">       </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="p">((</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">name1</span><span class="w"> </span><span class="nv">val1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">name2</span><span class="w"> </span><span class="nv">val2</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">       </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">name1</span><span class="w"> </span><span class="nv">val1</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">name2</span><span class="w"> </span><span class="nv">val2</span><span class="p">)</span><span class="w"> </span><span class="o">...</span><span class="p">)</span>
<span class="w">         </span><span class="nv">body1</span><span class="w"> </span><span class="nv">body2</span><span class="w"> </span><span class="o">...</span>
<span class="w">       </span><span class="p">)</span>
<span class="w">     </span><span class="p">)</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>There is a base-case pattern for when the <code class="docutils literal notranslate"><span class="pre">let*</span></code> has no bindings, in
which case it translates directly into a <code class="docutils literal notranslate"><span class="pre">let</span></code>. There is also a
recursive pattern for when there is at least one binding, in which
case the <code class="docutils literal notranslate"><span class="pre">let*</span></code> translates into a simpler <code class="docutils literal notranslate"><span class="pre">let*</span></code> nested within a
<code class="docutils literal notranslate"><span class="pre">let</span></code>. The ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) in a macro definition is similar to a
Kleene star (<code class="docutils literal notranslate"><span class="pre">*</span></code>) in a regular expression, denoting that the
preceding item can be matched zero or more times. Thus, a <code class="docutils literal notranslate"><span class="pre">let*</span></code>
with a single binding matches the second pattern rule above, where
<code class="docutils literal notranslate"><span class="pre">(name2</span> <span class="pre">val2)</span></code> is matched zero times.</p>
</section>
<section id="cpp-macros">
<h2>CPP Macros<a class="headerlink" href="#cpp-macros" title="Link to this heading"></a></h2>
<p>We return our attention to CPP macros. Despite their non-hygienic
nature, they can be very useful in tasks that involve metaprogramming.</p>
<p>CPP allows us to use <code class="docutils literal notranslate"><span class="pre">#define</span></code> to define two types of macros,
<em>object-like</em> and <em>function-like</em> macros. An object-lke macro is a
simple text replacement, substituting one sequence of text for
another. Historically, a common use was to define constants:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PI 3.1415926535</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pi = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;tau = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Better practice in C++ is to define a constant using <code class="docutils literal notranslate"><span class="pre">const</span></code> or
<code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p>
<p>A function-like macro takes arguments, as in <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> above, and can
substitute the argument text into specific locations within the
replacement text.</p>
<p>A more complex example of using function-like macros is to abstract
the definition of multiple pieces of code that follow the same
pattern. Consider the definition of a type to represent a complex
number:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Complex</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">real</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">imag</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;+&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;i)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Suppose that in addition to the overloaded stream insertion operator
above, we wish to support the arithmetic operations <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, and
<code class="docutils literal notranslate"><span class="pre">*</span></code>. These operations all have the same basic form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expression</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">real</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expression</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">imag</span><span class="o">&gt;</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we’ve used <em>uniform initialization syntax</em> to initialize a
<code class="docutils literal notranslate"><span class="pre">Complex</span></code> with values for its members. We can then write a
function-like macro to abstract this structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define COMPLEX_OP(op, real_part, imag_part)    \</span>
<span class="cp">  Complex operator op(Complex a, Complex b) {   \</span>
<span class="cp">    return Complex{ real_part, imag_part };     \</span>
<span class="cp">  }</span>
</pre></div>
</div>
<p>The macro has arguments for each piece that differs between
operations, namely the operator, the expression to compute the real
part, and the expression to compute the imaginary part. We can use the
macro as follows to define the operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">COMPLEX_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
<span class="n">COMPLEX_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
<span class="n">COMPLEX_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span>
<span class="w">           </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
</pre></div>
</div>
<p>As with our initial <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> implementation, the trailing semicolon is
extraneous but improves readability and interaction with syntax
highlighters. Running the code through the preprocessor with <code class="docutils literal notranslate"><span class="pre">g++</span>
<span class="pre">-E</span></code>, we get (modulo spacing):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span>
<span class="w">                  </span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can then proceed to define operations between <code class="docutils literal notranslate"><span class="pre">Complex</span></code> and
<code class="docutils literal notranslate"><span class="pre">double</span></code> values. Again, we observe that such an operation has a
specific pattern:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">type1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">type2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expr1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">expr2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">&lt;exprN&gt;</span></code> is the corresponding argument converted to its
<code class="docutils literal notranslate"><span class="pre">Complex</span></code> representation. We can abstract this using a macro:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define REAL_OP(op, typeA, typeB, argA, argB)   \</span>
<span class="cp">  Complex operator op(typeA a, typeB b) {       \</span>
<span class="cp">    return argA op argB;                        \</span>
<span class="cp">  }</span>
</pre></div>
</div>
<p>We can also define a macro to convert from a <code class="docutils literal notranslate"><span class="pre">double</span></code> to a
<code class="docutils literal notranslate"><span class="pre">Complex</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CONVERT(a)                              \</span>
<span class="cp">  (Complex{ a, 0 })</span>
</pre></div>
</div>
<p>We can then define our operations as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">REAL_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="n">REAL_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="n">REAL_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="n">REAL_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="n">REAL_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="n">REAL_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="n">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>Running this through the preprocessor, we get:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="p">};</span>
<span class="n">Complex</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>We can now use complex numbers as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Complex</span><span class="w"> </span><span class="n">c1</span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">Complex</span><span class="w"> </span><span class="n">c2</span><span class="p">{</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="o">+</span><span class="mi">2</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mf">3.5</span><span class="o">+</span><span class="mi">4</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mf">2.5</span><span class="o">+</span><span class="mi">4</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1.5</span><span class="o">+</span><span class="mi">2</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mf">3.5</span><span class="o">+</span><span class="mi">4</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="o">+-</span><span class="mi">4</span><span class="n">i</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1.5</span><span class="o">+</span><span class="mi">2</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<section id="stringification-and-concatenation">
<h3>Stringification and Concatenation<a class="headerlink" href="#stringification-and-concatenation" title="Link to this heading"></a></h3>
<p>When working with macros, it can be useful to convert a macro argument
to a string or to concatenate it with another token. For instance,
suppose we wanted to write an interactive application that would read
input from a user and perform the corresponding action. On complex
numbers, the target functions may be as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="nf">Complex_conjugate</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>

<span class="n">string</span><span class="w"> </span><span class="nf">Complex_polar</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The application would compare the user input to a string representing
an action, call the appropriate function, and print out the result.
This has the common pattern:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">input</span><span class="o">&gt;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;&lt;action&gt;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Complex_</span><span class="o">&lt;</span><span class="n">action</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, we both need a string representation of the action, as well as
the ability to concatenate the <code class="docutils literal notranslate"><span class="pre">Complex_</span></code> token with the action
token itself. We can define a macro for this pattern as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ACTION(str, name, arg)                  \</span>
<span class="cp">  if (str == #name)                             \</span>
<span class="cp">    cout &lt;&lt; Complex_ ## name(arg) &lt;&lt; endl</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> preceding a token is the <em>stringification</em> operator,
converting the token to a string. The <code class="docutils literal notranslate"><span class="pre">##</span></code> between <code class="docutils literal notranslate"><span class="pre">Complex_</span></code> and
<code class="docutils literal notranslate"><span class="pre">name</span></code> is the <em>token pasting</em> operator, concatenating the tokens on
either side.</p>
<p>We can then write our application code as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
<span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ACTION</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">conjugate</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span>
<span class="w">  </span><span class="n">ACTION</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">polar</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running this through the preprocessor, we obtain the desired result:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Complex</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
<span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;conjugate&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Complex_conjugate</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;polar&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Complex_polar</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="the-macro-namespace">
<h3>The Macro Namespace<a class="headerlink" href="#the-macro-namespace" title="Link to this heading"></a></h3>
<p>One pitfall of using CPP macros is that they are not contained within
any particular namespace. In fact, a macro, as long as it is defined,
will replace <em>any</em> eligible token, regardless of where the token is
located. Thus, defining a macro is akin to making a particular
identifier act as a reserved keyword, unable to be used by the
programmer. (This is one reason why constants are usually better
defined as variables qualified <code class="docutils literal notranslate"><span class="pre">const</span></code> or <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> than as
object-like macros.)</p>
<p>Several conventions are used to avoid polluting the global namespace.
The first is to prefix all macros with characters that are specific to
the library defining them in such a way as to avoid conflict with
other libraries. For instance, our complex-number macros may be
prefixed with <code class="docutils literal notranslate"><span class="pre">COMPLEX_</span></code> to avoid conflicting with other macros or
identifiers. The second strategy is to undefine macros when they are
no longer needed, using the <code class="docutils literal notranslate"><span class="pre">#undef</span></code> preprocessor directive. For
example, at the end of our library code, we may have the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#undef COMPLEX_OP</span>
<span class="cp">#undef REAL_OP</span>
<span class="cp">#undef CONVERT</span>
<span class="cp">#undef ACTION</span>
</pre></div>
</div>
<p>This frees the identifiers to be used for other purposes in later
code.</p>
</section>
</section>
<section id="code-generation">
<h2>Code Generation<a class="headerlink" href="#code-generation" title="Link to this heading"></a></h2>
<p>While macros allow us to generate code using the macro facilities
provided by a language, there are some cases where such a facility is
unavailable or otherwise insufficient for our purposes. In such a
situation, it may be convenient to write a <em>code generator</em> in an
external program, in the same language or in a different language.
This technique is also called <em>automatic programming</em>.</p>
<p>As an example, the R5RS Scheme specification requires implementations
to provide combinations of <code class="docutils literal notranslate"><span class="pre">car</span></code> and <code class="docutils literal notranslate"><span class="pre">cdr</span></code> up to four levels deep.
For instance, <code class="docutils literal notranslate"><span class="pre">(caar</span> <span class="pre">x)</span></code> should be equivalent to <code class="docutils literal notranslate"><span class="pre">(car</span> <span class="pre">(car</span> <span class="pre">x))</span></code>,
and <code class="docutils literal notranslate"><span class="pre">(caddar</span> <span class="pre">x)</span></code> should be equivalent to <code class="docutils literal notranslate"><span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">(cdr</span> <span class="pre">(car</span>
<span class="pre">x))))</span></code>. Aside from <code class="docutils literal notranslate"><span class="pre">car</span></code> and <code class="docutils literal notranslate"><span class="pre">cdr</span></code> themselves, there are 28
combinations that need to be provided, which would be tedious and
error-prone to write by hand. Instead, we can define the following
Python script to generate a Scheme library file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;(c</span><span class="si">{0}</span><span class="s1">r </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="s1">&#39;x&#39;</span>

<span class="k">def</span> <span class="nf">defun</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;(define (c</span><span class="si">{0}</span><span class="s1">r x) </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">defun</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cadrify()</span></code> function is a recursive function that takes in a
sequence such as <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'d',</span> <span class="pre">'a')</span></code> and constructs a call using the
first item and the recursive result of the rest of the sequence. In
this example, the latter is <code class="docutils literal notranslate"><span class="pre">(cdr</span> <span class="pre">(car</span> <span class="pre">x))</span></code>, so the result would be
<code class="docutils literal notranslate"><span class="pre">(car</span> <span class="pre">(cdr</span> <span class="pre">(car</span> <span class="pre">x)))</span></code>. The base case is in which the sequence is
empty, producing just <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">defun()</span></code> function takes in a sequence and uses it construct the
definition for the appropriate combination. It calls <code class="docutils literal notranslate"><span class="pre">cadrify()</span></code> to
construct the body. For the sequence <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'d',</span> <span class="pre">'a')</span></code>, the result
is:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cadar</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>
</pre></div>
</div>
<p>Finally, the loop at the end produces all combinations of <code class="docutils literal notranslate"><span class="pre">'a'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'d'</span></code> for each length. It uses the library function
<code class="docutils literal notranslate"><span class="pre">itertools.product()</span></code> to obtain a sequence that is the <code class="docutils literal notranslate"><span class="pre">i</span></code>th
power of the tuple <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'d')</span></code>. For each combination, it calls
<code class="docutils literal notranslate"><span class="pre">defun()</span></code> to generate the function for that combination.</p>
<p>Running the script results in:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">caar</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cadr</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cdar</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cddr</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">caaar</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">caadr</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>
<span class="o">...</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cdddar</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">x</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="nb">cddddr</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">x</span><span class="p">)))))</span>
</pre></div>
</div>
<p>We can place the resulting code in a standard library to be loaded by
the Scheme interpreter.</p>
</section>
</section>
<section id="template-metaprogramming">
<h1>Template Metaprogramming<a class="headerlink" href="#template-metaprogramming" title="Link to this heading"></a></h1>
<p><em>Template metaprogramming</em> is a technique that uses templates to
produce source code at compile time, which is then compiled with the
rest of the program’s code. It generally refers to a form of
compile-time execution that takes advantage of the language’s rules
for template instantiation. Template metaprogramming is most common in
C++, though a handful of other languages also enable it.</p>
<p>The key to template metaprogramming in C++ is <em>template
specialization</em>, which allows a specialized definition to be written
for instantiating a template with specific arguments. For example,
consider a class template that contains a static <code class="docutils literal notranslate"><span class="pre">value</span></code> field that
is true if the template argument is <code class="docutils literal notranslate"><span class="pre">int</span></code> but false otherwise. We
can write the generic template as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_int</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can now define a <em>specialization</em> for this template when the
argument is <code class="docutils literal notranslate"><span class="pre">int</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_int</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The template parameter list in a specialization contains the
non-specialized parameters, if any. In the case above, there are none,
so it is empty. Then after the name of the template, we provide the
full set of arguments for the instantiation, in this case just
<code class="docutils literal notranslate"><span class="pre">int</span></code>. We then provide the rest of the definition for the
instantiation.</p>
<p>Now when we use the template, the compiler uses the specialization if
the template argument is compatible with the specialization, otherwise
it uses the generic template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">is_int</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">is_int</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This prints a 0 followed by a 1.</p>
<p>Template specialization enables us to write code that is conditional
on a template argument. Combined with recursive instantiation, this
results in template instantiation being Turing complete. Templates do
not encode variables that are mutable, so template metaprogramming is
actually a form of functional programming.</p>
<section id="pairs">
<h2>Pairs<a class="headerlink" href="#pairs" title="Link to this heading"></a></h2>
<p>As a more complex example, let us define pairs and lists that can be
manipulated at compile time. The elements stored in these structures
will be arbitrary types.</p>
<p>Before we proceed to define pairs, we construct a reporting mechanism
that allows us to examine results at compile time. We arrange to
include the relevant information in an error message generated by the
compiler:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">report</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;report&quot;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For simplicity, we make use of an integer template parameter, though
we could encode numbers using types instead. When instantiating the
<code class="docutils literal notranslate"><span class="pre">report</span></code> template, the <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> raises an error if the
template argument <code class="docutils literal notranslate"><span class="pre">I</span></code> is nonnegative. Consider the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>The compiler will report an error, indicating what instantiation
caused the <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> to fail. In Clang, we get an error like
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pair.cpp:64:3: error: static_assert failed &quot;report&quot;
  static_assert(I &lt; 0, &quot;report&quot;);
  ^             ~~~~~
pair.cpp:67:16: note: in instantiation of template class &#39;report&lt;int, 5&gt;&#39;
      requested here
report&lt;int, 5&gt; foo;
               ^
</pre></div>
</div>
<p>Using GCC, the error is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;int, 5&gt;&#39;</span><span class="p">:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">67</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">main</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">64</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
   <span class="n">static_assert</span><span class="p">(</span><span class="n">I</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;report&quot;</span><span class="p">);</span>
   <span class="o">^</span>
</pre></div>
</div>
<p>In both compilers, the relevant information is reported, which is that
the arguments to the <code class="docutils literal notranslate"><span class="pre">report</span></code> template are <code class="docutils literal notranslate"><span class="pre">int</span></code> and 5.</p>
<p>We can then define a pair template as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Second</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pair</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">First</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">cdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Second</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Within the template, we define type aliases <code class="docutils literal notranslate"><span class="pre">car</span></code> and <code class="docutils literal notranslate"><span class="pre">cdr</span></code> to
refer to the first and second items of the pair. Thus, <code class="docutils literal notranslate"><span class="pre">pair&lt;int,</span>
<span class="pre">double&gt;::car</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">int</span></code>, while <code class="docutils literal notranslate"><span class="pre">pair&lt;int,</span>
<span class="pre">double&gt;::cdr</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>We can also define type aliases to extract the first and second items
from a pair:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">car_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Pair</span><span class="o">::</span><span class="n">car</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">cdr_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Pair</span><span class="o">::</span><span class="n">cdr</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">typename</span></code> keyword is required before <code class="docutils literal notranslate"><span class="pre">Pair::car</span></code> and
<code class="docutils literal notranslate"><span class="pre">Pair::cdr</span></code>, since we are using a nested type whose enclosing type
is dependent on a template parameter. In such a case, C++ cannot
determine that we are naming a type rather than a value, so the
<code class="docutils literal notranslate"><span class="pre">typename</span></code> keyword explicitly indicates that it is a type. Using the
aliases above, <code class="docutils literal notranslate"><span class="pre">car_t&lt;pair&lt;int,</span> <span class="pre">double&gt;&gt;</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">int</span></code>,
while <code class="docutils literal notranslate"><span class="pre">cdr_t&lt;pair&lt;int,</span> <span class="pre">double&gt;&gt;</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>In order to represent recursive lists, we need a representation for
the empty list:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can now define a template to determine whether or not a list,
represented either by the empty list <code class="docutils literal notranslate"><span class="pre">nil</span></code> or by a
<code class="docutils literal notranslate"><span class="pre">nil</span></code>-terminated sequence of <code class="docutils literal notranslate"><span class="pre">pair</span></code>s, is empty. We define a
generic template and then a specialization for the case of <code class="docutils literal notranslate"><span class="pre">nil</span></code> as
the argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_empty</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_empty</span><span class="o">&lt;</span><span class="n">nil</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In order to use the field <code class="docutils literal notranslate"><span class="pre">value</span></code> at compile time, it must be a
compile-time constant, which we can arrange by making it both static
and <code class="docutils literal notranslate"><span class="pre">const</span></code> and initializing it with a compile-time constant. With
C++14, we can also define global <em>variable templates</em> to encode the
length of a list:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_empty_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_empty</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>The value of <code class="docutils literal notranslate"><span class="pre">is_empty_v&lt;nil&gt;</span></code> is true, while <code class="docutils literal notranslate"><span class="pre">is_empty&lt;pair&lt;int,</span>
<span class="pre">nil&gt;&gt;</span></code> is false. Then we can determine at compilation whether or not
a list is empty:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">nil</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">nil</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nil</span><span class="p">;</span>
<span class="n">report</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">report</span><span class="o">&lt;</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">y</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="n">report</span><span class="o">&lt;</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">z</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, we introduce type aliases for lists, which act as immutable
compile-time variables. We then instantiate <code class="docutils literal notranslate"><span class="pre">report</span></code> with a type and
whether or not it is empty. This results in the following error
messages from GCC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;pair&lt;char, pair&lt;int,</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="s1">&#39;:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">82</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
   <span class="n">static_assert</span><span class="p">(</span><span class="n">I</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;report&quot;</span><span class="p">);</span>
   <span class="o">^~~~~~~~~~~~~</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;pair&lt;float, pair&lt;bool,</span>
  <span class="n">nil</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="s1">&#39;:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">83</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;nil, 1&gt;&#39;</span><span class="p">:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">84</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
</pre></div>
</div>
<p>Examining the integer argument of <code class="docutils literal notranslate"><span class="pre">report</span></code>, we see that the lists
<code class="docutils literal notranslate"><span class="pre">pair&lt;char,</span> <span class="pre">pair&lt;int,</span> <span class="pre">pair&lt;double,</span> <span class="pre">nil&gt;&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">pair&lt;float,</span>
<span class="pre">pair&lt;bool,</span> <span class="pre">nil&gt;&gt;</span></code> are not empty, but the list <code class="docutils literal notranslate"><span class="pre">nil</span></code> is.</p>
<p>We can compute the length of a list using recursion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">length</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="o">&lt;</span><span class="n">cdr_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">length</span><span class="o">&lt;</span><span class="n">nil</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, we are using a value from a recursive instantiation of the
<code class="docutils literal notranslate"><span class="pre">length</span></code> struct. Since <code class="docutils literal notranslate"><span class="pre">value</span></code> is initialized with an expression
consisting of an operation between compile-time constants, it is also
a compile-time constant. The recursion terminates at the
specialization for <code class="docutils literal notranslate"><span class="pre">length&lt;nil&gt;</span></code>, where the <code class="docutils literal notranslate"><span class="pre">value</span></code> member is
directly initialized to 0. As with <code class="docutils literal notranslate"><span class="pre">is_empty_v</span></code>, we define a
variable template <code class="docutils literal notranslate"><span class="pre">length_v</span></code> to encode the result. We can compute
and report the length of the <code class="docutils literal notranslate"><span class="pre">x</span></code> type alias:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">length_v</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
</pre></div>
</div>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">report</span></code> is arbitrary, since we only care
about the second argument, so we just pass <code class="docutils literal notranslate"><span class="pre">x</span></code> itself. We get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;pair&lt;char, pair&lt;int,</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="s1">&#39;:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">85</span><span class="p">:</span><span class="mi">26</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
</pre></div>
</div>
<p>The relevant information is that the length is 3.</p>
<p>We can define even more complex manipulation on lists. For instance,
we can reverse a list as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SoFar</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">reverse_helper</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">reverse_helper</span><span class="o">&lt;</span><span class="n">cdr_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                            </span><span class="n">pair</span><span class="o">&lt;</span><span class="n">car_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">SoFar</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">SoFar</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">reverse_helper</span><span class="o">&lt;</span><span class="n">nil</span><span class="p">,</span><span class="w"> </span><span class="n">SoFar</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SoFar</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">reverse_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">reverse_helper</span><span class="o">&lt;</span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="n">nil</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, we use a helper template to perform the reversal, where the
first template argument is the remaining list and the second is the
reversed list so far. In each step, we compute a new partial result as
<code class="docutils literal notranslate"><span class="pre">pair&lt;car_t&lt;List&gt;,</span> <span class="pre">SoFar&gt;</span></code>, adding the first item in the remaining
list to the front of the previous partial result. Then <code class="docutils literal notranslate"><span class="pre">cdr_t&lt;List&gt;</span></code>
is the remaining list excluding the first item.</p>
<p>The base case of the recursion is when the remaining list is <code class="docutils literal notranslate"><span class="pre">nil</span></code>,
in which case the final result is the same as the partial result. We
accomplish this with a <em>partial class template specialization</em>, which
allows us to specialize only some of the arguments to a class template
<a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. In <code class="docutils literal notranslate"><span class="pre">reverse_helper</span></code>, we specialize the first argument, so that
any instantiation of <code class="docutils literal notranslate"><span class="pre">reverse_helper</span></code> where the first argument is
<code class="docutils literal notranslate"><span class="pre">nil</span></code> will use the specialization. The specialization retains a
template parameter, which is included in its parameter list. The full
argument list appears after the template name, including both the
specialized and unspecialized arguments.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>C++ only allows partial specialization on class templates.
Function templates may be specialized, but they cannot be
partially specialized.</p>
</aside>
</aside>
<p>We seed the whole computation in the <code class="docutils literal notranslate"><span class="pre">reverse_t</span></code> alias template with
the original list and empty partial result. We apply <code class="docutils literal notranslate"><span class="pre">reverse_t</span></code> to
<code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">reverse_t</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, the second argument is an arbitrary nonnegative value. We get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;pair&lt;double, pair&lt;int,</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="s1">&#39;:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">86</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
</pre></div>
</div>
<p>As a last example, we can now write a template to append two lists:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">List2</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">append</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">pair</span><span class="o">&lt;</span><span class="n">car_t</span><span class="o">&lt;</span><span class="n">List1</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">append</span><span class="o">&lt;</span><span class="n">cdr_t</span><span class="o">&lt;</span><span class="n">List1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">List2</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List2</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">append</span><span class="o">&lt;</span><span class="n">nil</span><span class="p">,</span><span class="w"> </span><span class="n">List2</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">List1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">List2</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">append_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">append</span><span class="o">&lt;</span><span class="n">List1</span><span class="p">,</span><span class="w"> </span><span class="n">List2</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, the template appends the second argument to the first argument.
This is accomplished by prepending the first item of the first list to
the result of appending the second list to the rest of the first list.
The recursion terminates when the first list is empty. Applying
<code class="docutils literal notranslate"><span class="pre">append_t</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">append_t</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
</pre></div>
</div>
<p>We get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;pair&lt;char, pair&lt;int,</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="nb">float</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="nb">bool</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="s1">&#39;:</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">87</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">pair</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
</pre></div>
</div>
</section>
<section id="numerical-computations">
<h2>Numerical Computations<a class="headerlink" href="#numerical-computations" title="Link to this heading"></a></h2>
<p>Using just recursion and template specialization, we could encode
numbers using a system like Church numerals. However, C++ also
supports integral template parameters, so we can perform compile-time
numerical computations using an integer parameter rather than just
types.</p>
<p>As an example, consider the following definition of a template to
compute the factorial of the template parameter:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The generic template multiplies its template argument <code class="docutils literal notranslate"><span class="pre">N</span></code> by the
result of computing factorial on <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code>. The base case is provided
by the specialization for when the argument is 0, where the factorial
is 1.</p>
<p>Here, we’ve used a <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> to hold the computed value, so that
larger results can be computed than can be represented by <code class="docutils literal notranslate"><span class="pre">int</span></code>. We
define a template to report a result as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">report</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;report&quot;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The condition of the <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> is written to depend on the
template parameter so that the assertion fails during instantiation,
rather than before. Then if we compute the factorial of 5:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">factorial</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<p>We get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct report&lt;120ll&gt;&#39;</span><span class="p">:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">report</span>
   <span class="n">static_assert</span><span class="p">(</span><span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;report&quot;</span><span class="p">);</span>
   <span class="o">^</span>
</pre></div>
</div>
<p>This shows that the result is 120.</p>
<p>We can use a macro to make our program more generic, encoding the
argument to <code class="docutils literal notranslate"><span class="pre">factorial</span></code> as a macro that can be defined at compile
time:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<p>We can even provide a default value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef NUM</span>
<span class="cp">#define NUM 5</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Then at the command line, we can specify the argument as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --std=c++14 factorial.cpp -DNUM=20
factorial.cpp: In instantiation of &#39;struct report&lt;2432902008176640000ll&gt;&#39;:
factorial.cpp:27:33:   required from here
factorial.cpp:23:3: error: static assertion failed: report
   static_assert(N &gt; 0 &amp;&amp; N &lt; 0, &quot;report&quot;);
   ^
</pre></div>
</div>
<p>The command-line argument <code class="docutils literal notranslate"><span class="pre">-D</span></code> in GCC and Clang allows us to define
a macro from the command line.</p>
<p>Suppose we now attempt to compute the factorial of a negative number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --std=c++14 factorial.cpp -DNUM=-1
factorial.cpp: In instantiation of &#39;const long long int
  factorial&lt;-900&gt;::value&#39;:
factorial.cpp:23:36:   recursively required from &#39;const long long int
  factorial&lt;-2&gt;::value&#39;
factorial.cpp:23:36:   required from &#39;const long long int
  factorial&lt;-1&gt;::value&#39;
factorial.cpp:37:27:   required from here
factorial.cpp:23:36: fatal error: template instantiation depth exceeds
  maximum of 900 (use -ftemplate-depth= to increase the maximum)
   static const long long value = N * factorial&lt;N - 1&gt;::value;
                                    ^
compilation terminated.
</pre></div>
</div>
<p>We see that the recursion never reaches the base case of 0. Instead,
the compiler terminates compilation when the recursion depth reaches
its limit. We can attempt to add an assertion that the template
argument is non-negative as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;argument to factorial must be non-negative&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>However, this does not prevent the recursive instantiation, so that
what we get is an even longer set of error messages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct factorial&lt;-1&gt;&#39;</span><span class="p">:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">25</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">factorial</span>
  <span class="n">must</span> <span class="n">be</span> <span class="n">non</span><span class="o">-</span><span class="n">negative</span>
   <span class="n">static_assert</span><span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;argument to factorial must be non-negative&quot;</span><span class="p">);</span>
   <span class="o">^</span>
<span class="o">...</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;struct factorial&lt;-900&gt;&#39;</span><span class="p">:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span>   <span class="n">recursively</span> <span class="n">required</span> <span class="kn">from</span> <span class="s1">&#39;const long long int</span>
  <span class="n">factorial</span><span class="o">&lt;-</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="s1">&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="s1">&#39;const long long int</span>
  <span class="n">factorial</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="s1">&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">static</span> <span class="n">assertion</span> <span class="n">failed</span><span class="p">:</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">factorial</span>
  <span class="n">must</span> <span class="n">be</span> <span class="n">non</span><span class="o">-</span><span class="n">negative</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="s1">&#39;const long long int</span>
  <span class="n">factorial</span><span class="o">&lt;-</span><span class="mi">900</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="s1">&#39;:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span>   <span class="n">recursively</span> <span class="n">required</span> <span class="kn">from</span> <span class="s1">&#39;const long long int</span>
  <span class="n">factorial</span><span class="o">&lt;-</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="s1">&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="s1">&#39;const long long int</span>
  <span class="n">factorial</span><span class="o">&lt;-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="s1">&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">fatal</span> <span class="n">error</span><span class="p">:</span> <span class="n">template</span> <span class="n">instantiation</span> <span class="n">depth</span> <span class="n">exceeds</span>
  <span class="n">maximum</span> <span class="n">of</span> <span class="mi">900</span> <span class="p">(</span><span class="n">use</span> <span class="o">-</span><span class="n">ftemplate</span><span class="o">-</span><span class="n">depth</span><span class="o">=</span> <span class="n">to</span> <span class="n">increase</span> <span class="n">the</span> <span class="n">maximum</span><span class="p">)</span>
   <span class="n">static</span> <span class="n">const</span> <span class="n">long</span> <span class="n">long</span> <span class="n">value</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="p">;</span>
                                    <span class="o">^</span>
<span class="n">compilation</span> <span class="n">terminated</span><span class="o">.</span>
</pre></div>
</div>
<p>Here, we have removed the intermediate error messages between -1 and
-900.</p>
<p>In order to actually prevent recursive instantiation when the argument
is negative, we can offload the actual recursive work to a helper
template. We can then check that the argument is non-negative in
<code class="docutils literal notranslate"><span class="pre">factorial</span></code>, converting the argument to 0 if it is negative:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial_helper</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial_helper</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial_helper</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;argument to factorial must be non-negative&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorial_helper</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The key here is that <code class="docutils literal notranslate"><span class="pre">factorial</span></code> only instantiates
<code class="docutils literal notranslate"><span class="pre">factorial_helper&lt;0&gt;</span></code> if the argument of <code class="docutils literal notranslate"><span class="pre">factorial</span></code> is
nonnegative. Thus, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --std=c++14 factorial.cpp -DNUM=-1
factorial.cpp: In instantiation of &#39;struct factorial&lt;-1&gt;&#39;:
factorial.cpp:38:24:   required from here
factorial.cpp:17:3: error: static assertion failed: argument to factorial
  must be non-negative
   static_assert(N &gt;= 0, &quot;argument to factorial must be non-negative&quot;);
   ^
factorial.cpp: In instantiation of &#39;struct report&lt;1ll&gt;&#39;:
factorial.cpp:38:33:   required from here
factorial.cpp:34:3: error: static assertion failed: report
   static_assert(N &gt; 0 &amp;&amp; N &lt; 0, &quot;report&quot;);
   ^
</pre></div>
</div>
<p>We no longer have an unbounded recursion. This demonstrates how we can
achieve conditional compilation, even without a built-in conditional
construct.</p>
<p>An alternative strategy is to use a second, defaulted template
argument that tracks whether or not the first argument is positive:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="cm">/*Positive*/</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When we instantiate <code class="docutils literal notranslate"><span class="pre">factorial</span></code> with a positive argument, as in
<code class="docutils literal notranslate"><span class="pre">factorial&lt;5&gt;</span></code>, the second argument is defaulted to true. Since that
does not match the partial specialization, the instantiation uses the
generic version of the template. On the other hand, if we instantiate
the template with a non-positive argument, such as in
<code class="docutils literal notranslate"><span class="pre">factorial&lt;0&gt;</span></code>, the second argument defaults to false, resulting in
the partial specialization being used. Thus, the defaulted argument
serves to control whether the generic or specialized version is used.
Since it’s not used for anything else, we need not name the argument,
but we have included the <code class="docutils literal notranslate"><span class="pre">/*Positive*/</span></code> comment to document the
argument’s purpose.</p>
<p>As another example of a numerical computation, the following computes
Fibonacci numbers at compile time. For simplicity, we do not implement
error checking for negative arguments:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fib</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fib</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fib</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We have two base cases, provided by separate specializations for when
the argument is 0 or 1. As with factorial, we use a macro to represent
the input:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="o">&lt;</span><span class="n">fib</span><span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
<p>We can then specify the input at the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --std=c++14 fib.cpp -DNUM=7
fib.cpp: In instantiation of &#39;struct report&lt;13ll&gt;&#39;:
fib.cpp:26:27:   required from here
fib.cpp:22:3: error: static assertion failed: report
   static_assert(N &gt; 0 &amp;&amp; N &lt; 0, &quot;report&quot;);
   ^
</pre></div>
</div>
<p>We can even provide the largest input for which the Fibonacci number
is representable as a <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --std=c++14 fib.cpp -DNUM=92
fib.cpp: In instantiation of &#39;struct report&lt;7540113804746346429ll&gt;&#39;:
fib.cpp:26:27:   required from here
fib.cpp:22:3: error: static assertion failed: report
   static_assert(N &gt; 0 &amp;&amp; N &lt; 0, &quot;report&quot;);
   ^
</pre></div>
</div>
<p>This computation only takes a fraction of a second, since the C++
compiler only instantiates a template once for a given set of
arguments within a single translation unit. Thus, the compiler
automatically performs <em>memoization</em>, saving the result of a single
computation rather than repeating it.</p>
</section>
<section id="templates-and-function-overloading">
<h2>Templates and Function Overloading<a class="headerlink" href="#templates-and-function-overloading" title="Link to this heading"></a></h2>
<p>While function templates can also be specialized, a function template
can also be overloaded with a non-template function. In performing
overload resolution, C++ prefers a non-template function over a
template instantiation, as long as the parameter and return types of
the template instantiation are not superior to the non-template in
the given context.</p>
<p>As an example, consider the following function template to convert a
value to a string representation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">oss</span><span class="p">;</span>
<span class="w">  </span><span class="n">oss</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can make use of this template, with the compiler performing
template-argument deduction, as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mf">3.14</span><span class="n">i</span><span class="p">)</span>
<span class="mf">3.14</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>If we then decide that the representation of a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is
undesirable, we can write a function overload as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="w"> </span><span class="nf">to_string</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since this is a non-template function, C++ will prefer it to the
template instantiation <code class="docutils literal notranslate"><span class="pre">to_string&lt;bool&gt;</span></code> when the argument type is
<code class="docutils literal notranslate"><span class="pre">bool</span></code>. Thus, the same code in <code class="docutils literal notranslate"><span class="pre">main()</span></code> now results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mf">3.14</span><span class="n">i</span><span class="p">)</span>
<span class="mf">3.14</span>
<span class="n">true</span>
</pre></div>
</div>
</section>
<section id="sfinae">
<h2>SFINAE<a class="headerlink" href="#sfinae" title="Link to this heading"></a></h2>
<p>In considering function overloads, the C++ compiler does not consider
it an error if the types and expressions used in the header of a
function template are unsuitable for a particular set of template
arguments. This is known as <em>substitution failure is not an error
(SFINAE)</em>, and it is a powerful feature of templates in C++. Rather
than producing an error in such a case, the compiler simply removes
the template from the set of candidate functions to be considered in
overload resolution.</p>
<p>As an example, suppose we wanted to modify our <code class="docutils literal notranslate"><span class="pre">to_string()</span></code> to use
<code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> for the types for which the latter is defined. We
can place a dependence on the existence of a suitable
<code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> overload in the header of a new function
template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the trailing return type is necessary so that
<code class="docutils literal notranslate"><span class="pre">std::to_string(item)</span></code> appears in the header of the function. Then
the function template will fail on substitution if there is no
overload of <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> such that it can be applied to a
value of the template argument. For example, consider calling our
<code class="docutils literal notranslate"><span class="pre">to_string()</span></code> on a <code class="docutils literal notranslate"><span class="pre">Complex</span></code> object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Our previous <code class="docutils literal notranslate"><span class="pre">to_string()</span></code> template is still viable, so it is
considered in overload resolution. The new template we defined above,
however, fails to substitute, since there is no definition of
<code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> that can be applied to a <code class="docutils literal notranslate"><span class="pre">Complex</span></code>. Thus,
rather than being an error, the second template is merely removed from
consideration, and the call resolves to the original template.</p>
<p>With the second template definition, we can still call <code class="docutils literal notranslate"><span class="pre">to_string()</span></code>
on a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, since C++ will still prefer the non-template function.
However, we run into trouble when attempting to call it on a
<code class="docutils literal notranslate"><span class="pre">double</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">to_string</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">82</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">call</span> <span class="n">to</span> <span class="s1">&#39;to_string&#39;</span> <span class="ow">is</span> <span class="n">ambiguous</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">to_string</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="o">^~~~~~~~~~</span>
<span class="n">to_string</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">65</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span> <span class="n">note</span><span class="p">:</span> <span class="n">candidate</span> <span class="n">function</span> <span class="p">[</span><span class="k">with</span> <span class="n">T</span> <span class="o">=</span> <span class="n">double</span><span class="p">]</span>
<span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="n">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
       <span class="o">^</span>
<span class="n">to_string</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">72</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span> <span class="n">note</span><span class="p">:</span> <span class="n">candidate</span> <span class="n">function</span> <span class="p">[</span><span class="k">with</span> <span class="n">T</span> <span class="o">=</span> <span class="n">double</span><span class="p">]</span>
<span class="n">auto</span> <span class="n">to_string</span><span class="p">(</span><span class="n">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
     <span class="o">^</span>
<span class="n">to_string</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">76</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span> <span class="n">note</span><span class="p">:</span> <span class="n">candidate</span> <span class="n">function</span>
<span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="nb">bool</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
       <span class="o">^</span>
<span class="mi">1</span> <span class="n">error</span> <span class="n">generated</span><span class="o">.</span>
</pre></div>
</div>
<p>Both templates are equally viable when the argument is of type
<code class="docutils literal notranslate"><span class="pre">double</span></code>, so the compiler cannot disambiguate between them. The
non-template overload that takes in a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is also viable, since a
<code class="docutils literal notranslate"><span class="pre">double</span></code> can be converted to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>, so it is reported in the
error message even though it is inferior to either template.</p>
<p>In order to fix this problem, we need to arrange for the first
function template to be nonviable when there is a compatible overload
for <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code>. This requires ensuring that there is a
substitution failure for the template when that is the case.</p>
</section>
<section id="ensuring-a-substitution-failure">
<h2>Ensuring a Substitution Failure<a class="headerlink" href="#ensuring-a-substitution-failure" title="Link to this heading"></a></h2>
<p>There are many tools that are used to ensure a substitution failure.
Perhaps the most fundamental is the <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> template, defined in
the standard library in the <code class="docutils literal notranslate"><span class="pre">&lt;type_traits&gt;</span></code> header as of C++11. We
can also define it ourselves as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">enable_if</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">enable_if</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The generic template takes in a <code class="docutils literal notranslate"><span class="pre">bool</span></code> and a type and defines a
member alias for the type argument. The specialization elides this
alias when the <code class="docutils literal notranslate"><span class="pre">bool</span></code> argument is false. C++14 additionally defines
<code class="docutils literal notranslate"><span class="pre">enable_if_t</span></code> as an alias template, as in the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">enable_if_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">enable_if</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</pre></div>
</div>
<p>We can use <code class="docutils literal notranslate"><span class="pre">enable_if</span></code> or <code class="docutils literal notranslate"><span class="pre">enable_if_t</span></code> to induce a failure, as in
the following definition for <code class="docutils literal notranslate"><span class="pre">factorial</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When the template argument <code class="docutils literal notranslate"><span class="pre">N</span></code> is negative, the <code class="docutils literal notranslate"><span class="pre">enable_if</span></code>
instantiation has no <code class="docutils literal notranslate"><span class="pre">type</span></code> member, so we get an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="n">file</span> <span class="n">included</span> <span class="kn">from</span> <span class="nn">factorial.cpp</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span>
<span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">gcc5</span><span class="o">/</span><span class="n">c</span><span class="o">++/</span><span class="n">type_traits</span><span class="p">:</span> <span class="n">In</span> <span class="n">substitution</span> <span class="n">of</span>
    <span class="s1">&#39;template&lt;bool _Cond, class _Tp&gt; using enable_if_t = typename</span>
    <span class="n">std</span><span class="p">::</span><span class="n">enable_if</span><span class="p">::</span><span class="nb">type</span> <span class="p">[</span><span class="k">with</span> <span class="nb">bool</span> <span class="n">_Cond</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span> <span class="n">_Tp</span> <span class="o">=</span> <span class="n">long</span> <span class="n">long</span>
    <span class="nb">int</span><span class="p">]</span><span class="s1">&#39;:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span><span class="mi">52</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="s1">&#39;struct factorial&lt;-1&gt;&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">51</span><span class="p">:</span><span class="mi">25</span><span class="p">:</span>   <span class="n">required</span> <span class="kn">from</span> <span class="nn">here</span>
<span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">gcc5</span><span class="o">/</span><span class="n">c</span><span class="o">++/</span><span class="n">type_traits</span><span class="p">:</span><span class="mi">2388</span><span class="p">:</span><span class="mi">61</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">no</span> <span class="nb">type</span>
    <span class="n">named</span> <span class="s1">&#39;type&#39;</span> <span class="ow">in</span> <span class="s1">&#39;struct std::enable_if&lt;false, long long int&gt;&#39;</span>
     <span class="n">using</span> <span class="n">enable_if_t</span> <span class="o">=</span> <span class="n">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">_Cond</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&gt;</span><span class="p">::</span><span class="nb">type</span><span class="p">;</span>
                                                             <span class="o">^</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="s1">&#39;int main()&#39;</span><span class="p">:</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">51</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="s1">&#39;value&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="s1">&#39;factorial&lt;-1&gt;&#39;</span>
   <span class="n">report</span><span class="o">&lt;</span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
          <span class="o">^</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">51</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="s1">&#39;value&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="s1">&#39;factorial&lt;-1&gt;&#39;</span>
<span class="n">factorial</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">51</span><span class="p">:</span><span class="mi">32</span><span class="p">:</span> <span class="n">error</span><span class="p">:</span> <span class="n">template</span> <span class="n">argument</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">invalid</span>
   <span class="n">report</span><span class="o">&lt;</span><span class="n">factorial</span><span class="o">&lt;</span><span class="n">NUM</span><span class="o">&gt;</span><span class="p">::</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
                               <span class="o">^</span>
</pre></div>
</div>
<p>This provides us another mechanism to prevent instantiation of a
template with a semantically invalid argument. In this case,
substitution failure <em>is</em> an error, since the failure did not occur in
the header of a function template.</p>
<p>Another option we have is to rely on the fact that variadic arguments
are the least preferred alternative in function-overload resolution. Thus,
we can write our overloads as helper functions or function templates,
with an additional argument to be considered in overload resolution:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="w"> </span><span class="nf">to_string_helper</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ignored</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">to_string_helper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ignored</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">to_string_helper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">oss</span><span class="p">;</span>
<span class="w">  </span><span class="n">oss</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">string</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">to_string_helper</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">to_string()</span></code> calls <code class="docutils literal notranslate"><span class="pre">to_string_helper()</span></code> with the item and a
dummy integer argument. We define three overloads of
<code class="docutils literal notranslate"><span class="pre">to_string_helper()</span></code> as before, except that the overloads for
<code class="docutils literal notranslate"><span class="pre">bool</span></code> and types for which <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> is defined take in
an extra <code class="docutils literal notranslate"><span class="pre">int</span></code> argument. The generic overload that is viable for all
types, however, uses variadic arguments. Since variadic arguments have
the lowest priority in function-overload resolution, if both the
generic overload and another overload are viable, the latter is
chosen. Thus, the overload that uses <code class="docutils literal notranslate"><span class="pre">std::to_string()</span></code> is preferred
when <code class="docutils literal notranslate"><span class="pre">to_string_helper()</span></code> is called on a <code class="docutils literal notranslate"><span class="pre">double</span></code>. We no longer
have an ambiguity, and we get the desired result when the program is
compiled and run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mf">3.14</span><span class="n">i</span><span class="p">)</span>
<span class="mf">3.140000</span>
<span class="n">true</span>
</pre></div>
</div>
</section>
<section id="variadic-templates">
<span id="id4"></span><h2>Variadic Templates<a class="headerlink" href="#variadic-templates" title="Link to this heading"></a></h2>
<p>As of the C++11 standard, C++ supports <em>variadic templates</em>, which are
templates that take a variable number of arguments. Both class and
function templates can be variadic, and variadic templates enable us
to write variadic function overloads that are type safe, unlike
C-style varargs.</p>
<p>As an example, consider the definition of a tuple template that
encapsulates multiple items of arbitrary type. For simplicity, we
implement the template to require at least one item. We can declare
such a template as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Rest</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="p">;</span>
</pre></div>
</div>
<p>There is a non-variadic parameter, requiring at least one argument to
be provided. This is followed by a <em>parameter pack</em>, which accepts
zero or more arguments. In this case, the ellipsis follows the
<code class="docutils literal notranslate"><span class="pre">class</span></code> keyword, so the arguments accepted by the parameter pack are
types. We can then declare a tuple as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
</pre></div>
</div>
<p>In the first instantiation, the template parameter <code class="docutils literal notranslate"><span class="pre">First</span></code> is
associated with the argument <code class="docutils literal notranslate"><span class="pre">int</span></code>, while the parameter pack is
empty. In the second case, the parameter <code class="docutils literal notranslate"><span class="pre">First</span></code> is associated with
<code class="docutils literal notranslate"><span class="pre">double</span></code>, while the parameter pack is associated with <code class="docutils literal notranslate"><span class="pre">char</span></code> and
<code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>Within the template definition, we can use the <code class="docutils literal notranslate"><span class="pre">sizeof...</span></code> operator
to determine the size of the parameter pack. Thus, we can compute the
size of the tuple as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Rest</span><span class="p">);</span>
</pre></div>
</div>
<p>Parameter packs are often processed recursively. It is natural to
define a tuple itself recursively as a combination of the first data
item and a smaller tuple containing all but the first:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">first_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">First</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">rest_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">first_type</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="n">rest_type</span><span class="w"> </span><span class="n">rest</span><span class="p">;</span>
</pre></div>
</div>
<p>The ellipsis, when it appears to the right of a pattern containing a
parameter pack, expands the pattern into comma-separated
instantiations of the pattern, one per item in the parameter pack.
Thus, if <code class="docutils literal notranslate"><span class="pre">Rest</span></code> is associated with <code class="docutils literal notranslate"><span class="pre">char</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code>,
<code class="docutils literal notranslate"><span class="pre">tuple&lt;Rest...&gt;</span></code> expands to <code class="docutils literal notranslate"><span class="pre">tuple&lt;char,</span> <span class="pre">int&gt;</span></code>.</p>
<p>In the code above, we have introduced type aliases for the type of the
first data item and the type of the rest of the tuple. We then
declared data members for each of these components. We can write a
constructor to initialize them as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">Rest</span><span class="p">...</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">first</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"> </span><span class="n">rest</span><span class="p">(</span><span class="n">r</span><span class="p">...)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">First</span></code> as <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">Rest</span></code> as above, this expands to
the equivalent of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">r0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">  </span><span class="n">first</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"> </span><span class="n">rest</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>Both the parameter <code class="docutils literal notranslate"><span class="pre">Rest...</span> <span class="pre">r</span></code> as well as the use of the parameter
<code class="docutils literal notranslate"><span class="pre">r...</span></code> expand, with <code class="docutils literal notranslate"><span class="pre">r</span></code> replaced by a unique identifier in each
instantiation of the pattern.</p>
<p>The full template definition is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Rest</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Rest</span><span class="p">);</span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">first_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">First</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">rest_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">first_type</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">  </span><span class="n">rest_type</span><span class="w"> </span><span class="n">rest</span><span class="p">;</span>

<span class="w">  </span><span class="n">tuple</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">Rest</span><span class="p">...</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">first</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="w"> </span><span class="n">rest</span><span class="p">(</span><span class="n">r</span><span class="p">...)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since this is a recursive definition, we need a base case to terminate
the recursion. As stated above, we’ve chosen to make the base case a
tuple containing one item. We can specify this base case with a
specialization of the variadic template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">First</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="o">&lt;</span><span class="n">First</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">first_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">First</span><span class="p">;</span>

<span class="w">  </span><span class="n">first_type</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>

<span class="w">  </span><span class="n">tuple</span><span class="p">(</span><span class="n">First</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">first</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In order to facilitate using a tuple, we can write a function template
to construct a tuple. This can then take advantage of argument
deduction for function templates, which is not available for class
templates prior to C++17. We write a <code class="docutils literal notranslate"><span class="pre">make_tuple</span></code> variadic function
template as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Types</span><span class="o">&gt;</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="n">Types</span><span class="p">...</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">items</span><span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now make use of this function template to construct a tuple:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mf">4.9</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>While we now have the ability to construct a tuple, we have not yet
provided a convenient mechanism for accessing individual elements from
a tuple. In order to do so, we first write a class template to contain
a reference to a single element from a tuple. We declare it as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple_element</span><span class="p">;</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">Index</span></code> is the index corresponding to the item
referenced by a <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code>, and <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> is the type of the
tuple itself. We can then write the base case as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple_element</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Tuple</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">::</span><span class="n">first_type</span><span class="p">;</span>

<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">;</span>

<span class="w">  </span><span class="n">tuple_element</span><span class="p">(</span><span class="n">Tuple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">item</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The type of the element at index 0 is aliased by the <code class="docutils literal notranslate"><span class="pre">first_type</span></code>
member of a tuple. The element itself is represented by the <code class="docutils literal notranslate"><span class="pre">first</span></code>
data member of a tuple object. Thus, we initialize our reference to
the item with the <code class="docutils literal notranslate"><span class="pre">first</span></code> member of the tuple argument to the
constructor. We also introduce a type alias <code class="docutils literal notranslate"><span class="pre">type</span></code> to refer to the
type of the item.</p>
<p>The recursive case decrements the index and passes off the computation
to a <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code> instantiated with all but the first item in a
tuple:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tuple_element</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">rest_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="n">Index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">typename</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">::</span><span class="n">rest_type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">rest_type</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>

<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">;</span>

<span class="w">  </span><span class="n">tuple_element</span><span class="p">(</span><span class="n">Tuple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">item</span><span class="p">(</span><span class="n">rest_type</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">rest</span><span class="p">).</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">rest_type</span></code> member alias of a tuple is the type representing all
but the first item in the tuple. We alias <code class="docutils literal notranslate"><span class="pre">rest_type</span></code> in
<code class="docutils literal notranslate"><span class="pre">tuple_element</span></code> to recursively refer to a <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code> with a
decremented index and the <code class="docutils literal notranslate"><span class="pre">rest_type</span></code> of the tuple. We then arrange
to retrieve the item from this recursive instantiation. The
constructor creates a smaller <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code> and initializes
<code class="docutils literal notranslate"><span class="pre">item</span></code> to refer to the item contained in the smaller
<code class="docutils literal notranslate"><span class="pre">tuple_element</span></code>. We similarly alias <code class="docutils literal notranslate"><span class="pre">type</span></code> to refer to the
<code class="docutils literal notranslate"><span class="pre">type</span></code> contained in the smaller <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code>.</p>
<p>The following is an alias template for the type of a tuple element:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Tuple</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">tuple_element_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">tuple_element</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</pre></div>
</div>
<p>We can now write a function template to retrieve an item out of a
tuple:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Types</span><span class="o">&gt;</span>
<span class="n">tuple_element_t</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">(</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The work is offloaded to the <code class="docutils literal notranslate"><span class="pre">tuple_element</span></code> class template, out of
which we retrieve both the type of the element and the element itself.
But since <code class="docutils literal notranslate"><span class="pre">get</span></code> is implemented as a function template, we can rely
on argument deduction for its second template parameter:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tuple</span><span class="p">(</span><span class="mf">4.9</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">4.9</span>
<span class="n">c</span>
<span class="mi">3</span>
<span class="mf">5.9</span>
<span class="n">d</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>The standard library provides a definition of <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, allowing it
to contain zero items, along with <code class="docutils literal notranslate"><span class="pre">make_tuple()</span></code> and <code class="docutils literal notranslate"><span class="pre">get()</span></code> in
the <code class="docutils literal notranslate"><span class="pre">&lt;tuple&gt;</span></code> header.</p>
</section>
</section>
<section id="example-multidimensional-arrays">
<h1>Example: Multidimensional Arrays<a class="headerlink" href="#example-multidimensional-arrays" title="Link to this heading"></a></h1>
<p>As an extended example of using metaprogramming to build a complex
system, let’s consider the implementation of a multidimensional array
library in C++. Built-in C++ arrays are very limited: they represent
only a linear sequence of elements, and they do not carry any size
information. Multidimensional arrays can be represented by arrays of
arrays, but this representation can be cumbersome to use and can
suffer from poor spatial locality. Instead, most applications
linearize a multidimensional array and map a multidimensional index to
a linear index. We will use this strategy, but we will abstract the
translation logic behind an ADT interface.</p>
<section id="points">
<h2>Points<a class="headerlink" href="#points" title="Link to this heading"></a></h2>
<p>We start with an abstraction for a multidimensional index, which we
call a <em>point</em>. A point consists of a sequence of integer indices,
such as <span class="math notranslate nohighlight">\((3, 4, 5)\)</span> for a three-dimensional index. We define
a point template as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The template is parameterized by the dimensionality of the point, and
its data representation is an array of coordinates. We overload the
index operator for both <code class="docutils literal notranslate"><span class="pre">const</span></code> and non-<code class="docutils literal notranslate"><span class="pre">const</span></code> points.</p>
<p>We provide a stream-insertion operator overload as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to work with points, it is useful to have point-wise
arithmetic operations on points, as well as comparison operators. For
instance, the following are possible definitions of addition and
equality:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a lot of similarity between these two functions: they share
the same template header, arguments, and overall body structure, with
an initial value, a loop to update the value, and a return of that
value. Rather than writing several arithmetic and comparison
operations with this structure, we can use a function-like macro to
abstract the common structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define POINT_OP(op, rettype, header, action, retval)           \</span>
<span class="cp">  template &lt;int N&gt;                                              \</span>
<span class="cp">  rettype operator op(const point&lt;N&gt; &amp;a, const point&lt;N&gt; &amp;b) {   \</span>
<span class="cp">    header;                                                     \</span>
<span class="cp">    for (int i = 0; i &lt; N; i++)                                 \</span>
<span class="cp">      action;                                                   \</span>
<span class="cp">    return retval;                                              \</span>
<span class="cp">  }</span>
</pre></div>
</div>
<p>Then an arithmetic operators such as <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code> can be defined as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">POINT_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">         </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="n">POINT_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">         </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>These in turn are very similar, with the only difference the two
occurrences of <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code>. We can then abstract this structure
further for arithmetic operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define POINT_ARITH_OP(op)                      \</span>
<span class="cp">  POINT_OP(op, point&lt;N&gt;, point&lt;N&gt; result,       \</span>
<span class="cp">           result[i] = a[i] op b[i], result)</span>
</pre></div>
</div>
<p>Similarly, we can abstract the structure for comparison operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define POINT_COMP_OP(op, start, combiner)                      \</span>
<span class="cp">  POINT_OP(op, bool, bool result = start,                       \</span>
<span class="cp">           result = result combiner (a[i] op b[i]), result)</span>
</pre></div>
</div>
<p>We can now use these macros to define the point operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">POINT_ARITH_OP</span><span class="p">(</span><span class="o">+</span><span class="p">);</span>
<span class="n">POINT_ARITH_OP</span><span class="p">(</span><span class="o">-</span><span class="p">);</span>
<span class="n">POINT_ARITH_OP</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>
<span class="n">POINT_ARITH_OP</span><span class="p">(</span><span class="o">/</span><span class="p">);</span>

<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">==</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">!=</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="o">||</span><span class="p">);</span>
<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">&lt;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">POINT_COMP_OP</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>Compared to writing ten separate functions, this strategy has much
less repetition.</p>
<p>One last operation that would be useful is to construct a point of the
desired dimensionality from a sequence of coordinates, analogous to
<code class="docutils literal notranslate"><span class="pre">make_tuple()</span></code> from the previous section. We can define a variadic
function to do so as follows, giving it the name <code class="docutils literal notranslate"><span class="pre">pt()</span></code> for
succinctness:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Is</span><span class="o">&gt;</span>
<span class="n">point</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Is</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="n">Is</span><span class="p">...</span><span class="w"> </span><span class="n">is</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Is</span><span class="p">)</span><span class="o">&gt;</span><span class="p">{{</span><span class="w"> </span><span class="n">is</span><span class="p">...</span><span class="w"> </span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We use the <code class="docutils literal notranslate"><span class="pre">sizeof...</span></code> operator to compute the dimensionality. The
nested initializer lists are required, the outer one for the <code class="docutils literal notranslate"><span class="pre">point</span></code>
struct itself and the inner one for initializing its <code class="docutils literal notranslate"><span class="pre">coords</span></code>
member, since the latter is an array.</p>
<p>We can now perform operations on points:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">pt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-2</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">pt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="domains">
<h2>Domains<a class="headerlink" href="#domains" title="Link to this heading"></a></h2>
<p>The <em>domain</em> of an array is the set of points that it maps to
elements. A domain is <em>rectangular</em> if the start and end index for
each dimension is independent of the indices for the other dimensions.
Thus, an array over a rectangular domain maps a rectangular region of
space to elements.</p>
<p>We can represent a rectangular domain by an inclusive lower-bound
point and an exclusive upper-bound point:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectdomain</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lwb</span><span class="p">;</span><span class="w"> </span><span class="c1">// inclusive lower bound</span>
<span class="w">  </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">upb</span><span class="p">;</span><span class="w"> </span><span class="c1">// exclusive upper bound</span>

<span class="w">  </span><span class="c1">// Returns the number of points in this domain.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lwb</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">upb</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// multiple by the span of each dimension</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">upb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lwb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can define an iterator over a rectangular domain as follows,
writing it as a nested class within the <code class="docutils literal notranslate"><span class="pre">rectdomain</span></code> template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectdomain</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">iterator</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lwb</span><span class="p">;</span><span class="w"> </span><span class="c1">// inclusive lower bound</span>
<span class="w">    </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">upb</span><span class="p">;</span><span class="w"> </span><span class="c1">// inclusive upper bound</span>
<span class="w">    </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w"> </span><span class="c1">// current item</span>

<span class="w">    </span><span class="c1">// Returns the current point.</span>
<span class="w">    </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Moves this iterator to the next point in the domain.</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Increment starting at the last dimension.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// If this dimension is within bounds, then we are done.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">upb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Otherwise, reset this dimension to its minimum and move</span>
<span class="w">        </span><span class="c1">// on to the previous one.</span>
<span class="w">        </span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lwb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// We ran out of dimensions to increment, set this to an end</span>
<span class="w">      </span><span class="c1">// iterator.</span>
<span class="w">      </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">upb</span><span class="p">;</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Return an iterator that is set to the inclusive lower-bound</span>
<span class="w">  </span><span class="c1">// point.</span>
<span class="w">  </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">iterator</span><span class="p">{</span><span class="w"> </span><span class="n">lwb</span><span class="p">,</span><span class="w"> </span><span class="n">upb</span><span class="p">,</span><span class="w"> </span><span class="n">lwb</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Return an iterator that is set to the exclusive upper-bound</span>
<span class="w">  </span><span class="c1">// point.</span>
<span class="w">  </span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">iterator</span><span class="p">{</span><span class="w"> </span><span class="n">lwb</span><span class="p">,</span><span class="w"> </span><span class="n">upb</span><span class="p">,</span><span class="w"> </span><span class="n">upb</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The iterator keeps track of the lower and upper bounds, as well as the
current point. Incrementing an iterator increments the last coordinate
of the current point, and if that reaches the upper bound for that
coordinate, it is set to the lower bound and the previous coordinate
is incremented instead. This process is repeated as necessary, and if
the first coordinate reaches its upper bound, the iterator reaches the
end.</p>
<p>We can now use rectangular domains as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rectdomain</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>This results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Link to this heading"></a></h2>
<p>We can now proceed to define an ADT for a multidimensional array. We
can represent it with a rectangular domain and a C++ array to store
the elements. We also keep track of the size of each dimension for the
purposes of index computations. The following is an implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ndarray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rectdomain</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">domain</span><span class="p">;</span><span class="w"> </span><span class="c1">// domain of this array</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w">         </span><span class="c1">// cached size of each dimension</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w">              </span><span class="c1">// storage for the elements</span>

<span class="w">  </span><span class="c1">// Constructs an array with the given domain, default initializing</span>
<span class="w">  </span><span class="c1">// the elements.</span>
<span class="w">  </span><span class="n">ndarray</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rectdomain</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dom</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">domain</span><span class="p">(</span><span class="n">dom</span><span class="p">),</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">dom</span><span class="p">.</span><span class="n">size</span><span class="p">()])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Compute and store sizes of each dimension.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">upb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Copy constructor does a deep copy.</span>
<span class="w">  </span><span class="n">ndarray</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ndarray</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">domain</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">domain</span><span class="p">),</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">domain</span><span class="p">.</span><span class="n">size</span><span class="p">()])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">sizes</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">sizes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Assignment operator does a deep copy.</span>
<span class="w">  </span><span class="n">ndarray</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ndarray</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">this</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">domain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">domain</span><span class="p">;</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">domain</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">sizes</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">sizes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Destructor deletes the underlying storage and the elements</span>
<span class="w">  </span><span class="c1">// within.</span>
<span class="w">  </span><span class="o">~</span><span class="n">ndarray</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Translates a multidimensional point index into a</span>
<span class="w">  </span><span class="c1">// single-dimensional index into the storage array.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">indexof</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Returns the element at the given multidimensional index.</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">indexof</span><span class="p">(</span><span class="n">index</span><span class="p">)];</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Returns the element at the given multidimensional index.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">indexof</span><span class="p">(</span><span class="n">index</span><span class="p">)];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class template is parameterized by the element type and
dimensionality. A constructor takes in a rectangular domain, allocates
an underlying array of the appropriate size to hold the elements, and
stores the size of each dimension. <a class="reference external" href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)">The Big Three</a>
are implemented as needed. (We elide the move constructor and move
assignment operator for simplicity.) We then have a function to
translate a multidimensional index into a linear one, which the
overloaded index operators use to obtain an element.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">indexof()</span></code> function uses the combination of the input point and
the size of each dimension to linearize the index. In our
representation, the array is stored in <em>row-major format</em>, so that the
last dimension is the contiguous one:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ndarray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;::</span><span class="n">indexof</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the value of <code class="docutils literal notranslate"><span class="pre">N</span></code> is a compile-time constant, this loop can be
trivially unrolled by the compiler, eliminating any branching and
resulting in a faster computation.</p>
</section>
<section id="stencil">
<h2>Stencil<a class="headerlink" href="#stencil" title="Link to this heading"></a></h2>
<p>We can now use arrays to perform a <em>stencil computation</em>, which
iteratively computes the value of a grid point based on its previous
value and the previous values of its neighbors. <a class="reference internal" href="#figure-life"><span class="std std-numref">Figure 45</span></a>
is an example of a stencil update associated with <a class="reference external" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of
Life</a>, on a
<span class="math notranslate nohighlight">\(3 \times 3\)</span> grid.</p>
<figure class="align-center" id="id5">
<span id="figure-life"></span><a class="reference internal image-reference" href="_images/life.svg"><img alt="_images/life.svg" src="_images/life.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Figure 45 </span><span class="caption-text">Stencil update associated with Conway’s Game of Life.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>We use two grids, one for the previous timestep and one for the
current one. We use <em>ghost regions</em> at the edges of the grids,
extending each edge by an extra point, to avoid having to do separate
computations at the boundaries.</p>
<p>The following constructs three-dimensional grids of size <span class="math notranslate nohighlight">\(xdim
\times ydim \times zdim\)</span>, with ghost regions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rectdomain</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">domain</span><span class="p">{</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="n">xdim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ydim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">zdim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">};</span>
<span class="n">rectdomain</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">interior</span><span class="p">{</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="n">xdim</span><span class="p">,</span><span class="w"> </span><span class="n">ydim</span><span class="p">,</span><span class="w"> </span><span class="n">zdim</span><span class="p">)</span><span class="w"> </span><span class="p">};</span>
<span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gridA</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
<span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gridB</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
</pre></div>
</div>
<p>We initialize the grids as needed and then perform an iterative
stencil computation as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">probe</span><span class="p">(</span><span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">gridA_ptr</span><span class="p">,</span>
<span class="w">           </span><span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">gridB_ptr</span><span class="p">,</span>
<span class="w">           </span><span class="k">const</span><span class="w"> </span><span class="n">rectdomain</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">interior</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gridA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">gridA_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">ndarray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gridB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">gridB_ptr</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">interior</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">gridB</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">WEIGHT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Swap pointers</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">gridA_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">gridB_ptr</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We make use of iteration over a rectangular domain, arithmetic over
points, and using points to index into the multidimensional array. At
the end of each timestep, we swap which grid is the current and which
is the previous.</p>
<p>While this code is simple to write, it does not perform well on many
compilers. The linearized iteration over the rectangular domain can
prevent a compiler from optimizing the iteration order to make the
best use of the memory hierarchy, such as with a <a class="reference external" href="https://en.wikipedia.org/wiki/Polytope_model">polyhedral analysis</a>. In GCC, for example,
we find that a nested loop structure such as the following can be five
times more efficient:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">upb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">upb</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">lwb</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">interior</span><span class="p">.</span><span class="n">upb</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">gridB</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">WEIGHT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code is less simple, and it introduces a further dependency on
the dimensionality of the grid, preventing us from generalizing it to
an arbitrary number of dimensions.</p>
</section>
<section id="nested-iteration">
<h2>Nested Iteration<a class="headerlink" href="#nested-iteration" title="Link to this heading"></a></h2>
<p>In order to solve the problem of linearized iteration, we can use
metaprogramming to turn what appears to be a single loop into a nested
one, making it more amenable to analysis and optimization. We start
by writing a recursive template that introduces a loop nest at each
level of the recursion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rdloop</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Performs a nested loop over the set of loop indices in [lwb,</span>
<span class="w">  </span><span class="c1">// upb). The size of lwb and upb must be at least N. For each</span>
<span class="w">  </span><span class="c1">// index i1, ..., iN in [lwb, upb), calls func on the point</span>
<span class="w">  </span><span class="c1">// pt(is..., i1, ..., iN).</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Func</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Indices</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">loop</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Func</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lwb</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">upb</span><span class="p">,</span><span class="w"> </span><span class="n">Indices</span><span class="p">...</span><span class="w"> </span><span class="n">is</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">lwb</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">upb</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">rdloop</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="o">&gt;::</span><span class="n">loop</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">lwb</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">upb</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">is</span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We write our template as a class, since we will require a base case
and would need partial function-template specialization, which is not
supported by C++, to implement it purely with function templates. The
class is parameterized by the dimensionality. Within the class is a
single static member function template that is parameterized by a
functor type and a variadic set of indices. The arguments to the
function itself are a functor object, which will be applied in the
innermost loop, lower and upper bounds for the remaining dimensions,
and the set of indices computed so far.</p>
<p>The body introduces a new loop nest, using the lower and upper bounds,
and recursively applies the template with one less dimension. The
bound pointers are adjusted for the new dimension, and we pass the
input indices along with the one for this dimension in the recursive
call. Our base case, where there is only a single dimension, is then
as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rdloop</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Func</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Indices</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">loop</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Func</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lwb</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">upb</span><span class="p">,</span><span class="w"> </span><span class="n">Indices</span><span class="p">...</span><span class="w"> </span><span class="n">is</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">lwb</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">upb</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">func</span><span class="p">(</span><span class="n">pt</span><span class="p">(</span><span class="n">is</span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We construct a point from the collected set of indices from each
dimension and then call the functor object on that point.</p>
<p>Now that we have a mechanism for constructing a set of nested loops,
we start the recursion from a function object and domain as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rdloop</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;::</span><span class="n">loop</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">lwb</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span>
<span class="w">                </span><span class="n">domain</span><span class="p">.</span><span class="n">upb</span><span class="p">.</span><span class="n">coords</span><span class="p">);</span>
</pre></div>
</div>
<p>In order to actually make use of this, we provide a loop abstraction
as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">interior</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">gridB</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pt</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">)]</span><span class="w"> </span><span class="o">+</span>
<span class="w">    </span><span class="n">WEIGHT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridA</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We have the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> keyword, which we will define shortly, that
takes in a variable name to represent a point and the domain over
which to iterate. We then have a loop body that uses the point
variable. A semicolon appears after the body, and it is necessary due
to how <code class="docutils literal notranslate"><span class="pre">foreach</span></code> is defined.</p>
<p>The loop body looks very much like the body of a lambda function, and
since we require a function object in order to build the nested
structure, it is natural to consider how we can arrange for the loop
body to turn into a lambda function. We need a statement in which a
lambda function can appear at the end, right before the terminating
semicolon, and assignment fits this structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&lt;</span><span class="n">capture</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Thus, we need to arrange for the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> header to turn into the
beginning of this statement:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&lt;</span><span class="n">capture</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>We would like the programmer to be able to use all local variables, so
we should capture all variables by reference. The <code class="docutils literal notranslate"><span class="pre">foreach</span></code> also
introduces a new variable for the point, so that should be in the
parameter list:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">point</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are several remaining things we need. First, we need to figure
out the dimensionality of the point to use as the parameter. We can
use <code class="docutils literal notranslate"><span class="pre">decltype</span></code> to do so from the domain:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&lt;</span><span class="n">domain</span><span class="o">&gt;</span><span class="p">.</span><span class="n">lwb</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>Second, we need a way to ensure that when this assignment happens, the
nested loop structure is executed. We can do so by overloading the
assignment operator of the object <code class="docutils literal notranslate"><span class="pre">&lt;var&gt;</span></code>. Finally, we also need to
introduce the left-hand variable, preferably in its own scope. We can
do both by introducing a dummy loop header:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define foreach(p, dom)                                           \</span>
<span class="cp">  for (auto _iter = (dom).iter(); !_iter.done; _iter.done = true) \</span>
<span class="cp">    _iter = [&amp;](const decltype((dom).lwb) &amp;p)</span>
</pre></div>
</div>
<p>In order for this to work, we need the <code class="docutils literal notranslate"><span class="pre">iter()</span></code> method on a domain
to give us an object whose assignment operator takes in a functor. This
operator would then call the functor within a nested set of loops. The
object also needs a <code class="docutils literal notranslate"><span class="pre">done</span></code> field in order to ensure the dummy loop
executes exactly one iteration. We can add the following members to
the <code class="docutils literal notranslate"><span class="pre">rectdomain</span></code> template:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rectdomain</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">fast_iter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">rectdomain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">domain</span><span class="p">;</span><span class="w"> </span><span class="c1">// domain over which to iterate</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">done</span><span class="p">;</span><span class="w">                </span><span class="c1">// whether or not this loop has run</span>

<span class="w">    </span><span class="c1">// Constructs a fast_iter with the given domain.</span>
<span class="w">    </span><span class="n">fast_iter</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">rectdomain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dom</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">domain</span><span class="p">(</span><span class="n">dom</span><span class="p">),</span><span class="w"> </span><span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Loops over the associate domain, calling func on each point</span>
<span class="w">    </span><span class="c1">// in the domain.</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Func</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">fast_iter</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Func</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">rdloop</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;::</span><span class="n">loop</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">domain</span><span class="p">.</span><span class="n">lwb</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span>
<span class="w">                      </span><span class="n">domain</span><span class="p">.</span><span class="n">upb</span><span class="p">.</span><span class="n">coords</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// Returns a fast_iter over this domain.</span>
<span class="w">  </span><span class="n">fast_iter</span><span class="w"> </span><span class="nf">iter</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fast_iter</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The assignment operator of <code class="docutils literal notranslate"><span class="pre">fast_iter</span></code> is a template, taking in a
functor object. It then uses our nested loop generation mechanism to
generate a set of nested loops and call the functor from the innermost
loop, with the appropriate point as the argument.</p>
<p>The result is a loop that has the simplicity of a range-based for loop
but, depending on the compiler, the performance of a nested set of
loops. As an example, with GCC 6.2 on the author’s iMac computer, the
range-based for loop takes 1.45 seconds to perform ten timesteps of
the stencil above on a <span class="math notranslate nohighlight">\(256^3\)</span> grid, while the nested loops and
the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop each take 0.28 seconds. This demonstrates the
power of metaprogramming in order to extend the features of a
language.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="declarative.html" class="btn btn-neutral float-left" title="Logic Programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="concurrent.html" class="btn btn-neutral float-right" title="Parallel Computing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Amir Kamil, licensed under the Creative Commons Attribution-ShareAlike 4.0 International license.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org/">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>

<!-- Mirrored from eecs390.github.io/notes/metaprogramming.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 19 Mar 2024 18:15:53 GMT -->
</html>